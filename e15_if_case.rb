puts '                                    Условные операторы(if, unless и case when)'

#“Бранчинг”, “ветвление” - от англ.слова branch - ветвь. Подразумевается, что существует одна или более “ветвей” - участков кода, которые выполняются в зависимости от результата какого-либо сравнения.
#“Ветка”, “блок”, “бранч” - участок кода, который, возможно, будет исполнен при соблюдении некоторого условия.
#“Сравнение”, “тест” - непосредственно сама процедура сравнения,“тестирование” переменной на определенное значение.

# Операторы case упрощают управление потоком программы. Операторы if должны всегда использоваться для определения верно ли условие, а операторы case используются когда необходимо сделать различные решения основанные на значении.


puts '                                          Операторы if'

# Условие выражения if отделяется от кода зарезервированным словом then , новой строкой или точкой с запятой.
x, y = 9, 12
# Можно проверять на < > >= <= == != и другие условия
if x < y then # then писать не обязательно
  puts ("Икс меньше чем игрик")
  puts ("x < y")
end # Если условие в строке с if не выполняется то ничего не выводится(будто обращения к if не было)


# Примеры с булевыми переменными true и false(Значения false и nil ложны, а все остальное истинно)
isSmall = true

if isSmall == true
  puts ("OK")
end #=> "OK"

if isSmall # Ничего не указывая после переменной, по умолчанию проверяет на ее верность или существование
  puts ("OKe")
end #=> "OKe"

if !isSmall # знак отрицания ! можно ставить перед переменной вместо isSmall != true, тогда проверяет false
  puts ("no OK")
end


puts
# if возвращает значение, поэтому его можно присвоить в переменную
x = 1
name = if x == 1
	"one"
end
name #=> "one"


puts
puts '                                    Операторы and(&&) и or(||)'

# &&(and) - логическое и
# ||(or) - логическое или

# При нескольких условиях сначала проверяет первое, потом 2е итд слева направо
if isSmall == true and x == 9 # Можно объединять операции при помощи and значит и(выполняются оба)
  puts ("OK-2")
end

if isSmall == true or x != 9 # Обьединение при помощи or значит или(выполняется хотя бы одно)
  puts ("OK ili")
end

# Допольнительно. Во всех языкаx у 'or' и  '||' разные приоритеты, Ruby - не исключение. Для интерпрератора это выглядит так
p false or true #=> false <= (p false) or true
p false || true #=> true <= p (false || true)
# Если обернуть оба выражения в скобки, то будет true true
p nil || 6 #=> 6
p 123 || 567 #=> 123

# инициализация переменной
per = nil || 2 #=> 2
per #=> 2
per2 = per2 || 5 #=> 5
per2 #=> 5
per3 ||= 9 #=> 9
per3 #=> 9

x = 1
x = 5 || x #=> 5   # выбирает 1е

puts
# Множественное присвоение при помощи оператора and
a = 1 and b = 2
p [a,b] #=> [1, 2]


puts
puts '                                         Операторы elsif else'

# elsif без условия тоже самое что и else

x, y = 20, 12
if x == y
  puts "x = y"
elsif x > y # Оператор альтернативного условия elsif, запускается если предыдущее условие не выполнено(иначе если)
  puts "x > y"
  #Условный оператор внутри условного оператора
  if y == 12 # Если проверка "материнского" оператора прошла, то выпоняется проверка его внутреннего оператора
    puts "y = 12"
  end
elsif x == 5 # Операторов elsif может быть сколько угодно
  puts "Икс равно 5"
elsif x == 20 # Если несколько условий верные, будет выполнено только первое условие
  puts "Икс равно 20"
else #(иначе) Оператор else срабатыает если все условия после if и после elsif не выпоняются
  puts "x не= y"
end


puts
puts '                                       if в одну строку после чего либо'

# Можно задавать условие для возврата(или выполнения какого либо действия) после этого действия оператором if в одну строку
'abc' if true #=> abc
'abc' if false #=> nil
'world is not crazy' if 2 + 2 == 4 #=> world is not crazy

day = '1'
'Понедельник' if day == '1' #=> Понедельник

# Множественное присвоение при помощи оператора and и if
a,b,c = 10,50,0
a = 1 and b = 2 if c == 0 #=> 1 2
p [a,b] #=> [1, 2]

# Использование с методом для хэшей(очень распространенный вариант использования)
def print_detalis(detalis)
  puts detalis[:name] if detalis[:name]
  puts detalis[:age] if detalis[:age]
  puts detalis[:address] if detalis[:address]
  puts detalis[:phone] if detalis[:phone] # В итоге не будет ошибки(и/или nil) изза того что элемента :phone не существует
end
hh = { :name => 'Mike', :age => 45, :address => '123 West Street' }
print_detalis(hh) #=> Mike   45   123 West Street


puts
puts "                                             Оператор unless then"

# Иногда вместо if используют unless он имеет абсолютно такой же синтаксис как if, но выполняется если условии не верно
unless x > 3 then # Unless означает «Если условие не выполняется, то...»
  puts x.to_s  # Выведет значение x, если оно НЕ больше трёх.
else # Выполняется если условие верно
  puts "очень много, не сосчитать"
end

puts
# Unless в одну строку
age = 25
puts "You are a minor" unless age <= 18


puts
puts '                                             Тернарный оператор'

# Тернарный оператор (ternary operator) встречается довольно часто и обычно является однострочной альтернативой (иногда говорят "one-liner") конструкции "if...else".
# Конструкция: условие ? если_true : если_false (Если условие выполнено, сработает то, что стоит между вопросиком и двоеточием, если не выполнено — то, что после двоеточия)
# тернарный оператор выглядит хорошо только тогда, когда нужно выполнить только одну инструкцию. Для нескольких методов подряд лучше использовать конструкцию "if...else".

# С помощью тернарного оператора код можно сократить так:
a > b ? puts("Одна строка") : puts("Другая строка")
# Или даже так:
puts a > b ? "Одна строка" : "Другая строка"
# Можно было бы записать ещё вот так:
if a > b then puts "Одна строка" else puts "Другая строка" end # Но это считается плохим стилем.
# Предпочитайте тернарный оператор конструкциям с if/then/else/end. Он используется чаще и по определению более краток.

# Несколько условий:
puts (a < b && c != 5) ? "go party" : 'stay home'

# Тернареый оператор с более чем 2мя условиями
arr == arr.sort ? 'yes, ascending' : arr == arr.sort.reverse ? 'yes, descending' : 'no'
# условие в условии(скобки не обязательны)
x>0 ? (y>0 ? 1 : 4) : (y>0 ? 2 : 3)


puts
# У тернарного оператора в ruby один из самых низких приоритетов, ниже — только у операций присваивания, управляющих конструкций, блоков и т.д. Об этом важно помнить, когда его используете:
condition = true
result = 'first ' + condition ? 'second' : '2'  #=> in `+': no implicit conversion of true into String (TypeError)
# Используйте скобки:
result = 'first ' + (condition ? 'second' : '2') #=> "first second"


puts
# Результат выражения с тернарным оператором можно также записать в переменную. Например:
x = is_it_raining?()
result = x ? stay_home() : go_party()
# `result` будет содержать результат выполнения операции `stay_home` или `go_party`.

# Это также справедливо и для конструкции "if...else":
x = is_it_raining?()
result = if x
  stay_home()
else
  go_party()
end
# Результат выполнения метода `stay_home` или `go_party` будет записан в переменную `result`.


puts
puts '                                              Оператор case when'

# Оператор множественного выбора case-when обеспечивает выбор из нескольких альтернатив, каждая из которых может задаваться отдельным значением, набором значений или диапазоном:
# Условный оператор case удобно использовать при большом колличестве вариантогв boolean условий. Не работает с методами(напр <, >=) в условиях, но работает с диапазонами.
# Сложные ветвления и case лучше избегать. Лучше использовать с простыми перечислениями
# Выражение оператора when отделяется от кода зарезервированным словом then, новой строкой или точкой с запятой.
day = '7'
case day # Проверяем переменную day
when "1" # Когда переменная равна заданному значению...
  nameOfDay = "Понедельник" # ...то работает этот код
when "2"
  nameOfDay = "Вторник"
# Для перехода от условию у исполняемому коду можно использовать 1.перевод строки ...
when "3"
  nameOfDay = "Среда"
# ... 2.Оператор then ...
when "4" then nameOfDay = "Четверг"
# ... либо 3.Точку с запятой
when "5"; nameOfDay = "Пятница"
# Оператор else для оператора case when работает так же как и для оператора if
else
  nameOfDay = "Выходной"
end
puts nameOfDay #=> Выходной
# Альтернативы в операторе case проверяются последовательно, выбирается первая ветвь, для которой условие соответствует списку значений или диапазону


puts
# Каждый оператор when может иметь несколько возможных значений, разделенных запятыми.
# Запятая в case это аналог ||(or) в if
x = rand(1..3)
case x
when 1,2,3
  puts "1, 2, or 3"
when 10
  puts "10"
else
  puts "Some other number"
end

# С диапазонами в условиях
num = rand(0..100)
case num
when (20..25)
  puts 1
when (25..)
  puts 2
end

# case-when можно запустить без передачи в case аргумента но с дополнением условия в поле when, тогда будет возможно выполнение логических операций.
num = 11
case
when num.odd?
  puts 'odd'
when num.even?
  puts 'even'
end

# Альтернативный вариант запмси без аргумента. Тогда выполнится первое when которое вернет true.
x = 1
case
  puts "x equal one" when x == 1
  puts "x equal two" when x == 2
end


# case in - проверяет принадлежность обоих значений по порядку расположения
def quadrant(x, y)
  case [x, y]
    in [0.., 0..] then 1
    in [..0, 0..] then 2
    in [..0, ..0] then 3
    in [0.., ..0] then 4
  end
end
p quadrant(5, 3) #=> 1
p quadrant(-20, 3) #=> 2
p quadrant(-1, -1) #=> 3
p quadrant(5, -1) #=> 4
