puts '                                        Клиент серверная архитектура'

# https://www.youtube.com/watch?v=XaTwnKLQi4A

# Сервер выступает единым источником(поставщиком) данных, вычислений, бизнеслогики итд и большое коллич клиентов(потребителей) к этому серверу обращаются.
# Клиентом может быть браузер, мобильное приложение и другой сервер

# Для клиента сервер выступает единым источником, но при этом он может быть распределенным или состоять из многих микросервисов.


puts
puts '                                            HTTP и виды запросов'

# HTTP - гипертекстовый транспортный протокол, который находится на самом верхнем уровне(уровне приложений) сетевой модели OSI/ISO или TCP/IP. Именно при помощи HTTP общаются большинство приложений в интернете

# Первоначальная идея HTTP это обмен гипертекстовыми документами (HTML), но сейчас при помощи него можно передавать практически любые данные(текстовые, фаиловые, html, xml, json)


# методы запроса:
# GET, POST можно отправлять с помощью формы: <form aсtion="GET".../<form ation="POST"...
# PUT, PATCH, DELETE отправляются через POST, но с добавлением скрытой переменной(поля).

# GET запрос(request) от браузера серверу на получение данных / запрос о том что браузер хочет получить какую-то страницу(ресурс). Так же он содержит инфу о кодировках и языках поддерживаемых браузером. На этот запрос от сервера приходит ответ в виде данных запрашиваемой страницы/картинки/ресурса(ее html/css/... код) или об ошибке и некорректности запроса(например 404 страница не найдена)
# GET на самом деле тоже отправляет данные, но только данные пакета запроса(1 килобайт или типа того)
# Можно дополнительно передать данные(оч небольшие), эти данные будут видны в строке запрса(после знака ?), например:
#     /cart?product_1=4,product_2=7,product_3=4,
# в адресе запроса после ? будут видны параметры, которые разделяются знаком &
#     www.yandex.ru/search/?text=запорожская+аэс&lr=37129&search_source=chromentp_desktop&src=suggest_Pers
# Это результат того что форма указывает на GET-запрс <form aсtion="GET"...

# POST запрос(request) от браузера серверу на отправку данных на сервер(создание ресурса) - используется для отправки браузером данных на сервер(например ввод пароля, отправка сообщения на форум, залив картинки или видео). Так же содержит служебную информацию
# Отправляет данные на конкретный URL

# PUT - метод запроса на обновление ресурса целиком

# PATCH - метод запроса на обновление фрагмента ресурса(частичное обновление ресурса)

# DELETE - метод запроса на удаление ресурса

# GET/POST итд - это условное деление (конвенция), о которой просто договорились. Тоесть ничего не мешает создавать ресурс, например через GET

# Любой запрос в интернете - это по сути серия запросов/ответов клиента и сервера, который содержит заголовки (header), тело (body) и всякую служебную информацию.

# Пример POST-запроса(построчно):
# 1. POST /blog/ HTTP/1.1    -  стартовая строка, состоит из 3х частей(POST - метод, /blog/ - юрл, HTTP/1.1 - версия http)
# 2. Host: htmlacademy.ru
#    Contett-Tipe: application/x-www-form-urlencoded; charset=utf-8
#    Content-Length: 26      -  заголовки(headers), есть обязательные и необязательные, можно добавить и свои кастомные. В заголовках указывается информация о хосте, браузере, типе устройства с которого отправлен запрос, о типе контента, авторизационные заголовки с токенами. Так же с помощью заголовков обеспечивают безопасность взаимодействия различных источников сети.
# 3. {
#     login=user
#     password=qwerty
#   }                        - тело сообщения(body), в нем клиент отправляет серверу какието данные

# Пример ответа сервера(построчно) на запрос выше:
# 1. HTTP/1.1 200 OK         - строка статуса(в ответе сервера есть она но нет стартовой строки). Помимо версии http она возвращает статус код(200 OK), который определяет успешно был выполнен запрос или нет
# 2. Contett-Tipe: application/json
#    Connection: Closed      - хэдеры ответа
# 3. {
#     message: 'success login',
#     user: {id:'1', username ... }
#   }                        - тело сообщения(body), в котором сервер возвращает клиенту какието данные

# Статус код(например 200 OK) - сообщает о том как был обработан запрос. Существует 5 групп статус кодов:
# 1xx - Informational(информационные). Например 100, 101 итд
# 2xx - Success(успешно).              Значит что запрос выполнен успешно, например 200.
# 3xx - Redirection(перенаправление).  Например мы успешно залогинелись и сервер нас перенаправляет на другую страницу
# 4xx - Client Error(ошибка клиента).  Например клиент передал неправильные данные(400) или ресурс не найден(404)
# 5xx - Server Error(ошибка сервера).  Чтото пошло не так на сервере
# Статус коды это про семантику, тоесть мы можем послать и другой, но договорились как выше


# Идемпотентность запросов - если многократная отправка запроса приводит к одному и тому же эффекту. Например мы обновляем ресурс при помощи PUT запроса с одними и теми же данными, то сервер каждый раз должен его исполнить одинаково
# Корректно реализованные методы GET, PUT, DELETE - идемпотентны; но не метод POST, тк во многих случаях создаст новую сущность идентичную предыдущей


# Можно так же отправлять запросы вручную(тк они отправляются в текстовом виде) при помощи спец программ(пр telnet) например самый простой запрос(в консоли telnet ya.ru 80) - GET /HTTP/ 1.0  и получим ответ например код страницы


puts
puts '                                            Сервер. Состояния'

# SERVER(от слова служить) - сервер только обслуживает и возвращает на наш запрос, а сам никому ничего не отправляет


# Сервер не видит разницы между различными пользователями, разница оценивается на уровне приложения, тк на сервере может быть много приложений и он возвращает на запрос то что возвращает приложение. Соотв state(состояние) поддерживается приложением а не сервером.

# https://stackoverflow.com/questions/13200152/why-is-it-said-that-http-is-a-stateless-protocol

# stateless (без состояния) (сервер не присваивает никакого специального значения и не распознает запрос по соединению) — это протокол передачи данных, который относит каждый запрос к независимой транзакции, которая не связана с предыдущим запросом, то есть общение с сервером состоит из независимых пар запрос-ответ. Те при каждом следующем запросе клиент и сервер общаются как впервые. Те чтобы идентифицировать себя, клиент должен каждый раз отправлять всю необходимую полную информацию для этого

# HTTP - это протокол без состояния, т.к. сервер не прицепляет никакого специального значения.
# Например был раньше протокол IRC это протокол с состоянием, тк он всегда поддерживает соединение, а ни как HTTP в котором соединение есть только при запросах и ответах


puts
puts '                                                  Fiddler'

# Fiddler - прога для просмотра запросов(бесплатная). Устанавливается как прокси сервер, позволяет видеть все подключения и данные запросов.(https://vimeo.com/102869014 урок18)
# Аналог на маке - charles proxy

# Там можно посмотреть тело пост запросов(данные формы), там есть левые символы которые можно преобразовать в более читабельный вид при помощи - url unescape online (search query)

# Поэтому данные HTTP и небезопасны, тк условный админ вайфай сети офисной или просто сети локальной на работе таким же фидлером может считать инфу с паролей. Соотв по этому и стоит пользоваться HTTPS на котором запросы шифруются, но правда куда мы заходим все равно будет видно


puts
puts '                                        Схема работы HTTP протокола'

#  https://ru.wikipedia.org/wiki/Сетевая_модель_OSI
# http://lib.ru/WEBMASTER/rfc2068/ - документация для http можно изучить как работает http протокол


#                                Что происходит, когда вы вводите URL-адрес в браузере :

#      1. Разрешить домен(доменное имя например stackoverflow.com или ya.ru или localhost), если это не IP (запрос DNS) Браузер превращает доменное имя в IP-адрес(пр 	85.249.20.109  (IPv4)) и к нему подключается через порт

#      2. Откроет порт 80 по умолчанию, если не задан SSL и не переопределено двоеточием (http://host:port/).
# 127.0.0.1:80 это тоже самое что и 127.0.0.1 тоже самое что и localhost или localhost:80
# SSL - это подключение через защищенный канал например https://ya.ru

# Порты по умолчанию:
# 80 - http  например http://ya.ru
# 443 - https  например https://ya.ru
# Порт - это абстракция операционной системы или протокола(на самом деле никаких портов нет)
# 85.249.20.109:80  - можно добавить порт в конец IP-адреса

#      3. Отправляется запрос  для http://host/uri/here?other=stuff&too
# Пример запроса: использует и должен заканчиваться двумя символами возврата каретки и перевода строки (CrLf)
#   GET /uri/here?other=stuff&too HTTP/1.1
#   Host: host
#   Other: Headers, too.  Such as cookies
#   Header: Value

#      4. Получает ответ
# Пример ответа:
#   HTTP/1.1 200 OK
#   Other: Headers, too.  Such as cookies
#   Header: Value
#   <html>Actual HTTP payload is here, could be HTML data, downloaded file data, etc.

#     5. Соединение закрывается



# 1. Сначала компьютер ищет целевой хост. Если он существует в локальном кэше DNS, он использует эту информацию. В противном случае DNS-запрос выполняется до тех пор, пока не будет найден IP-адрес.
# 2. Затем ваш браузер открывает TCP-соединение с целевым хостом и отправляет запрос в соответствии с HTTP 1.1 (или может использовать HTTP 1.0, но обычные браузеры больше этого не делают).
# 3. Сервер ищет нужный ресурс (если он существует) и отвечает по протоколу HTTP, отправляет данные клиенту (=вашему браузеру)
# 4. Затем браузер использует парсер HTML для воссоздания структуры документа, которая позже будет представлена ​​вам на экране. Если он находит ссылки на внешние ресурсы, такие как изображения, файлы css, файлы javascript, они доставляются так же, как и сам HTML-документ.



# Упрощенный набросок, предполагающий простейший из возможных HTTP-запросов (без HTTPS, без HTTP2, без дополнений), простейший из возможных DNS, без прокси-серверов, IPv4 с одним стеком, только один HTTP-запрос, простой HTTP-сервер на другой конец, и никаких проблем на любом этапе. Почти нереалистичный сценарий, в реальном использовании почти всегда сложнее:

# 1.  браузер проверяет кеш; если запрошенный объект находится в кеше и является свежим, перейдите к #9
# кэш - это хранилище браузера на жеском диске, чтоб быстрее загружать страницы
# 2.  браузер запрашивает у ОС(операционной системы тк именно она превращает запрос в IP-адрес для браузера) IP-адрес сервера[(пункт 1 в самом вехнем списке)]
# 3.  ОС выполняет поиск DNS и отвечает на IP-адрес в браузере.
# 4.  браузер открывает TCP-соединение с сервером (этот шаг намного сложнее с HTTPS) [(пункт 2 в первом списке)]
# 5.  браузер отправляет HTTP-запрос через TCP-соединение[(пункт 3 в первом списке)]
# 6.  браузер получает HTTP-ответ и может закрыть TCP-соединение или повторно использовать его для другого запроса. [(пункт 4-5 в первом списке)]
# 7.  браузер проверяет, является ли ответ перенаправлением или условным ответом (коды состояния результата 3xx), запросом авторизации (401), ошибкой (4xx и 5xx) и т. д.; они обрабатываются иначе, чем обычные ответы (2xx)
# Может быть такой запрос который перенаправляет браузер, тогда браузер не завершает соединение а переходит туда куда перенаправили(можно сделать многократное перенаправление или зациклить, но в браузерах есть от этого защита)
# 8.  если ответ можно содержать в кеше, чтобы не перезагружать снова(некоторые документы можно содержать в кеше например картинки), ответ сохраняется в кеше. Но есть картинки с опцией перезагрузки(об этом сообщается в ответе сервера) например капча
# 9.  браузер декодирует ответ (например, если он заархивирован). Тк большинство серверов сейчас присылают ответ не в текстовом а в сжатом виде
# 10. браузер определяет, что делать с ответом (например, это HTML-страница, это изображение, это звуковой клип)
# 11. браузер отображает ответ или предлагает диалог загрузки для нераспознанных типов

# Кроме того, параллельно с этим происходит много других вещей (обработка введенного адреса, спекулятивная предварительная выборка, добавление страницы в историю браузера, отображение прогресса для пользователя, уведомление плагинов и расширений, рендеринг страницы во время ее загрузки, конвейеризация, отслеживание соединения для keep-alive, управление файлами cookie, проверка на наличие вредоносного контента и т. д.) — и вся операция становится на порядок сложнее с HTTPS (сертификаты, шифры и закрепление).


puts
puts '                                        Библиотека Net::HTTP'

# https://ruby-doc.org/stdlib-3.1.2/libdoc/net/http/rdoc/Net/HTTP.html - документация к библиотеке Net::HTTP


puts
puts '                                              Get запрос'

# Получить страницу по некому адресу и вывести ее на экран:

# Вариант1 - со стеками параметров(тут 'fighttime.ru', '/news.html')
require 'net/http'  # загрузка библиотеки(модуля) Net::HTTP
# теперь из модуля Net обращаемся к классу HTTP и его методу get:
page = Net::HTTP.get('fighttime.ru', '/news.html')  # метод get принимает 2 параметра 1 название домена и 2 путь по которому расположена сама страница
puts page #=> <!DOCTYPE html><html lang=en><meta charset=utf-8><meta ...  # Получаем HTML код запрашиваемой страницы


# Вариант 2 - со ссылкой, тк не очень удобно выводить длинные строки параметров
require 'net/http'
require 'uri'
uri = URI.parse "https://fighttime.ru/news.html" # помещаем в переменную новый объект созданный статическим методом
# URI - универсальный идентификатор ресурса / Universal Resource Identifier. Он называется так потому, что содержит в себе("http://localhost:4567/login﻿") 4 составляющих: протокол (http), имя хоста (localhost), порт (4567), путь (/login)
response = Net::HTTP.get(uri) # теперь этот объект мы может задать как параметр
puts response  #=>  <!DOCTYPE html> <html prefix="og: ... # Ответ почемуто немного другой(изза https ??)


puts
puts '                                              Post запрос'

# За отправку данных(например логина и пароля) (POST запрос) отвечает метод post_form класса: Net::HTTP
require 'net/http'
require 'uri'
uri = URI.parse('http://www.example.com/search.cgi')
# передаем методу post_form параметрами объекта URI и хэш с данными для POST запроса
# Делаем POST запрос/отправляем форму(как бы нажимаем кнопку ввести например логин и пароль):
response = Net::HTTP.post_form(uri, :login=>"ruby", "password"=>"50") # в хэше можно использовать как символы так и строки. данные в виде хэша отправляются как q=ruby&max=50
puts response # Запрос возвращает объект ответа сервера
puts response.body # body - оператор который выводит html код страницы из oбъекта ответа, без ненужной служебной информации
# response = Net::HTTP.post_form(uri, :x => "ruby").body   - как вариант можно было сделать и сразу


puts
# Проверяем при помощи оператора include? закрыт ли доступ('denied' в данном примере код страницы содержит именно такое значение если доступ закрыт) или нет после пост запрса с логином и паролем
require 'net/http'
require 'uri'
uri = URI.parse "https://rubyschool.us/router"
response = Net::HTTP.post_form(uri, login: 'aaa', password: 'ruby').body # оператор body можно ставить сразу тут
puts response.include?('denied') #=> true или false


puts
# Подбираем пароль при помощи запросов и програмы подборщика паролей
require 'net/http'
require 'uri'

def is_wrong_password?(password) # оформляем проверку доступа в виде функции
  uri = URI.parse "http://localhost:4567/login﻿"
  response = Net::HTTP.post_form(uri, username﻿: 'admin', password: password).body # передаем параметр в пост запрос
  response.include?('Wrong username or password, please try again') # возвращаем true или false
end

def find_password
  input = File.open("passwords.txt", "r")
  	while (line = input.gets)
      unless is_wrong_password?(line.strip) # передаем пароль в методе is_wrong_password? получаем true если неверный
        return line.strip
      end
      puts
  	end
  input.close
end

puts "Password is #{find_password}"












#
