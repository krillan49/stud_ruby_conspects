puts '                                  Helpers(хелперы/вспомогательные функции)'

# http://rusrails.ru/action-view-overview
# https://guides.rubyonrails.org/form_helpers.html

# Для каждого нового контроллера создается хелпер. Все хелперы расположены в каталоге /app/helpers/
module ArticlesHelper # хэлпер(является модулем) для контроллера Articles /app/helpers/articles_helper.rb
  # тут можно писать методы
end
# Один хелпер создаётся для одного контроллера, но все хелперы доступны всем контроллерам.

# app/helpers/application_helper.rb - главный хэлпер, в котором обычно пишут глобальные хэлперы использующиеся на разных страницах относящимся к разным моделям и контроллерам
module ApplicationHelper
end

# ?? Методы хэлперлов не действуют внутри контроллеров ??

# Хелпер - работает между контроллером и представлением. Чтобы не вставлять код в представление:
# В представлениях часто нужно писать какието участки кода, которые повторяются для разных представлений, тк на один контроллер у нас может быть несколько представлений(например у нас 5 представлений для контроллера Articles). Тк нет смысла дублировать один и тот же код во многих представлениях, то проще записать его в методе в хэлпере вызывать хэлпер в представление

# Логику в представлениях писать непринято, лучше выносить в хелперы. Представления предназначены для того, чтобы отображать данные. Нехорошо размазывать логику по всему приложению, лучше держать в одном месте(например в контроллерах).
# Много кода в представлении будет мешать фронтэндерам
# Код в представлениях трудно тестировать

# Хэлперы бывают встроенные в Рэилс изначально, но можно писать и собственные


puts
puts '                                      Встроенные хэлперы Rails'

# form_with - встроенный хэлпер для создания формы в виде

# link_to - позволяет вставлять ссылки и задавать им параметры(работает совместно с js-фаилом turbolinks)
link_to "Sign In", new_user_session_path

# Турбо конфирм
link_to 'Sign Out', destroy_user_session_path, data: { 'turbo-method': :delete, 'turbo-confirm': 'Выйти? Вы уверены?' }

# ссылка с блоклм(тут на путь '#') внутри тега которой несколько объектов, тут тег div, так же содержит дата-атрибуты для бутстрап
link_to '#', class: 'nav-link px-2 dropdown-toggle', data: {"bs-toggle": 'dropdown'} do
  tag.div '', class: "flag #{I18n.locale}-flag mt-1"
  t I18n.locale
end

# tag - позволяет прописывать тег, его значение и другие параметры
tag.div v, class: "alert", role: 'alert'
# .div - в представлении поместится тег div
# v  - значение/содержание тега

# debug, тут выведет список параметров, чтобы их отслеживать
debug(params)

# Преобразует введенный(например в поле) текст(@foo) в html, например заменяет "\n" на <br>
simple_format(@foo)

# autolinks - автоматическая подсветка ссылок ??

# А, также truncate - если есть длинная строка, то обрезается на строки под указанный размер:
truncate(@foo, length: 20)


puts
puts '                         Встроенные routes хэлперы(для URL). Именнованные маршруты'

# Их можно посмотреть в routes или открым несуществующий URL или по адресу http://localhost:3000/rails/info. Их можно использовать с хелпером link_to, чтобы строить теги <a> для навигации внутри приложения.

# Окончание хэлпера может быть _path или _url, например course_path, semesters_url – это routes helpers
# resourses_path  -  '/resourses'                   -   тоесть относительный маршрут
# resourses_url   -  'localhost:5000//resourses'    -   тоесть полный маршрут


root_path # для ссылок на главную(get '/' root в маршруте), может содержать параметры, например для локалей

url_for(locale: locale) # ??

# Если название контроллера не в множественном числе(без s на конце), то хэлпер для URL index будет называться не name_path а:
name_index_path
# при этом хэлпер для show будет называться стандартно


puts
puts '                            Кастомный хэлпер для вывода названия страницы во вкладке'

# На примере AskIt

# По умолчанию на вкладке страницы всегда только само название сайта заданное в head->title. Но красивее, чтоб помимо названия сайта там было и название страницы

# Напишем хэлпер, который будет помещен в лэйаут и будет принимать название конкретной страницы и добавлять его к названию сайта
# Хэлпер создадим глобальным в главном хэлпере app/helpers/application_helper.rb тк он будет использоваться на многих разных страницах
module ApplicationHelper

  # наш кастомный хэлпер для вывода названия страницы в зависимости от принятого параметра
  def full_title(page_title = "") # page_title = ""  - метод принимает название конкретной страницы
    if page_title.present? # теперь если название страницы существует(значение переменной установлено, тут не равно "") ...
      "#{page_title} | AskIt" # ... то вернем данную строку с названием страницы и сайта ...
    else # ... а иначе просто название сайта
      "AskIt"
    end
    # теперь та строка которая возвращается и будет подставлена туда куда мы интегрируем хэлпер(тут в тайтл)
  end

end


puts
puts '                          Паршал для меню, для передачи через второстепенный yield'

# Для удоббства и динамических возможностей меню можно вынести и главное меню сайта из лэйаут в отдельный паршал
# Создадим паршал меню shared/_menu.html.erb

# Хэлпер для того чтобы рендерить паршал с меню на страницах
module ApplicationHelper

  # currently_at - название любое, но это норм тк это хэлпер который нам говорит на какой странице мы находимся
  def currently_at(current_page = '')
    render partial: 'shared/menu', locals: {current_page: current_page}
    # render partial:  - говорит о том что рендерим именно паршал, а не полноценный вид, так от будет рендерить без лэйаута, а по умолчанию рэндерит с ним
  end

end


puts
puts '                      Кастомный хэлпер подсвечивающий на какой странице меню мы находимся'

# На примере AskIt

# По умолчанию пункты меню в шапке в лэйаут никак не отображают где мы находимя, напишем для этого хэлпер, который стилезует ссылку меню в которой мы в данноймомент находимся

# Хэлпер создадим глобальным в главном хэлпере app/helpers/application_helper.rb тк он будет использоваться на многих разных страницах
module ApplicationHelper

  def nav_tab(title, url, options = {})
    current_page = options.delete :current_page

    css_class = current_page == title ? 'text-secondary' : 'text-white'

    options[:class] = options[:class] ? options[:class] + ' ' + css_class : css_class

    link_to title, url, options
  end

  def currently_at(current_page = '')
    render partial: 'shared/menu', locals: {current_page: current_page}
  end

end

















#
