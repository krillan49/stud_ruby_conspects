puts '                             Устройство интернета. Клиент серверная архитектура'

# https://www.youtube.com/watch?v=PslExWYTD8U
# https://www.youtube.com/watch?v=XaTwnKLQi4A

# Интернет - это огромное число компьютеров, объединенное в одну большую сетку. Эти компьютеры принято делить на серверы, которые предоставляют информацию и клиентские компьютеры, которые информацию запрашивают и получают.

# Для того чтобы понять на каком из серверов есть нужная клиенту информация - у каждого из серверов есть свой IP-адрес. Но чтобы обращаться по буквенному адресу, например ya.ru существуют DNS-сервера, например у провайдера свой DNS-сервер, у хостинг-провайцдера свой DNS-сервер итд. Тоесть когда браузер посылает запрос с буквенным именем сайта, то сначала он идет к DNS-серверу, потом DNS-сервер возвращает браузеру IP-адрес соответсвующего сайта
# IP-адрес состоит из 4х цифр например 9.17.74.98
# Далее наш компьютер уже зная IP-адрес, начинатет через сеть других компьютеров пподсоединяться к нему и после того как они соединились, начинается их взаимодействие по протоколу HTTP

# Сервер выступает единым источником(поставщиком) данных, вычислений, бизнеслогики итд и большое колличество клиентов (потребителей) к этому серверу обращаются.
# Клиентом может быть браузер, мобильное приложение и другой сервер

# Для клиента сервер выступает единым источником, но при этом он может быть распределенным или состоять из многих микросервисов.



puts '                                            HTTP и виды запросов'

# HTTP - гипертекстовый транспортный протокол, который находится на самом верхнем уровне(уровне приложений) сетевой модели OSI/ISO или TCP/IP. Именно при помощи HTTP общаются большинство приложений в интернете

# HTTP - это стандарт(набор правил ?) общения между 2мя устройствами по сети, например между клиентом и сервером

# Первоначальная идея HTTP это обмен гипертекстовыми документами (HTML), но сейчас при помощи него можно передавать практически любые данные(текстовые, фаиловые, html, xml, json)


# методы запроса:
# GET, POST можно отправлять с помощью формы: <form aсtion="GET".../<form ation="POST"...
# PUT, PATCH, DELETE отправляются через POST, но с добавлением скрытой переменной(поля).

# GET запрос(request) от браузера серверу на получение данных / запрос о том что браузер хочет получить какую-то страницу(ресурс). Так же он содержит инфу о кодировках и языках поддерживаемых браузером. На этот запрос от сервера приходит ответ в виде данных запрашиваемой страницы/картинки/ресурса(ее html/css/... код) или об ошибке и некорректности запроса(например 404 страница не найдена)
# GET тоже отправляет данные, но только данные пакета запроса(1 килобайт или типа того)
# Можно дополнительно передать данные(оч небольшие), эти данные будут видны в строке запрса(после знака ?), например:
#     /cart?product_1=4,product_2=7,product_3=4,
# в адресе запроса после ? будут видны параметры, которые разделяются знаком &
#     www.yandex.ru/search/?text=запорожская+аэс&lr=37129&search_source=chromentp_desktop&src=suggest_Pers
# Это результат того что форма указывает на GET-запрс <form aсtion="GET"...

# POST запрос(request) от браузера серверу на отправку данных на сервер(создание ресурса) - используется для отправки браузером данных на сервер(например ввод пароля, отправка сообщения на форум, залив картинки или видео). Так же содержит служебную информацию
# Отправляет данные на конкретный URL

# PUT - метод запроса на обновление ресурса целиком

# PATCH - метод запроса на обновление фрагмента ресурса(частичное обновление ресурса)

# DELETE - метод запроса на удаление ресурса

# GET/POST итд - это условное деление (конвенция), о которой просто договорились. Тоесть ничего не мешает создавать ресурс, например через GET

# Любой запрос в интернете - это по сути серия запросов/ответов клиента и сервера, который содержит заголовки (header), тело (body) и всякую служебную информацию.


# Пример GET-запроса(построчно):
# 1. GET /index.html HTTP/1.1  - начальная строка
# 2. Host: www.example.com     - один из заголовков, которых может быть много, тут доменное имя сайта на который мы отправляем запрос

# Пример ответа сервера(построчно) на запрос выше:
# 1. HTTP/1.1 200 OK                                - начальная строка
# 2. Date: Mon, 23 May 2005 22:38:34 GMT            - заголовки ответа
#    Content-Tipe: text/html; charset=UTF-8         - тип данных, которые получаем
#    Content-Encoding: UTF-8
#    Content-Length: 138
#    Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
#    Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)  - какой сервер отдал данные(ответ)
#    ETag: "3f8of-1b6-3e1cb03b"
#    Accept-Ranges: bytes
#    Connection: close
# 3. <html>                                         - тело ответа(тут это html-документ)
#    <head>
#       <title>Главная страница</title>
#    </head>
#    <body>
#       Какойто контент
#    </body>
#    </html>


# Пример POST-запроса(построчно):
# 1. POST /blog/ HTTP/1.1    -  стартовая строка, состоит из 3х частей(POST - метод, /blog/ - юрл, HTTP/1.1 - версия http)
# 2. Host: htmlacademy.ru
#    Contett-Tipe: application/x-www-form-urlencoded; charset=utf-8    - тип данных которые отправляем
#    Content-Length: 26      -  заголовки(headers), есть обязательные и необязательные, можно добавить и свои кастомные. В заголовках указывается информация о хосте, браузере, типе устройства с которого отправлен запрос, о типе контента, авторизационные заголовки с токенами. Так же с помощью заголовков обеспечивают безопасность взаимодействия различных источников сети.
# 3. {
#     login=user
#     password=qwerty
#   }                        - тело сообщения(body), в нем клиент отправляет серверу какието данные, форматы могут быть разные json/xml итд

# Пример ответа сервера(построчно) на запрос выше:
# 1. HTTP/1.1 200 OK         - строка статуса. Помимо версии http она возвращает статус код(200 OK), который определяет успешно был выполнен запрос или нет
# 2. Contett-Tipe: application/json   - хэдеры ответа
#    Connection: Closed
# 3. {
#     message: 'success login',
#     user: {id:'1', username ... }
#   }                        - тело сообщения(body), в котором сервер возвращает клиенту какието данные(тут json)

# Статус код(например 200 OK) - сообщает о том как был обработан запрос. Существует 5 групп статус кодов:
# 1xx - Informational(информационные). Например 100, 101 итд. Конфигурационные, чтобы понять, что "общение сложилось" ВТФ ???
# 2xx - Success(успешно).              Значит что запрос выполнен успешно, например 200.
# 3xx - Redirection(перенаправление).  Например мы успешно залогинелись и сервер нас перенаправляет на другую страницу(редиректы)
# 4xx - Client Error(ошибка клиента).  Например переданы неправильные данные(400) или страница не найдена(404)
# 5xx - Server Error(ошибка сервера).  Чтото пошло не так на сервере и он не смог правильно обработать запрос
# Статус коды это про семантику, тоесть мы можем послать и другой, но договорились как выше


# Идемпотентность запросов - если многократная отправка запроса приводит к одному и тому же эффекту. Например мы обновляем ресурс при помощи PUT запроса с одними и теми же данными, то сервер каждый раз должен его исполнить одинаково
# Корректно реализованные методы GET, PUT, DELETE - идемпотентны; но не метод POST, тк во многих случаях создаст новую сущность идентичную предыдущей


# Можно так же отправлять запросы вручную(тк они отправляются в текстовом виде) при помощи спец программ(пр telnet) например самый простой запрос(в консоли telnet ya.ru 80) - GET /HTTP/ 1.0  и получим ответ например код страницы

# Так же всю инфу запросов с заголовками и прочим можно посмотреть в браузерах в консоли разработчика: Network и/или Console



puts '                                            Сервер. Состояния'

# SERVER(от слова служить) - сервер только обслуживает и возвращает на наш запрос, а сам никому ничего не отправляет


# Сервер не видит разницы между различными пользователями, разница оценивается на уровне приложения, тк на сервере может быть много приложений и он возвращает на запрос то что возвращает приложение. Соотв state(состояние) поддерживается приложением а не сервером.

# https://stackoverflow.com/questions/13200152/why-is-it-said-that-http-is-a-stateless-protocol

# stateless (без состояния) (сервер не присваивает никакого специального значения и не распознает запрос по соединению) — это протокол передачи данных, который относит каждый запрос к независимой транзакции, которая не связана с предыдущим запросом, то есть общение с сервером состоит из независимых пар запрос-ответ. При каждом следующем запросе клиент и сервер общаются как впервые. Соответсвенно, чтобы идентифицировать себя, клиент должен каждый раз отправлять всю необходимую информацию для этого

# HTTP - это протокол без состояния, т.к. сервер не прицепляет никакого специального значения.
# Например был раньше протокол IRC это протокол с состоянием, тк он всегда поддерживает соединение, а ни как HTTP в котором соединение есть только при запросах и ответах



puts '                                       Проги для просмотра запросов'

# Fiddler - прога для просмотра запросов(бесплатная). Устанавливается как прокси сервер, позволяет видеть все подключения и данные запросов.(https://vimeo.com/102869014 урок18)
# Аналог на маке - charles proxy

# Там можно посмотреть тело пост запросов(данные формы), там есть левые символы которые можно преобразовать в более читабельный вид при помощи - url unescape online (search query)

# Поэтому данные HTTP и небезопасны, тк условный админ вайфай сети офисной или просто сети локальной на работе таким же фидлером может считать инфу с паролей. Соотв по этому и стоит пользоваться HTTPS на котором запросы шифруются, но правда куда мы заходим все равно будет видно


# https://portswigger.net/burp/communitydownload
# Burp Suite Community - я бы вот посоветовал использовать инструмент поновее, оно изначально делалось для security-рисёрчеров, немного посложнее, чем fiddler, но не супер сложно



puts '                                        Схема работы HTTP протокола'

#  https://ru.wikipedia.org/wiki/Сетевая_модель_OSI
# http://lib.ru/WEBMASTER/rfc2068/ - документация для http можно изучить как работает http протокол


# Когда браузер узал от DNS-сервера IP-адрес и отправил по нему HTTP-запрос, то на сервере происходит:
# У операционной сисчтемы сервера есть портык которым нужно подключаться, номер порта добавляется к IP-адресу в запросе, например 9.17.74.98:777, так же можно дописать и после текстового адреса. Веб по протоколу HTTP по умолчанию использует порт 80, потому его прописывать необязательно.
# На компьютере-сервере должен работать процесс, который называется веб-сервер, если он работает и слушает 80й порт, то запрос поступит в это приложение/веб сервер. (это обычно Apache, Nginx и другие)
# Чтобы веб сервер что-то делал, то внутри него или рядом должно работать приложение, например Ruby on Rails приложение, которое содержит в себе какую-то логику, оно получает запрос, обрабатывает, обращается в БД, на другие сервера, если нужно и возвращает обратно через веб сервер по 80му порту клиенту/браузеру данные в виде ответа по HTTP протоколу и уже его обрабатывает браузер и показывает веб страницу, картинку итд.


#                                Что происходит, когда вы вводите URL-адрес в браузере :

#      1. Разрешить домен(доменное имя например stackoverflow.com или ya.ru или localhost), если это не IP (запрос DNS) Браузер превращает доменное имя в IP-адрес(пр 	85.249.20.109  (IPv4)) и к нему подключается через порт

#      2. Откроет порт 80 по умолчанию, если не задан SSL и не переопределено двоеточием (http://host:port/).
# 127.0.0.1:80 это тоже самое что и 127.0.0.1 тоже самое что и localhost или localhost:80
# SSL - это подключение через защищенный канал например https://ya.ru

# Порты по умолчанию:
# 80 - http  например http://ya.ru
# 443 - https  например https://ya.ru
# Порт - это абстракция операционной системы или протокола(на самом деле никаких портов нет)
# 85.249.20.109:80  - можно добавить порт в конец IP-адреса

#      3. Отправляется запрос  для http://host/uri/here?other=stuff&too
# Пример запроса: использует и должен заканчиваться двумя символами возврата каретки и перевода строки (CrLf)
#   GET /uri/here?other=stuff&too HTTP/1.1
#   Host: host
#   Other: Headers, too.  Such as cookies
#   Header: Value

#      4. Получает ответ
# Пример ответа:
#   HTTP/1.1 200 OK
#   Other: Headers, too.  Such as cookies
#   Header: Value
#   <html>Actual HTTP payload is here, could be HTML data, downloaded file data, etc.

#     5. Соединение закрывается



# 1. Сначала компьютер ищет целевой хост. Если он существует в локальном кэше DNS, он использует эту информацию. В противном случае DNS-запрос выполняется до тех пор, пока не будет найден IP-адрес.
# 2. Затем ваш браузер открывает TCP-соединение с целевым хостом и отправляет запрос в соответствии с HTTP 1.1 (или может использовать HTTP 1.0, но обычные браузеры больше этого не делают).
# 3. Сервер ищет нужный ресурс (если он существует) и отвечает по протоколу HTTP, отправляет данные клиенту (=вашему браузеру)
# 4. Затем браузер использует парсер HTML для воссоздания структуры документа, которая позже будет представлена ​​вам на экране. Если он находит ссылки на внешние ресурсы, такие как изображения, файлы css, файлы javascript, они доставляются так же, как и сам HTML-документ.



# Упрощенный набросок, предполагающий простейший из возможных HTTP-запросов (без HTTPS, без HTTP2, без дополнений), простейший из возможных DNS, без прокси-серверов, IPv4 с одним стеком, только один HTTP-запрос, простой HTTP-сервер на другой конец, и никаких проблем на любом этапе. Почти нереалистичный сценарий, в реальном использовании почти всегда сложнее:

# 1.  браузер проверяет кеш(это хранилище браузера на жеском диске, чтоб быстрее загружать страницы); если запрошенный объект находится в кеше и является свежим, переходим к  пункту 9
# 2.  браузер запрашивает у операционной системы(тк именно она превращает запрос в IP-адрес для браузера) IP-адрес сервера[(пункт 1 в самом вехнем списке)]
# 3.  ОС выполняет поиск DNS и отвечает на IP-адрес в браузере.
# 4.  браузер открывает TCP-соединение с сервером (этот шаг намного сложнее с HTTPS) [(пункт 2 в первом списке)]
# 5.  браузер отправляет HTTP-запрос через TCP-соединение[(пункт 3 в первом списке)]
# 6.  браузер получает HTTP-ответ и может закрыть TCP-соединение или повторно использовать его для другого запроса. [(пункт 4-5 в первом списке)]
# 7.  браузер проверяет, является ли ответ перенаправлением или условным ответом (коды состояния результата 3xx), запросом авторизации (401), ошибкой (4xx и 5xx) и т. д.; они обрабатываются иначе, чем обычные ответы (2xx)
# Может быть такой запрос который перенаправляет браузер, тогда браузер не завершает соединение а переходит туда куда перенаправили(можно сделать многократное перенаправление или зациклить, но в браузерах есть от этого защита)
# 8.  если ответ можно содержать в кеше, чтобы не перезагружать снова(некоторые документы можно содержать в кеше например картинки), ответ сохраняется в кеше. Но есть картинки с опцией перезагрузки(об этом сообщается в ответе сервера) например капча
# 9.  браузер декодирует ответ (например, если он заархивирован). Тк большинство серверов сейчас присылают ответ не в текстовом а в сжатом виде
# 10. браузер определяет, что делать с ответом (например, это HTML-страница, это изображение, это звуковой клип)
# 11. браузер отображает ответ или предлагает диалог загрузки для нераспознанных типов

# Кроме того, параллельно с этим происходит много других вещей (обработка введенного адреса, спекулятивная предварительная выборка, добавление страницы в историю браузера, отображение прогресса для пользователя, уведомление плагинов и расширений, рендеринг страницы во время ее загрузки, конвейеризация, отслеживание соединения для keep-alive, управление файлами cookie, проверка на наличие вредоносного контента и т. д.) — и вся операция становится на порядок сложнее с HTTPS (сертификаты, шифры и закрепление).



puts '                                   О разделении бэкенд и фронтэнд'

# На сервере происходит обработка запроса по определенному URL по протоколу HTTP. Сервер возвращает браузеру фаилы html, js, css  и другие, которые браузер использует, чтобы отрисовать страницу.

# Но эта страница так же может сама при помощи браузера обращаться к серверу, чтобы постоянно не перезагружать всю страницу, например для того чтобы подгрузить новые посты - это помимо визуала тоже фронтэнд. Тоесть логика происходящая на веб странице клиента.



puts '                                           Структура URL'

# https://ru.wikipedia.org/wiki/URL - статья википедии про URL, потом прочитать

# https://ru.wikipedia.org/wiki/URL#%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_URL
# https: - зашифрованный протокол http
# // - хз зачем (создатель http считает их лишними)
# ru.wikipedia.org - название хоста, которое DNS-сервером (чтобы выдать браузеру IP-адрес) разбиррается с конца:
#     org - доменная зона
#     wikipedia - домен
#     ru - поддомен, разбирается уже на сервере приложения(тут Википедии)
# /wiki/URL - адрес (тут URL часть адреса так как статья про URL)
# #%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_URL - якорь, после # закодированны точки и русские символы


# URL с параметрами:
# https://www.youtu.be/watch?v=PslExWYTD8U&t=897
# www - тоже поддомен
# ?v=PslExWYTD8U&t=897  - параметры идкт после вопроса и разделяются &, тут это айди видео(v=PslExWYTD8U) и время на котором его открыть(t=897)
















#
