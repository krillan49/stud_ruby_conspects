puts '                                              Docker'

# https://docs.docker.com/desktop/windows/                - Руководство пользователя Docker Desktop для Windows

# https://bv-dev.ru/ustanovka-dockerdoke-na-windows-10-reshenie-problem/     -  Решение проблемы с виндоус 10

# Если Docker работает на WSL, можно вернуть оперативную память, завершив все запущенные дистрибутивы с помощью команды:
# > wsl --shutdown


# На ОС без Линукс ядра запускает миллиард инстансов qemu, чтобы сэмулировать подходящее окружение
# На линуксе ничего не будет жрать
# На ОС, где не доступен докер, достаточно просто qemu иметь при себе, где докер, например в альпине можно будет запустить


# Image(образы) - готовые решения содержащие готовый функционал. Образы качаются из определенного регистра. Образ нельзя изменять. На основе образа мы можем создать готовый проект/контейнер. Образ это некий пакет на основе которого работает сам контейнер.

# Контейнер - наш проект содержащий функционал из образов и на основе этого функционала наше приложение. Этот проект можно запускать и пересылать. Например можно скачать образы разных языков и написать код на каждом и наш контейнер будет работать, тк у нас в контейнере будет функционал для каждого из этих языков



puts '                                               Docker Hub'

# https://hub.docker.com/

# Docker не хранит все образы на вашем ПК. Вместо этого он использует различные регистры. Регистры можно представить как папки, что хранят данные. Такие регистры хранят все образы на удаленном хосте. Docker может обращаться к регистрам и по необходимости вытягивать из них нужные образы.

# Docker Hub - хранилище образов, один из регистров. Он является официальным и содержит большое количество образов как по языкам программирования, так и по всевозможным технологиям.

# > docker login                              - команда авторизации в терминале(далее следовать инструкциям)
# > docker logout                             - команда для выхода


# Explore - вкладка с образами которые можно использовать. При выборе образа будет ссылка с командой скачивания для терминала. Команды на примере Джаваскрипт:
# > docker pull openjdk            - по умолчанию будет поставлена последняя версия
# > docker pull openjdk:latest     - последняя версия в ручную
# > docker pull openjdk:11         - конкретная версия(В докумментации в хабе указаны другие версии)

# > docker run openjdk             - запустить контейнер. Автоматически создает контейнер если его нет(Название контейнеру присваивается случайное)


# Деплой в Docker Hub - сборка образа в хранилище:
# > docker build -t krillan/myphp ./php                     - собераем образ для хаба, указав логин/название образа и путь к папке от рабочей директории
# > docker push krillan/myphp:latest                        - позволяет загрузить образ(на хаб?). :latest - по желанию можно указать версию. Теперь в личном кабинете в докерхабе будет новый контейнер. Там же можно добавить описание например какие порты используется что делает прога итд.
# > docker image rm krillan/myphp                           - удалить. Теперь наш образ остался только в хабе, теперь мы(или не мы) можем его себе стянуть если нужно
# > docker image pull krillan/myphp                         - стягиваем образ(название есть в нашем репозитории)
# > docker run -p 3001:80 --name my app krillan/myphp       - теперь можно зайти на локалхост и получить работающее приложение



puts '                                              Терминал'

# Что значат строки из набота команд в терминале(на примере):
# > docker run -d -p 80:80 docker/getting-started

# 1. docker - команда обращения к докеру(будем через докер что-то выполнять)

# 2. run - команда говорит что мы запускаем некий контейнер/проект. Если данного контейнера нет команда так же его докачивает, а потом запускает
#    pull - (может стоять на месте run)команда говорящая о том что нам надо скачать некий контейнер.

# 3. Опции относятся к той команде после которой стоят, например тут опция -d относится к команде run(для другой команды они могут значить другое. -D — debug, режим отладки, для команды docker)
#    -d (--detached) - опция команды run - отсоединенный режим: мы возвращаем управление в наш терминал, а не оставляем его внутри контейнера.(работа в фоновом режиме)
#    -p (--publish list) - опция позволяющая соединить порты
#    -m (--memory bytes) - Memory limit опция позволяет задать лимит выделяемой памяти для данного проекта

# 4. 80:80 - связываем порты. 1й 80 это порт связанный с нашим компом, 2й 80 это порт самого проекта. Те мы связываем по порту 80 наш комп с портом 80 контейнера/проекта

# 5. docker/getting-started - название контейнера, который мы хотим скачать и/или запустить/установить

# Далее пошла проверка на наличие(будет сообщение если проет отсудствуует), затем его скачивание и запуск(тк была прописана команда run). Теперь в нашем приложении Docker Desktop появился контейнер



puts '                                           Терминал - команды'

# > docker                                - выдаст список всех возможных команд

# > docker run --help                     - aфлаг --help выдаст полную информацию о конкретной команде

# > docker info                           - посмотреть всю информацию о нашем докере(какие контейнеры используются, какие скачаны, какие остановлены, какие есть образы)

# > doсker images                         - более детальная информация обо всех образах(та же таблица что и в приложении)

# > docker ps                             - показать полный список всех наших(доступных) контейнеров
# > docker ps -a                          - показать полный список всех наших(доступных) контейнеров

# stop - команда чтобы остановить работу одного или нескольких контейнеров. (уже не откроются в браузере)
# > docker stop 9cc6a7919e96              - по айди контейнера(который можно найти при помощи docker ps либо в приложении Docker Desktop Containers(статус изменится с running на exited)

# start - команда чтобы запустить контейнер
# > docker start 9cc6a7919e96             - по айди
# > docker start -i xxx                   - по названию с опцией для работы в терминале

# pause - команда чтобы поставить работу контейнера на паузу
# > docker pause 9cc6a7919e96             - по айди

# unpause - команда чтобы возобновить работу контейнера убрав с паузы
# > docker unpause 9cc6a7919e96           - по айди

# restart - команда чтобы перезапустить работу контейнера если вдруг возникла проблема
# > docker restart 9cc6a7919e96           - по айди

# > docker login                          - позволяет авторизоваться в терминале при помощи акаунта в докере(если зайти на оф сайт и создать акаунт) Это позволит отправлять контейнеры в докерхаб
# > docker logout                         - разлогин, выход из учетной записи

# > docker run -it openjdk                - запустить образ(тут openjdk) в интерактивном режиме. В этом режиме контейнер перейдет в режим running и в терминале мы будем уже внутри контейнера и в данном случае сможем писать код на языке Джава. При каждом новом запуске образа из консоли создается и запускается новый контейнер(хотя в приложении ничего и не меняется)
# -i или --interactive. Благодаря этому флагу поток STDIN поддерживается в открытом состоянии даже если контейнер к STDIN не подключён.
# -t или --tty. Благодаря этому флагу выделяется псевдотерминал, который соединяет используемый терминал с потоками STDIN и STDOUT контейнера.
# Для того чтобы получить возможность взаимодействия с контейнером через терминал нужно совместно использовать флаги -i и -t.

# > docker run -it --name MyJava openjdk
# --name - флаг при помощи которого можно задать имя контейнеру(тут MyJava)

# Ctrl + d - выход из интерактивного режима(из работы контейнера) в консоли. Контейнер снова переходит в режим Exited

# Когда контейнер создан уже не нужно запускать образ можно сразу запускать наш контейнер/проект:
# > docker start MyJava                    - запускаем при помощи команды start контейнер с именем MyJava(если контейнер пустой и в нем только образ просто вернет имя контейнера и перейдет в режим Running)
# Далее мы можем остановить работу контейнера(docker stop MyJava) поставить на паузу снять с паузы итд аналогичным образом

# > docker kill MyJava                     - зкстренный выход(выход с ошибкой - exited будет равно уже не 0)



puts '                                          Docker desctop'

# Docker desctop  - специальная программа/приложение докера

# скопировать - 2 прямоугольничка в конце строки

# Новые приложения после скачивания появляются во вкладке Containers.
# Там же в таблице можно посмотреть запущено ли оно(running), какие порты использует, когда начало работу, а так же опции для работы с ним(удаление пауза запуск в терминале итд)

# Помимо самого контейнера/приложения так же был добавлен образ(вкладка Images)
# in use - запущен/используется тоесть создан контейнер по этому образу.
# Tag - версия образа
# Там же есть опции для образа - запустить(если еще не запущен) скачать, пушнуть в хаб(мето где хранятся все образы) или удалить



puts '                                     Запуск контейнеров/приложений'

# В браузере нужно открыть локал хост и указать порт 80. localhost/80(прим указываем номер порта нашего контейнера)
# Либо открыть контейнер из приложения Docker Desktop Containers Open with browser

# В итоге мы получаем вебсайт с некой функциональностью находящийся на нашем компьютере и работающий по некоторому порту

# Так же можно скачать образ языка и внутри контейнера будет рабочий язык без наобходимости установки его на нашем компьютере. Так же можно будет передать этот контейнер на другой компьютер



puts '                                             Dockerfile'

# Выполнять команды в терминале не всегда удобно, вместо этого можно использовать Dockerfile - он позволяет описать характеристики подключаемого образа.

# Dockerfile - название фаила для проекта без расширений. Позволяет помещать описание образов в отдельный файл, который уже потом можно исполнить.

# Уже готовый код для этого фаила есть на странице соответсвующего образа в хабе

# например содержание Dockerfile для openjdk:
# FROM openjdk:11
# COPY . /usr/src/myapp
# WORKDIR /usr/src/myapp
# RUN javac Main.java
# CMD ["java", "Main"]

# Для PHP
# FROM php:7.2-apache
# COPY . /var/www/html
# WORKDIR /var/www/html
# EXPOSE 80

# Dockerfile состоит из нескольких основных команд:
# 1. FROM – указывает какой образ будет использован/скачен(например openjdk). Тут же можно указать версию образа(например :11), по умолчанию последняя версия
# FROM php:7.2-apache                  - можно после версии указать еще и сервер(например -apache)
# 2. COPY – указывает какие файлы(местоположение) из вашего проекта будут скопированы на хост машину. Другими словами, указывает какие файлы будут выполнены за счет возможностей образа. Так мы еще связываем папку и фаилы с образом
# COPY .	/usr/src/myapp               - тут "." путь где(тут в текущей диретории) будут находиться все фаилы, а "/usr/src/myapp" указывает в какую папку в самом образе мы будем это помещать
# COPY . /var/www/html                 - либо можно указать адрес сервера
# 3. WORKDIR – указывает рабочую директорию
# WORKDIR /usr/src/myapp
# WORKDIR /var/www/html
# 4. EXPOSE – указывает порт для проекта. Будет работать в том случае, если в образе есть локальный сервер(локалхост)
# EXPOSE 80
# EXPOSE 8001
# 5. RUN – позволяет описать команду, что выполниться один раз при сборке всего контейнера/создании образа
# RUN	javac Main.java                  - запускаем(javac) и компилируем фаил Main.java
# 6. CMD – описывает команду, что выполняется каждый раз при запуске контейнера
# CMD ["java", "Main"]                 - указываем что будем запускать наш фаил. Наш фаил(например Main.java) с необходимым кодом, неоходимо предварительно создать.

# Далее для построения фаила прописываем в терминале:
# build - команда позволяет построить наш фаил, далее прописываем путь к докерфаилу(например . )
# > docker build ./php
# > docker build -t my-php-app ./php         - при помощи флага "-t" задаем название образа(my-php-app). Нельзя чтоб название образа содержало спец символы и символы в верхнем регистре
# Теперь если выполнить 'docker images' мы увидим новый созданный образ в списке, у которого есть айди и размер который совпадает с материнским образом(например openjdk) тк информаци кроме небольшего фаила мы не добавили

# Удаление образа:
# > docker image rm 5ecde7c66384               - по айди образа

# Запуск образа:
# > docker run -p 0a51b7d194e0                 - запуск по айди(можно по названию если его задал при создании)
# > docker run -p 8001:80 -d my-php-app        - запуск по имени с указанием портов
# -p - опция указывающая соединение портов, (8001:80) можно дополнительно указать какие порты соединяются если они разные(будет работать только если у материнского образа есть сервер, в openjdk напр нет)
# Порт который работает на нашем компе(1й пр 3001) можно указывать каким угодно. А связываться мы будем с портом который прописали в строке EXPOSE
# В итоге наша проограмма исполняется (пр #=> "Hello World"). Соотв тут мы запустили язык Джава на компьютере на котором он не установлен. Теперь можно перейти на localhost:8001 в браузере и обнаружить там результат заботы программы (Hello)



puts '                                        Docker Compose'

# Docker Compose - представляет из себя отдельный файл, в котором можно указать какие образы будут подключены, какие у них будут характеристики, возможности итд.

# Преимуществом Docker Compose является возможность подключения сразу многих образов. Например, можно подключить языки Джава, Python, C++, PHP и к ним дополнительно настроить сервера, среды разработки и все это в одном файле.

# При построении файла Compose нужно указать сервисы(выполняют роль образов) и их характеристики.

# docker-compose.yml - название фаила докер компоста всегда должно быть такое. В этом фаиле можно написать описания различных образов и при запуске проэкта они будут либо скачаны либо сразу запущены.

# Пример: В хабе ищем phpmyadmin и внизу есть описание для фаила docker-compose.yml содержание можно просто скопировать в свой фаил докеркомпоста. Так же там ниже есть список всех переменных которые можно дописать дополнительно(например изменение логина хоста итд)

# docker/docker-compose.yml   - тут пример фаила docker-compose.yml с кодом. Описано 2 сервиса(образа) 1й управление базами данных mariadb:10.3 и 2й графический интерфейс phpmyadmin

# > docker-compose build           - сборка образа/проекта из фаила докеркомпост. Не производит запуск только сборка
# > docker-compose up              - запуск собранного образа, а так же предварительное скачивание и установка тех образов которых нет в наличии
# Теперь мы находимся в режиме работы приложения в консоли
# localhost:8080 - Далее заходим в указаный в фаиле порт(тут 8080) через браузер. Получаем панель входа(имя пользователя по умолчанию root, пароль кторый мы указали в докеркомпост фаиле) и мы в приложении
# Ctrl + c   -выход из режима работы приложения в консоли
# > docker-compose down            - остановить собранный образ


# Изменение сервиса:
# Можно в этом образе поменять mariadb:10.3 на mysql вместо копирования из хаба кода для mysql тк там вместо phpmyadmin указан другой графич интерфейс
# image: mysql - просто меняем на mysql значение характеристики image в docker-compose.yml
# можно поменять и другие данные например пароль на MYSQL_ROOT_PASSWORD: 12345
# Но стоит обратить внимание на наличие в коде хаба команд comand(аналог CMD) и добавить ее(тк она исполняется при каждом запуске):
# command: --default-authentication-plugin=mysql_native_password   (тут это плагин для авторизации)

# Снова выполняем команды
# > docker-compose build
# > docker-compose up
# опять заходим на наш локалхост и получаем новый вариант сборки


# Добавление сервиса:
# Можно написать код для него тк для двух сервисов выше а можно использовать отдельный докерфаил например на докерфаил с php
# docker/docker-compose.yml   - тут пример



puts '                                       Docker Volumes/Тома докер'

# Docker Volumes/Докер Тома – позволяют сохранять значения внутри контейнеров даже после их перезапуска. Сохраняет настройки на сервере(хост машине). Тк без них когда мы запускаем контейнер и делаем в нем какие-то настройки, а потом перезапускаем - то все эти настройки по умолчанию не сохраняются.

# За счет томов можно хранить как значения из базы данных, так и всевозможные файлы, документы и прочее.
# Нужно указывать в docker compose файле какие данные и где будут сохраняться. Обычно вы указываете папку в вашем проекте и папку на хост-машине.


# ПРИМЕР(Создание контейнера Питон + Джанга с сохранением настроек в томах докер):

# 1. Dockerfile:
# FROM python:3
# WORKDIR /usr/src/app                    - рабочая директория на хостмашине
# COPY requirements.txt ./                - requirements.txt стандартный фаил содержащий библиотеки(зависимости) для проэктов Джанга. ./ помещаем этот фаил в раб директорию WORKDIR(можно писать другой путь)
# RUN pip install -r requirements.txt     - берем библиотеки из фаила requirements.txt и устанавливаем при создании образа

# 2 docker-compose.yml  - код описан в docker/docker-compose.yml

# 3. requirements.txt  - записываем в этот фаил:
# Django>=3.0,<4.0                                        - библиотека Джанга выше версии 3.0 и ниже версии 4.0
# psycopg2-binary>=2.8                                    - дополнительная библиотека для работы с Джанга и Питоном
# С новой строки можно дописать другие библиотеки если они нужны

# 4. Далее запускаем все это:
# > docker-compose run django django-admin startproject itproger .
# docker-compose run - не только запускает все сервисы(как docker-compose up) и строит контейнер(docker-compose build) но и позволяет дописывать дополнительные команды
# django - обращаемся к уже собранному джанго а через него к команде джанго django-admin а через нее к другой команде
# startproject которая создает новый проект так же указываем название проекта(тут itproger).
# Далее путь(тут . значит устанавливать проект будем в той же папке)
# в итоге создаются фаилы manage.py и папка проекта(тут itproger) с фаилами для работы с Джанга
# > docker-compose up                   - все равно необходимо чтобы запустить контейнеры на постоянную обработку

# 5. теперь заходим на указанный нами localhost:8000 и получаем стандартную стартовую страницу Джанга
# если не работает смотрим в файл settigs.py строку ALLOWED_HOSTS = [] (тут должно быть [] или ['*'] это значит что разрешенные хосты стоят в значении "все")
# localhost:8000/admin - панель администратора в этом проекте(тк в Джанга она предустановлена), но авторизоваться в ней можно только создав суперпользователя
# > docker-compose run django  pyton manage.py migrate          - migrate - команда позволяет выполнить миграцию фаилов для создания суперпользователя
# > docker-compose run django  pyton manage.py createsuperuser  - createsuperuser - команда запускает создание суперпользователя
# Далее во время создания запрашивает создание логина, имэйла(не обязательно), пароля и его подтверждения(ввод не виден)
# теперь вводя логин и пароль мы можем авторизоваться в панели администратора и войти в нее.
# НО если мы выйдем и остановим контейнер(docker-compose down) то все эти настройки(суперпользователь, миграции) исчезнут, чтобы этого не случилось нужно прописать volumes и для pgdb(сделано)














#
