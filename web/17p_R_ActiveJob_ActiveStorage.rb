puts '                                            ActiveJob'

# ActiveJob - (фича Рэилс) это функционал, который позволяет отправлять наши задачи предназначенные для выполнения в фоновом режиме различным адапретам (например kafka, sidekiq итд), которые и выполняют эти задачи в фоновом режиме, те управляют очередями, задачами итд

# Некоторые задачи выполняются долго(даже минут 30) и если мы выполняем их синхронно, то у пользователя после нажатия кнопки на выполнение задачи, в браузере произойдет таймаут и браузер прервет выполнение и выдаст ошибку что страница грузится слишком долго


puts
puts '                                             Sidekiq'

# Процесс отправки писем можно отправлять в бэкграунде, в фоновом режиме, например при помощи метода deliver_later, как мы делали в контроллере PasswordResetsController (malers), но по умолчанию это не работает, тк обработка в бэуграунде пока еще не настроена. Для того чтобы ее настроить нам нужно специальное решение, которое будет правильным образом выполнять обработку, ставить задачи в очередь, при необходимости выполнять задачи снова, если возникла ошибка итд

# Есть разные движки/адаптеры которые могут выполнять задачи в бэкграунде, например из самых известных:
# kafka  - более сложное решение
# sidekiq - более простое(но тоже большое) решение (есть как бесплатная так и энтерпрайз версии)


# https://github.com/sidekiq/sidekiq
# https://github.com/sidekiq/sidekiq/wiki/Getting-Started

# sidekiq - позволяет создавать задачи в фоновом режиме как для Рэилс(через ActiveJob - есть раздел в описании сайдкик), так и без него

# 1. Установка:

# Gemfile:
gem 'sidekiq', '~> 7'
# > bundle i

# Так же у sidekiq есть требование, чтобы у нас в системе был установлен redis(NO-SQL база данных, которую sidekiq использует для храниения информации о задачах).
# На Никс-системах просто устанавливаем с redis офф сайта  -  https://redis.io/download/
# Но redis новых версий на виндоус больше не поддерживается(?? В описании есть замена в виде Dragonfly мб она поддерживается ??).

# Для винды есть альтернатива - Memurai https://www.memurai.com/ - это решение полностью повторяет API Редиса:
# https://www.memurai.com/get-memurai - бесплатно скачать можно тут(только Developer Edition, тоесть в продакшн не получится и нужно рестартить каждые 10 дней - имеется ввиду сервер рестарт ??), полноценная версия платная
# https://docs.memurai.com/en/installation.html  -  как установить

# После того как мы установили redis/memurai, сайдкик по умолчанию к нему подключится
# порт локалхоста по которому будет работать Редис по умолчанию localhost:6379
# https://github.com/sidekiq/sidekiq/wiki/Using-Redis   - описание как подключтиться по другому порту и еще всякое


# 2. Настройка:

# Создадим конфигурацию для сайдкика config/sidekiq.yml (код там)

# Далее нужно явно сказать Рэилс, какой адаптер будет использоваться ActiveJob
# https://github.com/sidekiq/sidekiq/wiki/Active-Job - копируем отсюда строку и помещаем в config/application.rb:
class Application < Rails::Application
  # ...
  config.active_job.queue_adapter = :sidekiq
end


# 3. Запуск:

# Запускать sidekiq будет в отдельном окне командной строки в директории проекта, тк он будет какбы крутиться и вызавать свой отладочный вывод
# > bundle exec sidekiq -q default
# Далее запускается как бы сервер sidekiq и идет отладочный вывод


puts
puts '                                    Sidekiq для отправки письма сброса пароля'

# Проверим будет ли приходить письмо с настройками сброса пароля (mailers)  в фоновом режиме

PasswordResetMailer.with(user: @user).reset_email.deliver_later
# Когда тут(password_resets_controller.rb) используем метод deliver_later и если есть адаптер для выполнения задач в фоновом режиме, тогда эта задача будет передана адаптеру и задача будет выполнена в бэкграунде

# Когда сервер рэилс отправляет письмо, отладочный вывод Сайдкика показывает, что использует ActionMailer, задачу с ее айди, адаптер, мэйлер, метод мэйлера и метод задачи и параметры:
# INFO: Performing ActionMailer::MailDeliveryJob (Job ID: 3d08abae-0c6f-4635-8239-f979ca856b2e) from Sidekiq(default) enqueued at 2024-02-04T12:57:51Z with arguments: "PasswordResetMailer", "reset_email", "deliver_now", {:params=>{:user=>#<GlobalID:0x000002a28cffa7e0 @uri=#<URI::GID gid://ask-it/User/7>>}, :args=>[]}

# А в консоли Рэилс будет:
# [ActiveJob] Enqueued ActionMailer::MailDeliveryJob (Job ID: 3d08abae-0c6f-4635-8239-f979ca856b2e) to Sidekiq(default) with arguments: "PasswordResetMailer", "reset_email", "deliver_now", {:params=>{:user=>#<GlobalID:0x000001dd77e2d4b0 @uri=#<URI::GID gid://ask-it/User/7>>}, :args=>[]}

# Это говорит о том что сервер поставил в очередь задачу на выполнение и эта задача будет выполняться в фоновом режиме, тоесть пользователь не ждет пока зада будет выполнена, а может дпльше чето делать в приложении и ничего не подвиснет, тк задача будет выполнена в бэкграунде.


puts
puts '                                   Интерфейс для отслеживания задач'

# Настроем маршрут в routes.rb для интерфейса отслеживания задач в нашем приложении, так же ограничим этот функционал только для администратора
# (Весь код далее из routes.rb)

require 'sidekiq/web' # подключаем сайдкик-веб

# Для того чтобы ограничить интерфейс только для администратора, добавим констрэйт(класс ограничения)
class AdminConstraint
  def matches?(request) # обязательно должен быть этот метод
    # request - это тот запрос, который был отправлен на маршрут (тут '/sidekiq'), он перенаправляется сюда на проверку, чтобы мы проверили от кого пришел запрос и либо пускаем этого пользователя по маршруту или нет.
    user_id = request.session[:user_id] || request.cookie_jar.encrypted[:user_id] # возьмем user_id либо из сессии, либо из зашифрованного куки если пользователь поставил галочку запомнить его
    # request.session[:user_id] - обращаемся к запросу через session[:user_id]
    # request.cookie_jar.encrypted[:user_id] - обращаемся к зашифрованному куки, но просто обратиться к нему не получится, поэтому нужно дополнительно применить метод cookie_jar
    # cookie_jar - берется из модуля (?)АктивДиспатч, этот модуль доступен в маршрутах потому дешифровка куки будет автоматической
    User.find_by(id: user_id)&.admin_role? # ищем пользователя по айди и проверяем на админа
  end
end

Rails.application.routes.draw do
  mount Sidekiq::Web => '/sidekiq', constraints: AdminConstraint.new
  # mount - метод монтирует маршрут на основе параметров
  # Sidekiq::Web => '/sidekiq'  - выбираем адрес по которому в приложении будет доступен Sidekiq::Web, тоесть мы подключаем интерфейс сайдкика по данному адресу на нашем сайте.
  # constraints: AdminConstraint.new - опция для обращения к проверке констрэйтом на админа, чтобы разрешить только ему маршрут

  # ...
  scope '(:locale)', locale: /#{I18n.available_locales.join("|")}/ do
    # ...
    namespace :admin, constraints: AdminConstraint.new do
      # constraints: AdminConstraint.new - можно использовать тот же ограничитель, чтоб дополнительно ограничить пространсво имен маршрутов админа
      resources :users, only: %i[index create edit update destroy]
    end
    # ...
  end
end

# Далее открываем приложение по адресу 'http://localhost:3000/sidekiq' и видем подробную статистику по задачам и действиями с ними со всякими менюшками и графиками


puts
puts '                               ActiveStorage. jobs. ZIP в background'

# В админском контроллере admin/users_controller.rb мы загружали и выгружали пользователей в формате EXEL, а эти операции могут занимать много времени, поэтому лучше перенести их выполнение в бэкграунд

# 1. Откроем дирректорию app/jobs в которой уже еть главный джоб/задача application_job.rb (код в нем) от которого и будут наследовать остальные наши задачи
# Создадим новый фаил, который назовем например app/jobs/user_bulk_import_job.rb в котором будем делать импорт EXEL фаилов
class UserBulkImportJob < ApplicationJob # наследует от главного джоба
  queue_as :default # обязательно указываем в какую очередь будет помещена задача(у нас только одна очередь :default но может быть много)

  def perform() # внутри джоба обязательно должен быть метод с таким названием, который и будет описывать задачу которую мы будем выполнять в бэкграунде
  end
end

# 2. В контроллере admin/users_controller.rb вызовем эту задачу в методе create
module Admin
  class UsersController < BaseController
    # ...
    def create
      if params[:archive].present?
        # UserBulkService.call params[:archive] - раньше вызывали этот сервисный объект, теперь будем вызывать задачу:
        UserBulkImportJob.perform_later # но тут начинаются сложности, тк мы не можем просто сюда передать params[:archive] или даже params[:archive].path потому что это временный фаил и когда задача начнет выполняться его может уже не быть
        # perform_later - поставит задачу в очередь и сделает ее в фоне (в отличие от простого perform)
        flash[:success] = t '.success'
      end
      redirect_to admin_users_path
    end
    # ...
  end
end


















#
