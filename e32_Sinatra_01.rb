puts '                                         Sinatra(Ruby on Sinatra)'

# gem install sinatra   -   установка гема(если очень долго устанавливается отменям контрл+с и заново оно доустановит)
# gem install puma   -  также рекомендуется запустить, его Sinatra заберет при наличии.
# https://github.com/sinatra/sinatra   -   документация sinatra

# start ruby app.rb  -  запуск в отдельном окне(чтото вроде командной строки). Либо просто запустить в отдельном окне терминала.

# (!!! Спросить\погуглить почему так и не считывает с диска)фаил стилей в папке public, нужно сохранять во время работы синатры для данного конкретного фаила .rb, либо после перезапуска синатры в другом каталоге с другими фаилами .rb а иначе она не воспримет изменения(похоже оставляет фамл гдето у себя в памяти)

# при каждом запросе синатра считывает фаил с диска, соотв не нужно чтото каждый раз перезагружать во время изменений, но это не касается главного фаила программы .rb если мы вносим изменения в нем то уже нужен перезапуск. Измененный код не вступит в силу, пока вы не перезапустите сервер. Перезагружайте сервер каждый раз, когда вы меняете или используете перезагрузку кода.


require 'sinatra'  # подключение модуля sinatra нужно как и для любых других библиотек и гемов

# get - метод в синатре(или способ работы сервера или гет-обработчик юрл адреса), который обслуживает запрос браузера типа "get"(браузер хочет получить данные с сервера), он срабатывает когда мы загружаем страницу по адресу '/', в данном случае с локального сервера запущенного синатрой. Он сообщает: если пришел GET запрос на корневую директорию '/', то выполни функцию, которую я написал между do и end.
get '/' do # get - метод, он принимает два аргумента: 1й - это адрес('/'), 2й - это лямбда(do...end)(do..end === ->{ })
  # '/' - тут слэш это общепринятое значение корня сайта те корневой сайт(нужен для локального сервера)
  return 'Hi'  # Метод возвращает просто текст на корневую страницу в пустой html(erb?) фаиле. return не обязателен как и в любом другом методе
end

# при запуске программы(ruby failname.rb) возвращается отладочный вывод и программа не завершается:
  #[2022-11-23 14:10:38] INFO  WEBrick 1.7.0
  #[2022-11-23 14:10:38] INFO  ruby 3.1.0 (2021-12-25) [x64-mingw-ucrt]
  #== Sinatra (v3.0.2) has taken the stage on 4567 for development with backup from WEBrick
  #[2022-11-23 14:10:38] INFO  WEBrick::HTTPServer#start: pid=1064 port=4567
# Синатра запустил свой новый сервер на нашем компьютере и в отладочном выводе написан порт на нашем компьютере(например 4567)
# Чтобы обратиться к этому запущенному серверу нужно ввести в браузере localhost:4567(http://localhost:4567/) после этого браузер обращается к написанному нами серверу и исполняет код. После чего в отладочном выводе появляется доп информация об этом:
  #::1 - - [23/Nov/2022:14:12:28 +0300] "GET / HTTP/1.1" 200 2 0.0307
  #::1 - - [23/Nov/2022:14:12:28 RTZ 2 (чшьр)] "GET / HTTP/1.1" 200 2
  #- -> /
# Выход при помощи Ctrl+C:
  #== Sinatra has ended his set (crowd applauds)
  #[2022-11-23 14:13:39] INFO  going to shutdown ...
  #[2022-11-23 14:13:39] INFO  WEBrick::HTTPServer#start done.

# localhost это обозначение нашего компьютера
# обычно вебсайты работает по порту 80, тогда номер порта писать не нужно, но если порт другой то нужно


# Далее можно добавлять при необходимости подстраницы например:

get '/' do # корневая страница по адресу localhost:4567 (переходя на нее в браузере мы запрашиваем выполнение метода get '/' на сервере)
  'Hi' # и возвращается данный текст в пустом html фаиле
end

get '/contacts' do # подстраница по адресу localhost:4567/contacts(переходя на нее в браузере мы выполняем метод get '/contacts')
  'phone 1113333'
end


puts
puts '                                           Sinatra reloader'

# Чтобы иметь возможность менять фаилы erb не перезапуская Синатру нужно установить доп гем
# gem install sinatra-reloader   -   установка
# gem install sinatra-contrib   -   альтернативный вариант установки если 1й не работает
# sudo apt install ruby-sinatra-contrib   -   вариант для мака и линукс

# для того чтобы все работало в начале erb фаила необходимо подключить наш гем
require 'sinatra/reloader'


puts
puts '                                            views view .erb'

# view - переводится как 'вид' или 'представление' и относится к frontend(тому что загружается в браузер). Оно пошло из V аббревиатуры MVS(модель вид(view) контроллер). По сути view это HTML-страница но записанная в немного хитром формате

# views(это имя каталога, в нем будут храниться наши представления) если хранить в другом месте синатра не найдет эти фаилы автоматически(хотя можно сказать где искать но структура с views предпочтительнее как стандарт)

# создаем в views HTML-страницу, но расширение у нее будет не .html а .erb например index.erb(название любое)
# пришем в нем необходимый нам HTML-код например <h1>Hi</h1>
# теперь мы можем подключить это представление/view/HTML-код в нашу программу через синтаксис в котором расширение(erb) будет методом, а имя фаила(a_index) символом(его параметром)
require 'sinatra'

get '/' do
  erb :a_index  # метод erb обращается к фаилу(предварительно ищет его в каталоге views) a_index.erb и возвращает его, тогда браузер запрашивая выполнение метода get по адресу '/' получает из него необходимый html код от сервера
  # erb :index можно прочитать как erb(:index). erb - метод, который принимает в качестве аргумента :index
end
# теперь рубикод и HTML-разметка у нас в разных каталогах что довольно удобно

# erb - это один из template(шаблон) engine(движек) те движек шаблонов, соотв есть и другие и для HTML и не только, их можно посмотреть:  # -> https://github.com/sinatra/sinatra -> Available Template Languages


puts
puts '                                                  Метод post'

# метод post обслуживает post-запросы(когда браузер хочет отправить данные например логин и пароль) со страницы(пр '/'), те обрабатывает данные которые браузер отправил к нам на сервер

# Синтаксис erb в HTML-коде(<%= @login %>). В этих(<%= %>) кавычках мы можем писать любой рубикод. Это чемто похоже на интерполяцию.

require 'sinatra'

get '/' do
  erb :a_index
end

post '/' do # в пути пишется тоже самое('/') что и в значении атрибута action в теге формы в .erb фаиле
  @login = params[:aaa] # Обращаемся(когда нажата кнопка формы) к параметрам через метод-хэш 'params' который есть в синатре, этот метод работает как хэш(или и есть хэш?), в котором: key - это значение атрибута 'name' поля в формате символа(тут :aaa), а value это то что пользователь ввел/выбрал в поле; соответсвенно в переменную(тут @login) присваивается значение хэша(введенное в поле пользователем). Теперь значение переменнай @login будет отображаться в представлении в кором она указана. Переменную нужно задавать с @.
  # Всё уже намного проще, просто в erb файле, вместо @login, можно писать сразу params[:aaa](из комментов к уроку 19)
  @password = params[:bbb] # аналогично для пароля
  erb :a_index # возвращаем вид, и если поместить в него наши переменные то отобразятся их значения
end
# теперь в нашей программе существуют 2 переменные(@login и @password) которые мы можем проверять
# информация присваивается в переменную только когда нажимается кнопка, соотв запрос post срабатывает


puts
# Добавляем функциональность(обращение к разному виду/представлению в зависимости от правильности логина и пароля)
require 'sinatra'

get '/' do
  erb :a_index
end

post '/' do
  @login = params[:aaa]
  @password = params[:bbb]

  if @login=='admin' && @password=='secret'
    erb :a_welcome # если условие срабатывает(введенные пароль и логин соответсвуют) возвращаем вид welcome в котором содержится ссылка на страницу contacts
  elsif @login=='admin' && @password=='admin'
    @denied='Haha, nice try! Access is denied!' # можно задать другое значение переменной
    erb :a_index
  else
    @denied='Access is denied' # если условие неверно появляется доп строка на странице(если в фаиле index есть соотв строка)
    erb :a_index # тк мы возвращаем вид index то переменная @denied должна быть в нем, чтобы отобразиться
  end
end

get '/contacts' do # Страница которая будет открываться по ссылке из welcome.erb(<a href="/contacts">Contacts</a>)
  "Contacts: +7 000 000-00-00"
end


# Фишка с добавлением страниц: Если нам на сайте нужно сделать несколько страниц на которых особо ничего не происходит(например тех что просто запланированы или просто страницы особо ничего не содержащие) без добавления разных фаилов(видов), то можно обойтись одним новым представлением для всех
# В данном случае создаем отдельный вид message.erb в котором пишем такой код чтоб все отображанемое на странице передавалось только через переменные
get '/faq' do
  @title='FAQ'
  @message='test page1'
  erb :a_message
end
get '/something' do # В итоге мы создали 2 разные страницы за которые отвечает одно представление message.erb
  @title='Something'
  @message='test page2'
  erb :a_message
end
# Так же мы можем обобщить содержание этих страниц в отдельном методе если оно однотипное
def under_construction
  @title='Under construction'
  @message='This page is under construction'
  erb :a_message
end
get '/some' do
  under_construction
end
get '/other' do
  under_construction
end


puts
puts '                           Запись данных формы в фаил и вывод данных на страницу'

# сохраниение в фаил на примере сайта barbershop
#(для сохранения фаила в маке и линуксе возможно придется его сперва создать с правами доступа при помощи команды chmod 666 users.txt)
require 'sinatra'

get '/' do
  erb :barbershop_index
end

post '/' do
  @user_name = params[:user_name]
  @phone     = params[:phone]
  @date_time = params[:date_time]

  @title = 'Thank you!'
  @message = "Dear #{@user_name}, we'll be waiting for you at #{@date_time}" # производим интерполяцию строк чтобы задать значение переменных в текст для вывода в другом представлении(:barbershop_message)

  f = File.open 'text/barbershop_users.txt', 'a' # создаем txt фаил для списка заявок
  f.write "User: #{@user_name}, phone: #{@phone}, date and time: #{@date_time}\n" # записываем данные из заявок
  f.close

  erb :barbershop_message
end

# Чтение из фаила в синатру вариант 1(без использования erb фаила для этой страницы)
get '/result1' do
  send_file 'text/barbershop_users.txt' # посылаем фаил на страницу /result1 нашего сайта
  # erb :barbershop_result_a # html из этого вида не выводит. Видимо потому что фаил посылается на адрес а не в представление
  # Данным способом почемуто не отображаются данные введенные во время работы с сайтом если дополнительно не обновить страницу
end

# Чтение из фаила в синатру вариант 2
get '/result2' do # HTML текст <h2>RESULT:</h2> тут уже отображается
  @file = File.open('text/barbershop_users.txt',"r")
  erb :barbershop_result_a
  #erb :barbershop_result_b #тут тоже работает
  # @file.close - придется перенести в erb, тк иначе метод возвращает этод код а не вид
end

# Создаем зону /admin где по логину и паролю будет выводиться список записавшихся
get '/login' do
  erb :barbershop_login
end

post '/login' do
  @login    = params[:login]
  @password = params[:password]

  if @login=='admin' && @password=='secret'
    erb :barbershop_admin  # возвращаем вид admin на страницу login
  else
    @dinaed='<p>Access is denied</p>' # можно в рубифаиле вводить текст вместе с тегами тогда не придется их вводить в erb фаиле достаточно будет ввести <%= @dinaed %>
    erb :barbershop_login
  end
end

get '/admin' do # Доп страница для отдельного отображения вида admin без пароля
  erb :barbershop_admin
end


puts
puts '                                             Папка public'

# Позволяет нам обеспечивать доступ дополнительных фаилов в веб(на наш сайт) просто по адресу, без дополнительных элементов кода. Аналогично views папка public автоматически воспринимается Синатрой в этом качестве. Если мы положим в эту папку какой либо фаил, то он будет доступен нам из корня сайта, например localhost:4567/users.txt

# Теперь для записи в этот фаил доступного через веб, достаточно изменить путь на ./public/users.txt (. в начале означает текущий каталог) и наша программа будет куда проще тк этот фаил после создания будет доступен по localhost:4567/users.txt
# В каталоге public можно создавать для удобства любое количество подкаталогов(например для css)
f = File.open './public/users.txt', 'a'  # меняем путь тут


puts
puts '                                             Layout.erb'

# layout.erb - это базовая страница/шаблон, имя зарезервировано. Он будет всегда использоваться Синатрой по умолчанию и добавлять параметр метода erb в точку <%= yield %>. В файле views/layout.erb можно сделать основной каркас страницы, разместить yield и уже из других erb подгружать информацию.

# Задаем аргументом метода erb необходимый html код или представление и он будет выводиться внутри вида layout.erb в точку <%= yield %>. Тоесть метод get вернет нам представление layout.erb c интегрированным в <%= yield %> аргументом метода erb
get '/' do
	erb "Hello! <a href=\"https://github.com/bootstrap-ruby/sinatra-bootstrap\">Original</a> pattern has been modified for <a href=\"http://rubyschool.us/\">Ruby School</a>" # просто строка с html кодом
end
get '/' do
	erb :a_welcome # код из вида a_welcome также помещается в точку <%= yield %>
end


# Сообщение об ошибке(пример вложенного в erb кода Ruby). В layout для нее есть код, проверяющий переменную:
get '/about' do
  @error='Какаято ошибка!!!' # Оппределяем переменную @error
  erb :barbershop_about
end


puts
# Валидация(validation) - обозначает проверку параметров. Например если отправлена форма с незаполненными полями:
get '/' do
  erb :barbershop_index
end
post '/' do
  # при повторной обработке этого запроса все переменные внутри запроса определяются заново, тк метод снова запускается
  @user_name = params[:user_name]
  @phone     = params[:phone]
  @date_time = params[:date_time]

  if @user_name!='' && @phone!='' && @date_time!='' # Пустая строка('') будет значением если ничего не введено в поле
    @title = 'Thank you!'
    @message = "Dear #{@user_name}, we'll be waiting for you at #{@date_time}"
    # Не добавляем @error=nil тк:
    # Во время нового запроса и контекст новый, данные между разными запросами не сохраняются. При каждом другом запросе работает как будто с чистого листа - он проводит человека заново по всем пунктикам, и из-за этого ничего не знает о предыдущем запросе, что сохранялось там, осталось там (кроме как сохранений в сессиях или в базе естественно) Иначе как запросы двух людей разделять
    erb :barbershop_message
  else
    @error = "You forgot enter some field. Please reapite"
    erb :barbershop_index
  end
end

# Для того чтобы пользователь не заполнял все поля заново, если какоето забыто, нужно поставить значение заполненных полей в аргумент value в html-элементе этого поля при помощи синтаксиса <%= ... %> добавив прямо в значение аргумент value переменную
post '/' do
  @user_name = params[:user_name]
	@phone = params[:phone]
	@date_time = params[:date_time]

  # хеш для удобства, значения повторяют значения атрибутов name
	hh = { user_name: 'Введите имя', phone: 'Введите телефон', date_time: 'Введите дату и время' }

	@error = hh.select{|key,_| params[key]==''}.values.join(", ") # объединяем сообщения о незаполненных полях в строку и присвамваем в переменную либо пустую строку если незаполненных значений нет

  return erb :barbershop_index if @error!='' # возвращаем вид в зависимости от того какое значение приняла переменная
  @message = "Dear #{@user_name}, your phone #{@phone}, we'll be waiting for you at #{@date_time}"
  erb :barbershop_message
end


puts
# отправка подтверждения на почту при помощи гема pony
require 'sinatra'
require 'pony'

get '/contacts' do
	erb :barbershop_contacts
end

post '/contacts' do
	@email = params[:email]   # (например) Pushkinidze49@gmail.com
	@user_message = params[:user_message]

	hh = { email: 'Введите почту', user_message: 'Введите сообщение' }
	@error = hh.select{|k,_| params[k]==''}.values.join(', ')

	if @error == ''  
		@message2 = "<p style=\"color: green;\">Сообщение принято, ответ будет прислан на вашу почту по адресу #{@email}</p>"

	  Pony.mail(   # отправляем подтверждение на почту пользователя
		  {
		    :subject => 'Ваше сообщение принято',
		    :body => 'Ваше сообщение принято',
		    :to => @email,
		    :from => 'gigantkroker@gmail.com',

		    :via => :smtp,
		    :via_options => {
		      :address => 'smtp.gmail.com',
		      :port => '587',
		      :user_name => 'gigantkroker@gmail.com',
		      :password => 'lokflkbvmodiyvgy',
		      :authentication => :plain,
		      :domain => 'gmail.com'
		    }
		  }
		)
	end

	erb :barbershop_contacts
end










#
