puts '                               File I/O: Работа с файлами и каталогами'

# File - класc отвеч за раб с фаилами.
# Dir - класс отвеч за работу с директориями

# ВАЖНО: обрабатываются в путях только такие / слэши


puts
puts '                                           File Создание фаила'

# Вы можете создать объект File , используя метод .new, для чтения, записи или того и другого, в зависимости от строки режима. Наконец, вы можете использовать метод .close , чтобы закрыть этот файл.
a_file = File.new("filename.extension", "mode")
  # ... process the file
a_file.close


puts
puts '                                             Чтение файла'

# Можно использовать метод File.open , чтобы создать новый файловый объект и назначить этот файловый объект файлу. Но между методами File.open и File.new есть разница в том, что метод File.open может быть связан с блоком, а File.new не может.

# open("", "") - метод для открытия фаилов, 1й параметр внутри которого указывает на необходимый фаил, а второй - режим в котором мы хотим войти, описание режимов ниже:
# r	  (read) Открытие файла лишь для чтения. Курсор помещается в начало файла перед первым символом.
# r+  Открытие файла для чтения и записи. Курсор помещается в начало файла перед первым символом.
# w   (write) Открытие файла лишь для записи. Файл будет полностью перезаписан новой информацией. Если файла нет, то он будет создан.
# w+	Открытие файла для записи и чтения. Файл будет полностью перезаписан новой информацией. Если файла нет, то он будет создан.
# a   (append - добавить) Только запись в файл. Курсор будет поставлен в конце файла, если файл существует, в противном случае создается новый файл для записи. Данные записываются в конец фаила, после последнего символа либо с новой строки, если текстовый фаил сохранен с новой пустой строкой
# a+	Запись и чтение из файла. Курсор будет поставлен в конце файла, если файл существует, в противном случае создается новый файл для записи.
# b	  Режим двоичного файла (может использоваться с любой из перечисленных команд).
# t	  Режим текстового файла (может использоваться с любой из перечисленных команд, кроме «b»).

File.open("ruby_exemples/text/simple.txt", "r") do |file| # Задаем переменную(file) в которую Ruby присвоит указанный фаил.
  puts file.read() # Без метода read выдаст не содержание фаила, а просто метаданные объекта
  puts file.read().include? "Перед" # При помощи read мы получаем строку, с которой можем проделывать все строковые операции(Почемуто не корректно работает одновременно с предыдущим puts, выводит false, вмето true, хотя символы взяты из текста, но без предыдущего puts все корректно работает)
  puts file.readline() # метод readline читает фаил построчно. так же не работает после предыдущих методов
  puts file.readline() # при повторении читает следующую(2ю) строку(В нашем тексте она пустая)
  puts file.readchar() # читает 1й символ, так же 2й readchar прочитает след символ(работает после readline). После readline читает первый символ следующей строки.

  # Так же мы можем пользоваться циклами:
  for line in file.readlines() # Для обращения к переменной как к массиву строк вместо readline используем метод readlines
    puts line # Получается построчная прочитывание всего фаила
  end # начало читать со 2го символа 3й строки, тк предыдущ операции учлись.
end # Необходимо прописывать end, тк открытый фаил необходимо закрыть чтоб обозначить окончание кода относящегося к нему


puts
puts '                                            Запись в фаил'

# a (append)
File.open("ruby_exemples/text/simple.txt", "a") do |file|
  file.write("\nTEST записи") # метод write() для записи, можно пользоваться \n, чтоб записывалось с новой строки
end # Если повторить запуск, то запишется еще раз, после посл символа. После запусков и записи фаил автоматически сохраняется

# w (write)
File.open("ruby_exemples/text/simple2.txt", "w") do |file| # Перезаписывает фаил, либо создает новый, если такого нет
  file.write("TEST записи")
end


puts
puts '                                    Альтернативный способ чтения и записи'

# Запись в фаил в режиме w
output = File.open("ruby_exemples/text/simple.txt", "w")
  output.write "Something"  # оператор write записывает в фаил строку "Something"
output.close

# Чтение фаила в режиме r
input = File.open("ruby_exemples/text/simple.txt", "r") # название переменной любое не обяз input
  puts input.read
input.close # Закрытие файла для этого способа производится методом close


# Чтение фаила строка за строкой
input = File.open "text.txt", "r"
  while (line = input.gets) # пока строка присудствует в фаиле на который ссылается переменная(?)
    puts line
  end
input.close

# Пример
input = File.open "list.txt", "r"
  n = 1
  sum = 0
  while (line = input.gets)
  	puts "#{n} #{line}"
  	sum += line.split(',')[1].to_i
  	n += 1
  end
  puts "\nTotal sum = #{sum}"
input.close


# Пример 2: выборка из фаила и запись в другой фаил
input = File.open("passwords.txt", "r")
	#puts input.read
  arr = []
	while (line = input.gets)
		puts line if line.chomp.size == 6
    str = line if line.chomp.size == 6
   	arr << str
	end
input.close

output = File.open("pass_output.txt", "w")
	arr.each do |str|
    output.write(str)
  end
output.close

# Другие примеры в Lessons18.rb


puts
puts '                                      Методы работы с фаилами(File)'

# Те же самые методы, которые мы использовали для «простого» ввода-вывода, доступны для всех файловых объектов. Итак, gets читает строку из стандартного ввода, а aFile.gets читает строку из файлового объекта aFile. Однако объекты ввода-вывода предоставляют дополнительный набор методов доступа, облегчающих нашу жизнь:

# Получение директории без имени файла
puts File.dirname("/var/www/test.txt") #=> /var/www
# Переименование фаила
File.rename 'file1.ext', 'file2.ext' #Переиминовывает file1 в file2
# удаления существующего файла tekst2.txt :
File.delete("tekst2.txt")

puts
# IO.each_line. метод читает фаил построчно выгружая из памяти уже прочитанные строки, что позволяет экономить память при работе с большими фамлами
Dir.chdir "C:/Projects/lesson_18" # Меняем директорию при необходимости
File.new('passwords.txt').each do |line|
  password = line.chomp
  puts password.size
end

puts
# sysread(метод системного чтения) - применяется для чтения содержимого файла с возможностью указать колличество читаемых символов. Можно открыть файл в любом из режимов при использовании метода sysread
aFile = File.new("ruby_exemples/text/simple.txt", "r")
if aFile
  content = aFile.sysread(20) # Этот оператор выведет первые 20 символов файла. Указатель файла теперь будет размещен на 21-м символе в файле
  puts content
else
  puts "Unable to open file!"
end
#=> "Работа с фа"    # ? Почему-то не 20 а меньше.

puts
# syswrite(метод системной записи) для записи содержимого в файл. Нужно открыть файл в режиме записи при использовании метода syswrite
aFile = File.new("ruby_exemples/text/simple2.txt", "r+")
if aFile
   aFile.syswrite("ABCDEF")
else
   puts "Unable to open file!"
end

puts
# each_byte всегда связан с блоком. (ХЗ ЧЕ ОН ДЕЛАЕТ)
aFile = File.new("ruby_exemples/text/simple2.txt", "r+")
if aFile
   aFile.syswrite("ABCDEF")
   aFile.each_byte {|ch| putc ch; putc ?. }
else
   puts "Unable to open file!"
end


puts
puts '                                     Права доступа к фаилу в Linux'

# Команда линукса(а так же мак и андроид):
chmod 644 config.php # пример
chmod 765, file1.rb  # Где значение 765 это параметр доступа к фаилу file1.rb. Значения каждой из 3х цифр может быть от 0 до 7
# r - read Прочитать фаил
# w - write Записать в фаил
# x - exequte Запустить фаил
# Каждое из этих свойств может быть включено или отключено - всего комбинаций 8(2**3)
# Кодировка параметров доступа производится в 2ичном когде где x - единицы, w - двойки, r - четверки. 1 в соотв положении значит включен режим, 0 - выключен.
# rwx : 000 = 0, 001 = 1, 010 = 2, 011 = 3, 100 = 4, 101 = 5, 110 = 6, 111 = 7. (первая цифра - r, 2я - w, 3я - x)

# цифры параметра доступа(например 777):
# 1я цифра(у нас 7) отображает для owner(владелец фаила)
# 2я цифра для group(группа)
# 3я цифра для всех остальных

File.chmod 765 # команда Руби меняющая права доступа в фаилы


puts
puts '                                          Методы класса IO'

# Класс File является подклассом класса IO. Класс IO также имеет несколько методов, которые можно использовать для управления файлами.

puts
# IO.readlines . Этот метод возвращает содержимое файла построчно в виде массива
arr = IO.readlines("ruby_exemples/text/simple.txt")
puts arr[0] #=> "Работа с файлами это распространенная вещь в программировании. Нам постоянно ... "
puts arr[1] #=> ""  # Вторая строка пустая
# В этом коде переменная arr является массивом. Каждая строка файла simple.txt будет элементом массива arr. Следовательно, arr[0] будет содержать первую строку, тогда как arr[1] будет содержать вторую строку файла.

puts
# IO.foreach. Этот метод также возвращает вывод построчно. Разница между методом foreach и методом readlines заключается в том, что метод foreach связан с блоком. Однако, в отличие от метода readlines , метод foreach не возвращает массив.
IO.foreach("ruby_exemples/text/simple.txt"){|block| puts block}
# Этот код будет передавать содержимое файла test построчно в блок переменных, а затем вывод будет отображаться на экране


puts
puts '                                           Фаиловые запросы'

# проверяет, существует ли файл перед его открытием:
File.open("file.rb") if File::exists?( "file.rb" )

# выясняет, действительно ли файл является файлом
File.file?( "ruby_exemples/text/simple.txt" ) #=> true

# определяет, является ли данное имя файла каталогом
File::directory?( "/usr/local/bin" ) # => true
File::directory?( "file.rb" ) # => false

# доступен ли файл для чтения, записи или исполняемого файла
File.readable?( "test.txt" )   # => true
File.writable?( "test.txt" )   # => true
File.executable?( "test.txt" ) # => false

# имеет ли файл нулевой размер или нет
File.zero?( "test.txt" )      # => true
# возвращает размер файла
File.size?( "text.txt" )     # => 1002

# определяет тип файла, возвращая одно из следующих значений: file, directory, characterSpecial, blockSpecial, fifo, link, socket, or unknown.
File::ftype( "test.txt" )     # => file

# определения времени создания, изменения или последнего доступа к файлу
File::ctime( "test.txt" ) # => Fri May 09 10:06:37 -0700 2008
File::mtime( "text.txt" ) # => Fri May 09 10:44:44 -0700 2008
File::atime( "text.txt" ) # => Fri May 09 10:45:01 -0700 2008


puts
puts '                                              Dir Каталоги'

# Все файлы находятся в разных каталогах, каталоги обрабатываются классом Dir .

# напечатать текущую директорию
puts Dir.pwd #=> E:/doc

# Изменение относительного(текущего каталога) пути/сменить директорию(можно указать полный путь)
Dir.chdir "C:/Projects" # процесс, все его действия в файловой системе происходят относительно какого то места, оно и называется текущим каталогом после запуска обычно оно равно местоположению программы, а chdir позволяет его сменить. Удобно использовать как в коде так и в irb
# Пример с неполным путем: будет изменение на текущий относительный + новый
puts Dir.pwd #=> E:/doc
Dir.chdir("new_dir")
puts Dir.pwd #=> E:/doc/new_dir

# Все фаилы директории в виде массива(к которому можно будет применить методы массивов)
p Dir.entries "E:/doc" #=> [".", "..", "pic", "ruby_exemples", "Гайд шатдаун DOXAхРоскомсвобода 27.02.2022.pdf", "ГВД", "з.txt", "мма", "паспорт", "покер", "текст", "учеба"]
# Особенности: "E:"(без слэша) == "E:/doc"
p Dir.entries "E:/" #=> ["$RECYCLE.BIN", "doc", "games", "msdownld.tmp", "programs", "System Volume Information", "Безымянный.jpg", "видео", "загрузки", "музыка"]
p Dir.entries "E:" #=> [".", "..", "pic", "ruby_exemples", "Гайд шатдаун DOXAхРоскомсвобода 27.02.2022.pdf", "ГВД", "з.txt", "мма", "паспорт", "покер", "текст", "учеба"]
# Все фаилы директории за исключением "." и ".."
p Dir.children("E:") #=> ["pic", "ruby_exemples", "Гайд шатдаун DOXAхРоскомсвобода 27.02.2022.pdf", "ГВД", "з.txt", "мма", "паспорт", "покер", "текст", "учеба"]


# Создаем новую директорию
Dir.mkdir("new_dir")

# Удаляем директорию, директория должна быть пустой (не иметь файлов или других директорий в ней)
Dir.delete("new_dir")

# Проверяем пустая ли директория
Dir.empty?("new_dir")

# Итерация по папке с получением имен файлов и директорий в заданной папке (., .. - в элементах это норма, это указатели текущей и корневой директорий). Во вложенных директориях файлы показаны не будут (не рекурсивно).
Dir.foreach("test_dir") do |entry|
  puts entry
end

# Тоже самое что выше, но умеет работать рекурсивно и фильтровать выборку.
contents = Dir.glob("**/*") # ** - рекурсия, * - условия выборки aka wildcard (* - никаких, *.txt - только .txt)
contents.each do |entry|
  puts entry
end

# Поиск фаила(пути к фаилу) по полному имени с расширением
p Dir.glob('E:/**/Heather Locklear.jpeg') #=> ["E:/doc/pic/pictures/неон/Heather Locklear.jpeg"]
Dir.glob('E:/**/*/Heather Locklear.jpeg') #=> ["E:/doc/pic/pictures/неон/Heather Locklear.jpeg"]
# поиск по части имени не обязательно расширение
p Dir.glob('E:/**/*Locklear*') #=> ["E:/doc/pic/pictures/неон/Heather Locklear.jpeg"]
# Поиск фаилов по расширению
p Dir.glob('E:/**/*.jpg') #=> ["E:/$RECYCLE.BIN/S-1-5-21-1390554581-1841657848-2307281156-1001/$IRVMUGP.JPG", "E:/doc/pic/foto/фотки/2002-2011/2002 общага 49я/x_45bc2ccf.jpg", "E:/doc/pic/foto/фотки/2002-2011/2002 общага 49я/x_52b287d7.jpg", "E:/doc/pic/foto/фотки/2002-2011/2002 общага 49я/x_8e5a3fe1.jpg", ... и так далее все фаилы на диске с таким расширением

# Вариант 2 "в ручную" при помощи рекурсии
@dir=nil
def filefinder_e(failname, dir)
  return @dir if @dir # возвращаемся если фаил найден
  Dir.chdir(dir) # меняем директорию на заданную
  start_dir=Dir.pwd # начальная директория данного этапа рекурсии
  fold=Dir.children(Dir.pwd) # массив элементов директории
  if fold.find{|e| e==failname} # проверяем есть ли в ней искомый фаил
    @dir=Dir.pwd # если есть присваиваем путь в переменную
    return @dir
  end
  dirs=fold.select{|e| File::directory?(e)} # выбираем среди элементов директории
  dirs.each do |d|
    filefinder_e(failname, Dir.pwd+"/#{d}") # рекурсия - применяем метод к поддиректориям
    Dir.chdir(start_dir) # если не найдено меняем директорию на изначальную для этого этапа рекурсии
  end
  @dir ? @dir : 'не найдено'
end
filefinder_e('Heather Locklear.jpeg', 'E:/doc/pic') #=> "E:/doc/pic/pictures/неон"


puts
puts '                                   Создание временных файлов и каталогов'

# Временные файлы — это файлы, которые могут создаваться на короткое время во время выполнения программы, но не являются постоянным хранилищем информации.

Dir.tmpdir #предоставляет путь к временному каталогу в текущей системе, хотя по умолчанию этот метод недоступен. Чтобы сделать Dir.tmpdir доступным, необходимо использовать require 'tmpdir'.
# Можно использовать Dir.tmpdir с File.join для создания независимого от платформы временного файла —
require 'tmpdir'
tempfilename = File.join(Dir.tmpdir, "tingtong")
tempfile = File.new(tempfilename, "w")
tempfile.puts "This is a temporary file"
tempfile.close
File.delete(tempfilename)
# Этот код создает временный файл, записывает в него данные и удаляет его.

# Стандартная библиотека Ruby также включает библиотеку Tempfile , которая может создавать для вас временные файлы —
require 'tempfile'
f = Tempfile.new('tingtong')
f.puts "Hello"
puts f.path
f.close
