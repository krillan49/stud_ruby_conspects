puts '                                        Переменные и типы данных'

# суть переменных - это ссылки на ячейки памяти, куда мы можем что-то записать и, при желании, изменить.

# В Руби переменная это ссылка на объект. У этих объектов бывают разные типы данных(они принадлежат к объектам разных классов) Если ты перезапишешь переменную, то просто потрешь ссылку

# Операторы puts/print выводят не сами типы данных, а объекты(тип данных object), к которым уже относятся типы данных, являющиеся подтипами/подклассами к object

# Предпочтительно в программировании задавать переменные до блоков кода их обрабатывающих.

#В языках программирования Ruby и JavaScript мы столкнемся с тремя основными naming conventions:
# Snake case (snake - змея), между словами ставится знак подчеркивания underscore (`_`). Переменные именуются следующим образом: client_age, user_password, user_password_expiration_date. Используется в руби, а также в базах данных.
# Camel case (camel - верблюд), слово начинается с маленькой буквы, слова разделяются с помощью больших букв: clientAge, userPassword, userPasswordExpirationDate. Используется в JavaScript.
# Kebab case (kebab - шашлык), слова разделяются дефисом: client-age, user-password, user-password-expiration-date. Иногда используется в HTML, в т.н. data-атрибутах. Например: `<input type="text" name="login" data-error-highlight-color="red">`.

# Кроме naming conventions существуют правила: в руби переменные должны начинаться всегда с буквы, переменные могут содержать цифры и/или знак подчеркивания.

# = Это оператор присвоения

# Названия переменных лучше делать полностью уникальными, чтоб название одной переменной не было составной частью названия другой). Наример первая часть названия это к чему относится переменная, а вторая, что она делает.

# Руби определяет переменную встречая ее в первый раз(пр. а=1). Встречая переменную далее он ее не переопределяет а присваеивает новое значение(пр. а=2)

n.is_a?(Numeric) # проверка принадлежности данных переменной к заданному классу


limit = 100; cols = ["red","yellow","blue"]  # запись любого кода возможно через точку с запятой и/или с новой строки


puts
# Тип данных Integer(целые числа) подтип Fixnum
per_1 = 15
puts (per_1) #=> 15
# Целые числа делятся: Fixnum от -2³⁰ до 2³⁰(занимают меньше памяти(4 байта?) и быстрее работают) и Bignum 2³⁰ и больше. Второй тип может хранить в себе целые числа вообще любого размера, если для них хватит места в оперативной памяти.

# Запись десятичного числа (без учёта знаков «плюс» и «минус») должна начинаться с цифры от 1 до 9. Целое число, которое начинается с нуля, считается восьмеричным. Целое число с префиксом «0x» — шестнадцатеричное, «0b» — двоичное; эта приставка только обозначает в каком исчислении число, а само число идет после неею

# Альтернативная запись больших чисел при помощи нижнего подчеркивания(только в Руби):
x = 1_000_000_000 # => 1000000000

123                  # Fixnum decimal
1_234                # Fixnum decimal with underline
-500                 # Negative Fixnum
0377                 # octal
0xff                 # hexadecimal
0b1011               # binary
?a                   # character code for 'a'
?\n                  # code for a newline (0x0a)
12345678901234567890 # Bignum

# Methods Integer
2.even? #=> true (четный?)
2.odd? #=> false (нечетный?)

12345.digits      # => [5, 4, 3, 2, 1]
# параметр - система исчисления
12345.digits(7)   # => [4, 6, 6, 0, 5]
12345.digits(100) # => [45, 23, 1]


puts
# Тип данных Float(плавающий) - числа с плавающей точкой(4 байта?)
per_2 = 14.5
puts (per_2) #=> 14.5

p 123.4                # floating point value
p 1.0e6                #=> 1000000.0  #scientific notation
p 4E10                 #=> 40000000000.0 #e может быть в любом регистре #dot not required
p 4e20                 #=> 4.0e+20  # если слишком много нулей то выводится в такой форме
p 4e+20                #=> 4.0e+20 sign before exponential
p 3e-20                #=> 3.0e-20
p 5e-3                 #=> 0.005

# Rational (рациональные числа) и Complex (комплексные числа с мнимой единицей).


puts
# В Руби нет единого типа данных Boolean! Есть тип TrueClass и есть FalseClass. Принимают только true или же false. (1 байт)
per_3 = false
puts (per_3) #=> false

# Тип данных Nil - пустое значение переменной
per_4 = nil
puts (per_4) #=>
p per_4 #=> nil

# switch false-true
a = false
b = !a
p b #=> true

# Двойное отрицание возвращает действительность объекта
!![] #=> true


puts
# Тип данных String - строки. Последовательность(массив) байтов в кодировке UTF-8, могут быть любой длины.
per_5 = "Скопец чтоли?"
puts (per_5) #=> Скопец чтоли?

# Array [...] - тип данных массивы
# Hash {...} - тип данных хэши


puts
# Вариант задания переменных сразу
a,b,c = 2,5,4 #=> 2 5 4 #=>[2,5,4]
print a, b, c, "\n"

# Присвоение цепочкой
a = b = c = d = '*'
p a #=> '*'
p c #=> '*'

# инициализация значений из массива
width, length, height = [2,3,4]
p width #=> 2
p length #=> 3
p height #=> 4

# Изменеие значений переменных друг на друга без использования 3й(работает не во всех языках)
x = 10
y = "ten"
x, y = y, x
print "#{x} #{y}\n" #=> ten 10
# Альтернативный способ(но он только для чисел)
a = 5
b = 10
a = a + b # a = 15
b = a - b # b = 5
a = a - b # a = 10


puts
# Особенности присвоения значений переменным:
a = "abcdefg" # => "abcdefg" - переменная a инициализирована новой строкой.
b = a         # => "abcdefg" - переменная b получает ссылку на ТУ ЖЕ строку.
a[3] = 'R'    # => "abcRefg" - строка, присвоенная a, изменяется.
b             # => "abcRefg" - при изменении a неявно изменилось и b, так как они ссылаются на ОДИН объект.
# Однако:
x = 10        # => 10  - переменная x инициализирована числом 10.
y = x         # => 10  - переменная y получает ссылку на то же значение.
x += 5        # => 15  - операция += создаёт НОВОЕ целое значение 15, которое и записывается в x,
y             # => 10    поэтому изменение x не отражается на y


puts
puts '                                             методы class, is_a и methods'

# объект это тоже тип данных
# is_a - метод проверяющий объект по типу данных
123.is_a?(Integer) #=> true
123.is_a?(String) #=> false
123.is_a?(Object) #=> true
"blabla".is_a?(Object) #=> true

# class - метод проверки типа данных объекта(принадлежности к классу)
2.class #=> integer
"2".class #=> string
2.0.class #=> float
5.6.class.superclass #=> Numeric

# methods - метод, который отображает все методы, которые можно применить к применяемому типу данных
"x".methods  # Выведет все доступные операторы методов функций для string
2.0.methods  # для float


puts
puts '                                              Псевдопеременные'

# Это специальные переменные, которые выглядят как локальные переменные, но ведут себя как константы. Этим переменным нельзя присвоить какое-либо значение.

self # объект-приемник текущего метода.
true # значение, представляющее true.
false # значение, представляющее ложь.
nil # значение, представляющее неопределенное.
__FILE__ # имя текущего исходного файла.
__LINE__ # номер текущей строки в исходном файле.


puts
puts '                                           Оператор defined?'

# defined? (определенный?) — это специальный оператор, который принимает форму вызова метода, чтобы узнать, определено ли переданное выражение. Он возвращает строку описания выражения или nil, если выражение не определено.

# Использование 1
defined? variable # True if variable is initialized

foo = 42
p defined? foo    # => "local-variable"
p defined? $_     # => "global-variable"
p defined? bar    # => nil (undefined)

# Использование 2
defined? method_call # True if a method is defined

p defined? puts        # => "method"
p defined? puts(bar)   # => nil (bar is not defined here)
p defined? unpack      # => nil (not defined here)

# Использование 3
defined? super # True if a method exists that can be called with super user
# => "super" (if it can be called)
# => nil (if it cannot be)

# Использование 4
defined? yield   # True if a code block has been passed
# => "yield" (if there is a block passed)
# => nil (if there is no block)


puts
puts '                                       Присвоение условия в переменную'
# Перенести к условным операторам ?
(1..n).map do |num|
  fizz = (num % 3 == 0) # присваиваем результат условия в переменную
  buzz = (num % 5 == 0)
  if fizz && buzz
    "#{num} FizzBuzz"
  elsif fizz
    "#{num} Fizz"
  elsif buzz
    "#{num} Buzz"
  else
    num
  end
end


puts
puts '                                             x op= y'

# x op= y  - где op это некая операция
х = 1
x += 1 #=> 2 (тоже самое что и x = x + 1)


puts
puts '                                             Оператор ||='

# a||=b - является условным оператором присваивания . Это означает или равно. Он проверяет, определено ли значение слева, а затем использует его. Если это не так, используйте значение справа. Это означает: если 'a' не определено или ложно( false или nil) , то оцените 'b' и установите aрезультат. В противном случае (если 'a' определено и оценивается как истинное), то 'b' не оценивается, и присваивание не происходит.
# a ||= b тоже самое что и a = a || b Те в переменную x присваивается результат операции x || y
#a||=b  это примерно  a ? a : a=b  (a=a||b  это примерно  a=a ? a : b)

#Например(a изначально не определено):
a ||= nil # => nil   # не выводит ошибку хотя локальная переменная не определена(хотя так a || 1 будет ошибка) те присвоение в переменную идет до проверки на ошибку. Удобно для установки значения по умолчанию
a #=> nil
a ||= 0 # => 0    # тут уже в переменную присвоился 0
a #=> 0
a ||= 2 # => 0

x = 1
x = 5 || x #=> 5

foo = false # => false
foo ||= true # => true
foo ||= false # => true

# a||=b почти сокращение от a||a=b  (и не эквивалентен a=a||b). Разница в том, что когда a не определено, a||a=b будет повышаться NameError, тогда как a||=b устанавливается a в b. Это различие не имеет значения, если a и b являются локальными переменными, но имеет значение, если любой из них является методом получения/установки класса.



puts
# Потом изменить разделы, переводы в другие типы наверно нужно добавить сюда
p nil.to_i #=> 0

# пример использования для того чтоб нам не важно было пустой хэш или имеет значение
def nil_to_i(par, hh = {})
  x = hh[:a]  #=> число или nil
  x = x.to_i  #=> число или 0 который получился из nil
  x += par    #=> теперь можно складывать даже если там изначально был nil
  hh[:a] = x  #=> перезназначаем значение элемента хэша(в итоге получился аналог hh[:a]+=par)
  hh
end
p nil_to_i(3) #=> {:a=>3}
p nil_to_i(5, {a: 2}) #=> {:a=>7}
