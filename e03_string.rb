puts '                                             Строки(String)'

#"ABCDEFGHIJKLMNOPQRSTUVWXYZ"  "abcdefghijklmnopqrstuvwxyz"

# Строка — изменяемый (!)массив(!) байтов, представляющий символы в кодировке UTF-8. Реализуются классом String.

"abcΣΣΣ".encode("ASCII", "UTF-8", invalid: :replace, undef: :replace, replace: "") # "abc"

# Если строка ограничена апострофами, внутри неё распознаются только специальные последовательности «\\» и «\’», обозначающие соответственно, обратный слэш и апостроф.
puts 'Строка с табуляцией "\t" и символом переноса \'\n\'' #=> Строка с табуляцией "\t" и символом переноса '\n'

# Если строка ограничена двойными кавычками, то в ней распознаются также управляющие символы «\t» (знак табуляции), «\n» (перенос строки), «\010» (любой символ в восьмеричной кодировке) и другие.
puts "Строка с табуляцией \"\\t\" и символом переноса '\\n'" #=> Строка с табуляцией "\t" и символом переноса '\n'

# Ограничители %q[…] или %Q[…] (можно использовать круглые, квадратные, фигурные, угловые скобки и другие символы) позволяют записывать строки с использованием апострофов и кавычек без экранирования. Форма %q[…] также обеспечивает непосредственный вывод управляющих последовательностей:
puts %q[Строка с табуляцией "\t" и символом переноса '\n'] #=> Строка с табуляцией "\t" и символом переноса '\n'

# Для вывода многострочного текста имеется ещё одна форма представления строк:
puts <<EOF
В этом тексте
  всё, включая переводы строк,
         кавычки и отступы,
    будет выведено "как есть".
EOF
# Вместо «EOF» может использоваться любое слово или число, важно, чтобы финальный ограничитель был написан с начала строки и за ним непосредственно следовал перевод строки. В многострочных текстах работает вывод спецсимволов, как и в строках, ограниченных двойными кавычками.


puts
# Создание строки
myStr = String.new("THIS IS TEST")

# Упрощенное создание строки
words = "чето там про фигню"
words2 = "    иЛи пРо иХ оТсУдСтВиЕ\n" # \n - Перенос строки в выводе(puts)
words3 = "И ПРО ЦВЕТ \"ФИГНИ\"" # \" - Простановка знака кавычек внутри кавычек функциональных


puts
# Строковые операции
"aaa" + "bbb" #=> aaabbb
"aaa" == "aaa" #=> true
"aaa" == "bbb" #=> false
# Дублирование строк при помощи оператора *
"abc" * 3 #=> abcabcabc
'=' * 10 #=> ==========
# String*Integer Строку умножаем на число. Наоборот число на строку выйдет естественно херня, тк это не операция умножения, а это оператор * для типа данных String, для мультипликации строки.

# Изменение символа строки по индексу:
a = "abcdefg"
a[3] = 'R'    #=> "abcRefg"

# Выделение части строки дапазоном индексов символов строки:
text = "vasya"
text[0..1] #=> "va"

# Переменная это ссылка на объект строки
a = 'fghj'
b = a
b.capitalize!
b = a
p b #=> "Fghj"
p a #=> "Fghj"


puts
# Методы
puts (words.upcase() + words2 + words3.downcase()) # Операторы для изменения регистра текста(заглавные и строчные)
puts words2.capitalize # Оператор ставящий первую букву в верхний регистр, а все остальные в нижний
# метод strip убирающий пробелы до 1го и после последнего символа, пробелы между слов не трогает. Так же удаляет спецсимволы например \n(whitespace)
p "   текст   с   пробелами   ".strip #=> "текст   с   пробелами"
puts "\ngoga\r".strip #=> goga

# Объединение строки и переменной/числа, перевод их в тип данных строка через .to_s
res = 11 % 5
puts ("результат остатка от деления 11 на 5 равен: "+res.to_s)

cheto = "Хуb рыGaeb"
puts (cheto.length())     # (длинна)Оператор считающий коллич символов в строке, учитывает и пробелы
puts cheto.count("eb")    # Считает число заданных символов в строке(в данном случае 3(2 - b и 1 - e))
puts cheto.include? "ыGa" # Оператор для поиска символов в строке выдает true или false(знак ?)
puts cheto.delete("ХG")   # Оператор для удаления определенных символов(не обязательно стоящих подряд) из строки
puts cheto.start_with?("Ху") # Проверяет начинается ли строка с заданной строки, выдает true или false(знак ?)
puts cheto.empty?         # Проверяет пустая строка или нет, выдает true или false(знак ?)
puts cheto.chop!          # Оператор для удаления последнего символа в строке
# Тк ! это знак присвоения, то строка после подобных преобразований такой и сохраняется
puts cheto.slice! "рыG"   # Оператор извлекающий заданную часть строки(эта часть остается остальная строка убирается)
"hello\nworld\n".lines    #=> ["hello\n", "world\n"]
'stressed'.reverse        # => "desserts"
'hello'.each_char { |x| puts x } #=> итерация для string
'hello'.chars #=> ["h", "e", "l", "l", "o"]  #Возвращает массив символов в str. Это сокращение для str.each_char.to_a.

('A'..'Z').to_a.rotate(n).join #Прокрутка алфавита на n вперед -n назад

# буквенный счет(например для номеров колонок в xl)
'aa'.succ # => "ab"
'az'.succ # => "ba"

'122.99.9.99.999'.next #=> "123.00.0.00.000"

# Вырезать из строки
'f0ff8ff'.scan('ff') #=> ["ff", "ff"]
'stressed'.scan(/.../) #=> ["str", "ess"] #разбивка по числу символов(число точек)
'stressed'.scan(/e.s/) #=> ["ess"]  # Вырезать строки по части их символов
'stressed'.scan(/#{'e.s'}/) #=> ["ess"]  # для переменной

'stressed,,  ff'.squeeze #=> "stresed, f"  убирает элементы повторяющиеся подряд
# squeeze("m-z")

'The   quick brown'.split(/ /) #=> ["The", "", "", "quick", "brown"]
"0 9026315 -827&()".split(/[^0-9]/) #=> ["0", "9026315", "", "827"]
# Сохранение пробела в конце
" Abf b C d E f G ".split(/ /,-1).join(' ') #=> " Abf b C d E f G "
" AbfCgg di Ejjj fii ".split(/\b/) #=> [" ", "AbfCgg", " ", "di", " ", "Ejjj", " ", "fii", " "]
"AbfCgg di Ejjj fii".split(/ab|fi/i) #=> ["", "fCgg di Ejjj ", "i"]
"asd fgh g\njku".split(/^\n| /) #=> ["asd", "fgh", "g\njku"]

# Разбивка вокруг заданного элемента
'abcPgty'.partition('P') #=> ["abc", "P", "gty"]

# Побуквенная замена(по соотв индексам в аргумента)
"hello".tr('el', 'ip')    #=> "hippo"  Замена символо e на i и символа l на p
"hello".tr('a-k', '')     #=> llo
"hello".tr('aeiou', '*')    #=> "h*ll*"
'abcde'.tr('ace', 'RTY')  #=> "RbTdY"
"1 _heKKl+lo".tr('^a-z0-9_', '') #=> "1_hello"
'abz'.tr('a-yz', 'b-za') #=> "bca"
'AabBzZ'.tr('a-yzA-YZ', 'b-zaB-ZA') #=> "BbcCaA"
s.tr('A-Za-z', 'B-ZAb-za') # rotate-1
a.tr("^#{b}", '') # Общие символы 2х строк

# Замена заданной подстроки на заданную подстроку
p "heelloel".gsub(/el/, '+-89') #=> "he+-89lo+-89"

eval("{:a=>1, :b=>2, :c=>3}") #=> {:a=>1, :b=>2, :c=>3}
eval("{:a=>1, :b=>2, :c=>3}").class #=> Hash
arr=eval("[1,[2,[3]]]")
arr #=> [1, [2, [3]]]
arr.class #=> Array

# Возвращает целочисленный порядковый номер односимвольной строки.(англ буквы с c 97)
p 'A'.ord #=> 65
p 'Z'.ord #=> 90
p 'a'.ord #=> 97
p 'z'.ord #=> 122
p '0'.ord #=> 48
p '9'.ord #=> 57
"abc".bytes #=> [97, 98, 99]
"hel".sum #=> 313  #('h.ord' + 'e'.ord + 'l'.ord)

puts 5.chr # вывести символ по его закодированному номеру


((c.ord-97)-n%26+123).chr #  работает корректно для n<=25(либо для отнимания по 1 в цикле)

# Caesar Cipher decode1 with i
if /[A-Z]/===c
  k=((65-(c.ord-shift-i))/26.0).ceil
  c.ord-shift-i<65 ? (c.ord-shift-i+26*k).chr : (c.ord-shift-i).chr
elsif /[a-z]/===c
  k=((97-(c.ord-shift-i))/26.0).ceil
  c.ord-shift-i<97 ? (c.ord-shift-i+26*k).chr : (c.ord-shift-i).chr
end
# Caesar Cipher decode2
c.ord+shift>90 ? ((c.ord+shift-65)%26+65).chr : (c.ord+shift).chr if /[A-Z]/===c
c.ord+shift>122 ? ((c.ord+shift-97)%26+97).chr : (c.ord+shift).chr if /[a-z]/===c
# Caesar Cipher decode3
sd=('a'..'z').to_a.rotate(shift).join
su=('A'..'Z').to_a.rotate(shift).join
text.tr('a-z', "#{sd}").tr('A-Z', "#{su}")


# субпатерны строки
#https://www.codewars.com/kata/5a4a2973d8e14586c700000a/solutions/ruby
#https://www.codewars.com/kata/5a4a391ad8e145cdee0000c4/solutions/ruby
#https://www.codewars.com/kata/5a49f074b3bfa89b4c00002b/solutions/ruby

@nums = %w[zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen]

# Обязательно 2 знака нуля после запятой:
"#{'%.2f' % 1}" #=> "1.00"


puts
# сопоставление текста на общие элементы(поиск наиболее похожнго)
require "rubygems/text"
def find_most_similar(word)
  @words.sort_by{|w| levenshtein_distance(word, w)}.first
end



puts
puts '                                          Интерполяция строк'

# 1. Интерполяция переменных c символьными префиксами #символ_переменнойимя_переменной. Не имнтерполирует выражения
$global = 10
CONST = 9
@instanse = 8
local = 7
puts "This is #$global+#CONST+#@instanse+#local=" #=> This is 10+#CONST+8+#local=
# Не работает с одинарными кавычками
puts 'This is #$global+#CONST+#@instanse+#local=' #=> This is #$global+#CONST+#@instanse+#local=


puts
# 2. Интерполяция выражений #{...}. Можно встраивать в строку выражения, условия математические действия итд.
# Интерполяция строк производится при помощи управляющих символов #{...} внутри строки(кавычек)
a = 1
p "Summ is: #{a + 1}" #=> "Summ is: 2"

# Так удобнее помещать в строку данные другого типа и соответсвенно меньше и понятнее код
area = 3.141592653
p "The area is #{area}." #=> "The area is 3.141592653."

# Инетрполяция строк и специальные символы не работает в одинарных кавычках(''), а работает только в двойных(""), например потому в одинарных кавычках можно писать двойные(и наоборот) без слэша и это не будет разбивать строку
'Hi "ok" #{text} bay'
"hi 'ok' #{text} bay"

# если в строке встречается конструкция #{ }, то всё, что находится внутри фигурных скобок, вычисляется интерпретатором, преобразуется в строковый формат и помещается в данное место создаваемой строки.
for i in (1..7).reverse_each do
  puts "Осталось #{i} секунд#{case i
                              when 2..4 then "ы"
                              when 1 then "а"
                              else ""
                              end }..."
end
# при использовании вставки всё, что находится внутри фигурных скобок, является обычным ruby-кодом, в частности, там не требуется экранирование кавычек.

#Примеры интерполяции
"#{arr[0][n] ? arr[0][n] : ' '} #{arr[1][n] ? arr[1][n] : ' '}\n" # 1
"#{str_1[i] || ' '} #{str_2[i] || ' '}" # 2
