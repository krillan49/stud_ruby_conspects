puts '                                       Регулярные выражения'

# https://docs.ruby-lang.org/en/master/Regexp.html

# Регулярное выражение — это специальная последовательность символов, которая помогает сопоставлять или находить другие строки или наборы строк, используя специальный синтаксис, хранящийся в шаблоне
# Литерал регулярного выражения — это шаблон между косыми чертами или произвольными разделителями, за которыми следует %r
/pattern/

# Ruby позволяет вам начинать регулярные выражения с символа %r, за которым следует разделитель по вашему выбору. Это полезно, когда описываемый вами шаблон содержит много символов косой черты, которые вы не хотите экранировать:
%r|/| # соответствует одному символу косой черты, экранирование не требуется
%r!/usr/local! # общее регулярное выражение с разделителями
%r[</(.*)>]i # Символы Flag также разрешены с помощью этого синтаксиса

# примеры
reg = %r!<(/...|...)>!   # %r!<[^>]*>!   - лучший вариант
"<div>test</div>".gsub(reg, "")#=> "test"

score = "24-79(72); 16-101(53); 86(58)-27; 31-90(74); 0-115(115); 67-40; 61-21"
score.gsub(%r!\((\d+|\d+,\d+)\)!, '') #=> "24-79; 16-101; 86-27; 31-90; 0-115; 67-40; 61-21"


puts
puts '                                      Модификаторы регулярных выражений'

# Литералы регулярных выражений могут включать необязательный модификатор для управления различными аспектами сопоставления. Модификатор указывается после второго символа косой черты, как показано ранее, и может быть представлен одним из этих символов:
/pattern/im # может быть указано несколько опций сразу
# i       - Игнорирует регистр при сопоставлении текста.
# o       - Выполняет интерполяцию #{} только один раз, при первом вычислении литерала регулярного выражения.
# x       - Игнорирует пробелы и разрешает комментарии в регулярных выражениях
# m       - Соответствует нескольким строкам, распознавая новые строки как обычные символы.
# u,e,s,n - Интерпретирует регулярное выражение как Unicode (UTF-8), EUC, SJIS или ASCII. Если ни один из этих модификаторов не указан, предполагается, что регулярное выражение использует исходную кодировку.



puts
puts '                                      Шаблоны регулярных выражений'

# За исключением управляющих символов (+ ? . * ^ $ ( ) [ ] { } | \), все символы соответствуют самим себе. Можно экранировать управляющий символ, поставив перед ним обратную косую черту "\".

^ # Соответсвует началу строки
$ # Соответствует концу строки
. # Соответсвует любому одиночному символу кроме новой строки. Использование параметра m так же помогает ему соответсвовать новой строке
[] # Соответсвует любому одиночному символу из указанных в скобках
[^] # Соответсвует любому одиночному символу кроме указанных в квадратных в скобках

# *далее re это некое предшествующее регулярное выражение:

re* # Соответствует 0 или более вхождениюям предыдущего выражения
  str="gkhgckhcghg<Anastasia> +48-421-674-8974 Via Quirinal Roma"
  name=str.scan(/<.*>/) #=> ["<Anastasia>"]
re+ # Соответствует 1 или более вхождениюям предшествующего выражения
re? # Соотвествует 0 или 1 вхождению предыдущего выражения
re{n} # Соответсвует точно n вхождениям предыдущего выражения
re{n,} # Соответсвует n или более вхождениям предыдущего выражения
re{n, m} # Соответсвует не менее чем n и не более чем m вхождениям предыдущего выражения

a|b # Соответсвует либо a либо b
(re) # Группирует регулярные выражения и запоминает совпадающий текст
(?imx) # Временно включает опции i, m или x в регулярном выражении, если в скобках затрагивается только эта область
(?-imx) # Временно отключает параметры i, m или x в регулярном выражении, если в скобках затрагивается только эта область
(?: re) # Группирует регулярные выражения без запоминания совпадающего текста
(?imx: re) # Временно включает опции i, m или x в скобках
(?-imx: re) # Временно отключает параметры i, m или x в скобках
(?#...) # Комментарий
(?= re) # Задает положение при помощи шаблона. Не имеет диапазона
(?! re) # Определяет позицию используя отрицание шаблона. Не имеет диапазона
(?> re) # Соответсвует независимому шаблону без возврата

\w # Соответсвует символам слова
\W # Соответсвует несловесным символам
\s # Соответсвует пробелам, эквивалентно [\t\n\r\f]
\S # Соответсвует непробельным символам
\d # Соответсвует цифрам, эквивалентно [0-9]
\D # Соответсвует нецифрам
\A # Соответсвует началу строки
\Z # Соответсвует концу строки. Если существует новая строка, она соответсвует непосредственно перед новой строкой
\z # Соответсвует концу строки
\G # Соответсвует точке где закончилось последнее совпадение
\b # Соответсвует границам слов вне квадратных скобок
\B # Соответсвует границам слов
\n, \t, \etc. # Соответсвует символам новой строки, возврата каретки, табуляции итд
\1..\9 # Соответсвует энному сгруппированному подвыражению
\1 # Соответсвует энному сгруппированному подвыражению если оно уже совпало. В противном случае относится к восьмеричному представлению кода символа


puts
puts '                                        Примеры регулярных выражений'

# Буквенные(Literal) символы:
/ruby/ # Соответсвует "ruby"

/hgkjhg/ #=> 'hgkjhg' подстрока целиком соответсвует условию оператора
/[hgkjhg]/ #=> каждый символ в скобках отдельно соответсвует условию оператора
# Квадратная скобка это каждый как в операторе tr

# Character Classes:
/[Rr]uby/ # Соответсвует "Ruby" или "ruby"
/rub[ye]/ # Соответсвует "ruby" или "rube"
/[aeiou]/ # Соответсвует одной из букв в квадратных скобках(гласные) в нижнем регистре
/[0-9]/ # Соответсвует любой цифре, тоже что и /[0123456789]/
/[a-z]/ # Соответсвует любой строчной букве ASCII
/[A-Z]/ # Соответсвует любой заглавной букве ASCII
/[a-zA-Z0-9]/ # Соответсвует любому символу из этих диапазонов
/[^aeiou]/ # Соответсвует любому символу кроме строчных гласных
/[^0-9]/ # Соответсвует любому символу кроме цифр

# Special Character Classes:
/./ # Соответсвует любому символу кроме новой строки
/./m # В многострочном режиме так же соответсвует и новой строке
/\d/ # Соответсвует /[0-9]/
/\D/ # Соответсвует /[^0-9]/
/\s/ # Соответсвует /[\t\r\n\f]/
/\S/ # Соответсвует /[^\t\r\n\f]/
/\w/ # Соответсвует одному символу слова /[A-Za-z0-9_]/
/\W/ # Соответсвует одному символу не являющемуся словом /[^A-Za-z0-9_]/

# Случаи повторения:
/ruby?/ # Соответсвует "rub" или "ruby", символ y не обязателен
/ruby*/ # Соответсвует "rub" плюс 0 или более "y"
/ruby+/ # Соответсвует "rub" плюс 1 или более "y"
/\d{3}/ # Соответсвует ровно 3м цифрам
/\d{3,}/ # Соответствует 3м и более цифрам
/\d{3,5}/ # Соответсвует 3, 4 или 5 цифрам

/<.*>/ # жадное повторение: соответсвует "<ruby>perl>" в "<ruby>perl>" (берет все символы до последнего символа(тут >))
/<.*?>/ # не жадное соответсвует "<ruby>" в "<ruby>perl>" (берет все символы до ближайшего символа(тут >))

# группировка со скобками:
/\D\d+/ # без группы (от + повторяется только \d)
/(\D\d)+/ # сгруппировано (от + повторяется пара \D\d)
/([Rr]uby(,)?)+/ # соответсвует например "Ruby, Ruby, ruby ruby" итд

# Back References(назад ссылки):
/([Rr])uby&\1ails/ # Соответсвует "Ruby&Rails" или "ruby&rails" (1 - берет 1й символ в выражении)

# Альтернативы:
/ruby|rube/ # Соответсвует "ruby" или "rube"
/rub(y|le)/ # Соответсвует "ruby" или "ruble"
/ruby(!+|\?)/ # "ruby" за которым следует один или более знаков ! или один знак ?

# Якоря. Необходимо указать позицию совпадения
/^Ruby/ # Соответсвует "Ruby" в начале строки(перед нет символов) или внутренней линии(строки текста?)
/Ruby$/ # Соответсвует "Ruby" в конце строки(после нет символов) или линии(line)
/\ARuby/ # Соответсвует "Ruby" в начале строки
/Ruby\Z/ # Соответсвует "Ruby" в конце строки
/\bRuby\b/ # Соответсвует "Ruby" на границе слова
/\brub\B/ # \B не является границей слова: соответсвует "rub" в "rube" и "ruby" но не отдельно

/Ruby(?=!)/ # Соответсвует "Ruby" если за ним стоит восклицательный знак
/Ruby(?!!)/ # Соответсвует "Ruby" если за ним не стоит восклицательный знак

# Специальный синтаксис со скобками:
/R(?#comment)/ # Соответсвует "R" все остальное комментарий
/R(?!)uby/ # Нечувсивмитклен к регистру при сопоставлении "uby"
/R(?!:uby)/ # Тоже что и выше
/rub(?:y|le))/ # Только группа без создания обратной ссылки \1


puts
puts '                                               Regexp class'

# Экранирование управляющих элементов
Regexp.escape("-..,.44$&%$--,.,") #=> "\\-\\.\\.,\\.44\\$&%\\$\\-\\-,\\.,"


puts
puts '                                               Поиск и замена'

# Некоторые из наиболее важных методов String, использующих регулярные выражения, — это sub и gsub, а также их варианты sub! и gsub! Все эти методы выполняют операцию поиска и замены с использованием шаблона Regexp. sub и sub! заменяет первое вхождение шаблона а gsub & gsub! заменяет все вхождения.

"text\n0987, asd".gsub(/[0-9 ,\s]/, '') #=> "textasd"   # удаляем символы "0-9 ,\s"

phone="2004-959-559 #This is Phone Number"
phone.sub!(/#.*$/, "") #=> 2004-959-559  # удаляем Ruby-style коментарии
phone.gsub!(/\D/, "") #=> 2004959559  # удаляем все кроме цифр

# Меняет любую гласную на (!!!)
'ytesuityFTGFDI'.gsub(/[aeiou]/i, '(!!!)') #=> "yt(!!!)s(!!!)(!!!)tyFTGFD(!!!)"

# Меняет на "x" элементы являющиеся отдельными словами(до и после пробелы) из списка
"It should have helped him,".gsub(/\b(him|her|he|it|she)\b/i, 'x') #=> "x should have helped x,"

# Меняет подстроку Probably или probably на Prolly или prolly
'Abc Probably probably'.gsub(/([pP])robably/, "\\1rolly") #=> "Abc Prolly prolly"

# Скобки обособляют условия (\d+|\d\/\d) (tbsp|tsp) == цифра.цифра или число + ' ' + tbsp или tsp
'3/0 tsp aaa 2 tbsp 4 tspr'.gsub(/(\d+|\d\/\d) (tbsp|tsp)/, 'A') #=> "A aaa A Ar"

# Интерполяция
name='Vasya'
'strgVasyajhlhj'.gsub(/[^#{name}]/, '') #=> "sVasya"

# Применение меиодов только для символов соотв регулярному выражению
s.gsub(/[aeiou]/i, &:swapcase)
"a+b-c/d*30".gsub(/\w+/, &:reverse) #=> "a+b-c/d*03"

# условие в gsub(замены разных символов на разные строки)
str.gsub!(/[ab]/, "a" => "aRbFR", "b" => "LFaLb")

# блок в gsub
str.gsub!(/[ab]/){|с| с=='a' ? 'aRbFR' : 'LFaLb'}
text.gsub(/[A-Z]/) { |c| (c.ord - 65 - (c >= 'J' ? 1 : 0)).divmod(5).map { |x| x + 1 }.join }


# Замена элементов на их модифицированные версии(в блок передаются и изменяются те подстроки что соотв условию, остальные части строки остаются неизменными)
def anchorize(t)
  t.gsub(/http:\/\/[^ ]{1,}/){|match| "<a href=\"#{match}\">#{match}</a>" }
end
p anchorize('hello http://world.com !') # hello <a href="http://world.com">http://world.com</a> !'


puts
puts '                                               Разные примеры'

'abcdefghijklmnopqrstuvwxyz'
'BCDFGHJKLMNPQRSTVWXYZ'
'bcdfghjklmnpqrstvwxyz'

# поиск индекса символа
'foo' =~ /f/ # => 0
'foo' =~ /o/ # => 1
# сосчитать кол символов в строке при помощи $
"!!!!!"=~/$/ #=> 5


# Включает ли значение переменной слово alligator вне зависимости от регистра
animal = 'тAlligAtorgoh'
animal =~ /alligator/i ? true : false #=> true

# убирает все символы после символа #
url = 'https://www.codewars.com/#ukfkh67879900jnjn'
url[/[^#]+/] #=> "https://www.codewars.com/"

# Включены ли только строчные буквы цифры и подчеркивание длинна строки от 4 до 16
username.match?(/^[a-z\d_]{4,16}$/)
# Содержит ли слово согласную +"y" в конце
word.match?(/[^aeiou]y$/)
# Содержит одну только букву
s.match?(/\A[a-z]\z/i)

# Разбивка по 2м разным символам
"{{name}} likes {{animal_type}}".split(/[{}]/) #=> ["", "", "name", "", " likes ", "", "animal_type"]
# Разбивка по буквам соответсвующим
"ultrarevolutionariees".split(/[^aeiou]/) #=> ["u", "", "", "a", "e", "o", "u", "io", "a", "iee"]
str.split(/#{a}/) # интерполяция переменной

# Подсчет символов соотв
s.count('^a-zA-Z0-9')


# Интерполяция
"ultrarevolutionariees".scan(/#{'.'*2}/) #=> ["ul", "tr", "ar", "ev", "ol", "ut", "io", "na", "ri", "ee"]
# Интерполяция "сложная"
$div_by_4=/^\d*(#{('00'..'96').step(4).to_a.join('|')})$/

$div_by_4=/(0|4|8|(\d*((0|2|4|6|8)(0|4|8)|(1|3|5|7|9)(2|6))))$/
$div_by_4=/([048]|(\d*([02468][048]|[13579][26])))$/


'HaHahahahaHaHahaha'.scan(/(ha)+|(Ha)+/).size # Считает количество переходов с 'ha' на 'Ha' и наоборот

self.scan(/#\w+/) # Вырезаем слова начинающиеся с # и состоящие из символов \w

# Вернуть все буквы стоящие после символов заданных переменной letter в строке
str.scan(/(?<=#{letter})[a-z]/i).join


# метод scan вырезает только части выражения в скобках если строка соотв всему выражению иначе возвращает пустой массив
logparser=/\A(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}) {1,}(ERROR|INFO|DEBUG) {1,}\[([a-z0-9]{1,}):{0,1}([a-z0-9]{1,}):{0,1}([a-z0-9]{1,}){0,1}\] {1,}([a-zA-Z' ]{1,})\z/
p "2003-07-08 16:49:45,896 ERROR [user1:mainfunction:subfunction] We have a problem".scan(logparser)
#=> [["2003-07-08 16:49:45,896", "ERROR", "user1", "mainfunction", "subfunction", "We have a problem"]]
# возвращает элемент nil в массив если данное подвыражение отсутсвует(если это отсутсвие соотв выражению({0,}))
p "2003-07-08 16:49:46,896 INFO [user1:mainfunction] We don't have a problem".scan(logparser)
#=> [["2003-07-08 16:49:46,896", "INFO", "user1", "mainfunction", nil, "We don't have a problem"]]


# поиск слов в строке
"milkshakepizzachickenfriescokeburgerpizzasandwichmilkshakepizza".scan(/milkshake/) #=> ["milkshake", "milkshake"]
"milkshakepizzachickenfriescokeburgerpizzasandwichmilkshakepizza".scan('milkshake') #=> ["milkshake", "milkshake"]

# Переменная содержит какоето из этих слов(переменная всегда справа)
/hello|ciao|salut|hallo|hola|ahoj|czesc/i === greetings

# Содержится ли символ в икс
/[a-z]/ === x
# Соответсвие(каждая точка любой символ, число точек должно соотв числу пропущ символов)
/code...s/==="codewars" #=> true
# строка соответсвует длинне строки s(столько же или больше) и содержит только символы из условия
s='abc'
/[#{s}]{#{s.size}}/==='aabcc' #=> true
/[#{s}]{#{s.size}}/==='aacc' #=> true
/[#{s}]{#{s.size}}/==='aa' #=> false

# Принадлежит ли значение диапазону
('0'..'255') === '245' #=> true

# Не содержится ли символы в строке
self !~ /\S/

# начинается ли с строка с одной или другой буквы
"pello".start_with?(/H|P/i) #=> true

# строка соответсвует '+1 MDZHB 80 516 GANOMATIT 21 23 86 25'(только это 2цифры 3цифры люб.аглавные 4раза по 2 цифры)
!!(message =~ /\+1 \AMDZHB \d{2} \d{3} [A-Z]+ \d{2} \d{2} \d{2} \d{2}\z/)

# Совокупность многих условий
[/[A-Z]/, /[a-z]/, /\d/, /.{8}/].all?{ |re| string =~ re }

# проверяет - строка состоит из эн одинаковых подстрок("abbaabbaabba" - true, "abbabbabba"-false)
/\A(\w+)\1+\z/ === s

regex=/^(?=.*[A-Z])(?=.*[0-9])[A-Z0-9]{6,}$/ # Регулярное выражение утверждает, что где(?=.*[A-Z])-то в строке есть алфавитный символ в верхнем регистре, и утверждает, что где(?=.*[0-9])-то в строке есть цифра, а затем проверяет, является ли все буквенным символом или цифрой и что колличество символов больше или равно 6.
