puts '                                           Array (Массивы)'

# Массивы Ruby представляют собой упорядоченные коллекции(наборы) объектов любого типа с целочисленным индексом. Каждый элемент массива связан с индексом и ссылается на него. Сам массив как и все в Руби объект. Массивы используются для представления последовательности данных, элементов идущих по-порядку

puts
puts '                                          Одномерные массивы'

# Одномерный массив состоит из нескольких элементов, объединенных под одним именем.
arr = Array[3, 5, 9, true, "Сися", 6.25] #=> [3, 5, 9, true, "Сися", 6.25]

# Способы инициализации:
nums = Array.[](1, 2, 3, 4, 5) #=> [1, 2, 3, 4, 5]
digits = Array(0..9) #=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
arr1 = [1, 3, "rr"] #=> [1, 3, "rr"]
arr2 = :a, "b", 3 #=> [:a, "b", 3]  # можно и без скобок

# Инициализация массива(только для элементов string) с пробелами вместо запятых и без кавычек
list3 = %w[Roman 32 Mike] #=> ["Roman", "32", "Mike"]
list3a = %w(one two three four five) #=> ["one", "two", "three", "four", "five"]


puts
# Индексы и их применение:
names = ["Гонзик", "Влаженка", "Крокер", 1, 5, 100] # Индексы в Массивах начинают свой счет с нуля Гонзик=0, Влаженка=1, Крокер=2
names[2] #=> Крокер
names[-1] #=> 100  # Индексы в массивах можно брать с конца тогда начинаются с минус единицы 100 = -1, 5 = -2, 1 = -3 итд

# Вывод нескольких элементов с указанием индекса начала(1е число) и длинны(2е)(только с положительными индексами):
names[1, 3] #=> ["Влаженка", "Крокер", 1]  3 элемента начиная с эл под индесом 1
# удобно когда неизвестен размер массива(не будет ошибки если он меньше)

# при вводе с puts элементы массива будут выводиться в столбик
print(names[1, 2],"\n") #=> ["Влаженка", "Крокер"] а вот так уже будут выведены в строку

# Диапазоны элементов
names[0..3] #=> ["Гонзик", "Влаженка", "Крокер", 1]  элементы с индексами от 0 до 3
names[0...3] #=> ["Гонзик", "Влаженка", "Крокер"]
names[1..1] #=> ["Влаженка"]
names[-3..-1] #=> [1, 5, 100]  Можно использовать отрицательные индексы
names[1..] #=> ["Влаженка", "Крокер", 1, 5, 100] Можно использовать открытый диапазон

# Тк names[1..3] возвращает новый массив ["Влаженка", "Крокер", 1] то [1] уже обращается к этому новому массиву
names[1..3][1] #=> Крокер
names[0..2][rand(0..2)] # пример применения

# Переназначение элемента по индексу
names[0] = "Сдох"
names #=> ["Сдох", "Влаженка", "Крокер", 1, 5, 100]
# Изменение элемента по индексу
names[1].upcase!
names #=> ["Сдох", "ВЛАЖЕНКА", "Крокер", 1, 5, 100]

# Математические операции с эементами массивов
mas1[0] + 10 + mas2[1] #=> 16


puts
# добавление символов в элементы массива по индексу
arr = ['a', 'b', 'c']
arr[0] << '???' #=> "a???"
arr[1] << 69 #=> "bE"
arr #=> ["a???", "bE", "c"]


puts
#Новый пустой массив(создание/инициализация массивов):
list = Array.new
# Добавление элементов в массив:
list[0] = 29
list[3] = 90
list[5] = 29
list #=> [29, nil, nil, 90, nil, 29] # Недостающие элементы перед заданными, автоматически заполняютмя значением nil (nil - null object/нулевой объект)

# При инициализации этим способом, можно передать параметры при инициализации, задав число изначальных элементов и сами элементы или блок их создающий
arrp0 = Array.new(10) #=> [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil]
arrp = Array.new(10, 1) #=> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
nums = Array.new(10){|i| i} #=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # блок по умолчанию принимает индексы

# Альтернативный вариант инициализации
list2 = []
list2 << 10 #ставит по порядку индексов от 0
list2 << "ggg"
list2[5] = 100
list2 << :Vasya #ставит после последнего элемета
list2 << 'one' << 'two'
list2.push(5, 'fuu') # альтернативный вариант добавления элементов по порядку(добавит элементы 5 и 'fuu'). Также реализован в языке JavaScript, поэтому многие веб-программисты предпочитают использовать его
list2 #=> [10, "ggg", nil, nil, nil, 100, :Vasya, "one", "two", 5, "fuu"]


puts
# Удаление из массивов по индексу
list4 = [:a, :b, :c, :d]
list4.delete_at 1 #=> b (Возвращает удаленный элемент)
list4 #=> [:a, :c, :d] (Возвращает измененный массив)

# Удаление из массивов по элементу
list5 = [:a, :b, :c, :d]
list5.delete :c #=> c
list5 #=> [:a, :b, :d]


puts
# сложение массивов
mas1 = [1, 2, 3, 5, 5]
mas2 = [4, 5]
mas1 + mas2 #=> [1, 2, 3, 5, 5, 4, 5]

# вычитание массивов(вычитаются все элементы что вхлдят во 2й массив втч и повторяющиеся)
mas1 - mas2 #=> [1, 2, 3]

# сравнение массивов по последовательным членам(ранние важнее поздних)
mas1 <=> mas2 # -1   # массив 1 меньше потому что его 1й член меньше первого члена второго массива


# заполнение массива диапазонами
[*('a'..'c'), *('D'..'F'), *('4'..'7')] #=> ["a", "b", "c", "D", "E", "F", "4", "5", "6", "7"]
[('a'..'c'), ('D'..'F'), ('4'..'7')] #=> ["a".."c", "D".."F", "4".."7"]

list = [1, 2]
[0, 0, *list, 0, 0] #=> [0, 0, 1, 2, 0, 0]


[1, 2, 3].to_s #=> "[1, 2, 3]"


puts
puts '                              Копирование массива(контринтуитивный момент)'

# Невозможно сделать копию массива, переназначив его в новую переменную, тк это просто будет та же ячейка памяти которую вызывают несколько переменных. Массив - изменяемый объект сам по себе, соответственно, при изменении значения переменной руби не создает новый массив, а изменяет старый:
arr1 = [1, 1, 1, 1]
arr2 = arr1
arr2[0] = 'A'
[arr1, arr2] #=> [["A", 1, 1, 1], ["A", 1, 1, 1]]

# Дла копирования нужно использовать дополнительные методы, например clone или dup
arr1 = [1, 1, 1, 1]
arr2 = arr1.clone
arr3 = arr1.dup
arr2[0] = 'A'
arr3[1] = 'B'
[arr1, arr2, arr3] #=> [[1, 1, 1, 1], ["A", 1, 1, 1], [1, "B", 1, 1]]
# для многомерных массивов похоже надо клонировать и все подмассивы(?)


puts
puts '                                                Методы'

# Методы разное
[1, 2, 3, 4, 5].length #=> 5  # length/size считает длинну(по числу элементов) массива
list[rand(0...list.size)] #=> возвращает случайный элемент массива
[:right, :left, :up, :down].sample #=> :right   # случайный элемент массива
[:right, :left, :up, :down].sample(2) #=> [:right, :down]   # выбирает несколько случайных элементов массива
[1, 2, 3, 4, 5].reverse #=> [5, 4, 3, 2, 1]  # располагает элементы массива в обратном порядке
[1, 2, 3, 4, 5].rotate(2) #=> [3, 4, 5, 1, 2]
[1, 2, 3, 4, 5].rotate(-1) #=> [5, 1, 2, 3, 4]
list.include? 28 # ищет элемент true - нашел, false - не нашел
list.uniq # .uniq выбирает не повторяющиеся(исключает повторяющиеся) элементы массива
list.count # считает число элементов массива(можно задавать условия и блоки для выборки)
list.sort # Сортирует элементы в алфавином поряке(String), порядке возрастания(Numeric) итд
[].empty? #=> true # Проверяет пустой ли массив(nil считается элементом)[в Рэилс есть отличия см книгу стр 131-132]
[1,2,3].push(5, 'fuu') #=> [1, 2, 3, 5, "fuu"]  Добавляет элементы в конец массива
[1, 2, 3].pop #=> 3 (Массив становится [1, 2]). Удаляет и возвращает последний элемент.
[1, 2, 3].pop(2) #=> [2, 3]  # массив становится [1]  # отрезает несколько элементов
[1, 2, 3].unshift('a') #=> ["a", 1, 2, 3] Добавляет элемент в начало массива
[1, 2, 3].shift #=> 1 (Массив становится [2, 3]). Удаляет и возвращает первый элемент. Можно задать integer аргумет задающий число удаленных элементов с начала.
[5, 8, 4].drop(1) #=> [8, 4]  удаляет 1й элемент и возвращает массив без него
[11, 22, 33, 44, 55].take(2) #=> [11, 22] Берет элементы из начала(сам массив не изменяется)
[11, 22, 33, 44, 55].last(2) #=> Берет элементы из конца(сам массив не изменяется)
[1, 2, 3, 4, 5].find{|e| e == 2} #=> 2  # detect/find Ищет первое совпадение
[11, 22, 33, 44, 55].fetch(2, 'такого индекса нет') #=> 33 # Ищет по индексу если такого нет то выдает default_value
[11, 22, 33, 44, 55].fetch(5, 'такого индекса нет') #=> "такого индекса нет"


# Выборка при помощи метода grep
[0, 3.3, 5, 'ff', 7].grep(Integer)                #=> [0, 5, 7]            # по классу
[4,5,8,9,4,5,1,3,6].grep((3...7))                 #=> [4, 5, 4, 5, 3, 6]   # по диапазону
['abcde', 'adeab', 'abdgse', 'bdefa'].grep(/^ab/) #=> ["abcde", "abdgse"]  # (начинаются с "ab") по регекс


arr = eval("[1,[2,[3]]]") #=> [1, [2, [3]]]
arr.class #=> Array

# Разбивка и вырезка позволяющая избегать ошибок сложения при некорректных индексах
arr = ["a", "b", "c", "d", "e", "f", "g", "h"]
[*arr[0...2], *arr[2...5].reverse, *arr[5..-1]] #=> ["a", "b", "e", "d", "c", "f", "g", "h"]

# Уникальный элемент массива
numbers.reduce(:^)
numbers.inject(:^)
a.inject(0){|c, n| c^n}

# Поиск общих элементов(не учитывает повторы)
%w[a b b c d] & %w[g f d b b b s a k c] #=> ["a", "b", "c", "d"]
# хотябы один
(m & n).any?
# Поиск общих элементов 2d
[%w[a b c d], %w[g f d s a k c]].inject(:&) #=> ["a", "c", "d"]

# Поиск общих элементов(учитывает повторы)
def common(a, b, c)
  ha, hb, hc = a.tally, b.tally, c.tally
  (ha.keys + hb.keys + hc.keys).uniq.map do |k|
    values = [ha[k], hb[k], hc[k]]
    values.compact.size < 3 ? nil : [k]*values.min
  end.compact.flatten
end
p common([1,2,2,3],[5,3,2,2],[7,3,2,2]) #=> [2, 2, 3]

# найти отсутствующее число в массиве последовательных чисел при помощи арифм прогрессии (s=(a1+an)*n/2)
(a[0] + a[-1]) * (a.size + 1) / 2 - a.sum

# содержит ли массив все элементы другого массива(с повторяющимися)
needle.uniq.all?{|e| haystack.count(e) >= needle.count(e)}

# Разница массивов с повторными элементами
s2.chars.select{|x| s1.count(x) < s2.count(x)}
a.uniq.map{|n| [n, [a.count(n), b.count(n), c.count(n)]]}

# поиск дубликатов в массиве(быстрый)
ary.group_by{|e| e}.select{|k, v| v.size > 1 }

# Подсчет числа повторов каждого элемента
[10,9,8,9,6,1,2,4,3,2].group_by{|e| e}.map{|k, v| [k, v.size]}.to_h #=> {10=>1, 9=>2, 8=>1, 6=>1, 1=>1, 2=>2, 4=>1, 3=>1}
[10,9,8,9,6,1,2,4,3,2].tally #=> {10=>1, 9=>2, 8=>1, 6=>1, 1=>1, 2=>2, 4=>1, 3=>1}
[1,2,5,5,6].sort.chunk{|e| e}.to_a #=> [[1, [1]], [2, [2]], [5, [5, 5]], [6, [6]]] # chunk arra->enumerable

# Разбивка массива на подмассивы
[1, 2, 3, 4, 5, 6, 7].each_slice(3).to_a #=> [[1, 2, 3], [4, 5, 6], [7]]
# Разбиваем между 1м и 2м параметром когда выполняется условие для послндовательных членов
[0,4,4,4,0,4,3,3,0].slice_when{|x, y| x == 0 or y == 0}.to_a #=>[[0], [4, 4, 4], [0], [4, 3, 3], [0]]
# Не разбиваем пока выполняется условие
[1,2,4,9,10,11,12,15,16,19,20,21].chunk_while {|i, j| i + 1 == j}.to_a #=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
[1000, 0, 1, 0, 0, 0, 0].chunk_while(&:==).to_a #=> [[1000], [0], [1], [0, 0, 0, 0]]

# Действия с 2мя последовательными членами
[1,2,3,4,5,6].each_cons(3).to_a #=> [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]

# Распределяет элементы по индексам четные и нечетные
[1, 2, 3, 4].partition.with_index{|_, i| i.even?} #=> [[1, 3], [2, 4]]


# Разбивка массива по шаблону
def razbiv(form, arr)
  form.map{|e| arr.shift(e)}
end
razbiv([1,2,3,4], [1,2,3,4,5,6,7,8,9,10]) #=> [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]
razbiv([4, 2, 6, 3, 5], ["g", "k", "g", "v", "k", "y", "u", "n"]) #=> [["g", "k", "g", "v"], ["k", "y"], ["u", "n"], [], []]


# Разбивка массива по индексам
arr=[1, 3, 7, 'a']
inds=[[1], [1, 3]]
inds.map{|a| arr.map.with_index{|c, i| a.include?(i) ? ' ' + c.to_s : c}.join.split} #=> [["1", "37a"], ["1", "37", "a"]]


# Найти зацикленную последовательность(1939) в массиве(если она начинается с верного элемента)
arr, res = [1, 9, 3, 9, 1, 9, 3, 9, 1, 9, 3], []
arr.each do |n|
  res << n
  break if (res*(arr.size/res.size+1))[0..arr.size-1] == arr
end
res #=> [1, 9, 3, 9]


# Оптимизация перед пермутацией(сокращение максимального числа повторяющихся элементов до колличества в пермутации(тут n))
arr = ["3", "7", "7", "7", "3", "3", "3", "7", "8", "8", "8"]
n = 3
hh = arr.tally
moda = hh.map{|k, v| v > n ? [k]*3 : [k]*n}.flatten #=> ["3", "3", "3", "7", "7", "7", "8", "8", "8"]


puts
puts "                                                Методы с блоками"

# cycle Зацикленный вывод(будет выводить значения массива по кругу до принудительной остановки или бесконечно):
counter = 0
["a", "b", "c"].cycle{|x|
  print "#{x} "
  counter += 1
  break if counter > 10
} #=> a b c a b c a b c a b

# Считает индексы большие чем есть в массиве
[1, 2, 3].cycle.with_index do |n,i|
  print i
  break if i == 9
end
#=> 0123456789

# Заполнение подмассивов при помощи присвоения цикла cycle в переменную
def custom(s, n)
  w = s.chars.cycle # присвоение цикла в переменную  w.class#=>Enumerator
  (1..n).map{|i| i.times.map{w.next}}
end
custom('abc', 3) #=> [["a"], ["b", "c"], ["a", "b", "c"]]


puts
# each(каждый) Передает каждый последующий элемент массива в блок(проводит итерацию); возвращает исходный массив:
names2 = ["Гонзик", "Влаженка", "Крокер"]
x = 1
names2.each do |name|
	puts "#{x}.#{name} - ok"
  x += 1
end #=> ["Гонзик", "Влаженка", "Крокер"]


# Присвоение новых значений через переменную per в  - each do |per|, если это массив(иначе не присваивается)
items = [[1, 'a'], [2, ['b']], [3, 'c']]
items.each do |per|
  per[1] = 'new'
end
p items #=> [[1, "new"], [2, "new"], [3, "new"]]


# Метод-расширение each_with_index передает 2 параметра для того чтоб обойтись для подсчета при помощи переменной
names2.each_with_index{|name, i| puts "#{i + 1}.#{name} - ok"}

# замена элементов в массиве при помощи each в процессе итерации, меняет и индексы в процессе
def unflatten(arr)
  arr.each_with_index do |n, i|
    arr[i..n+i-1] = [arr[i..n+i-1]] if n > 2
  end
end
unflatten([1, 4, 5, 2, 1, 2, 4, 5, 2, 6, 2, 3, 3])#=> [1, [4,5,2,1], 2, [4,5,2,6], 2, [3, 3] ]


# Метод map/collect, map!/collect! map выполняет действие с каждым элементом в массиве и возвращает его результат в виде массива.
[1, 3, 4, 5, 7].map {|n| "#{n + 2} summ"} #=> ["3 summ", "5 summ", "6 summ", "7 summ", "9 summ"]

# Условие с or в map
arr.map.with_index{|n, i| arr[0..i].reverse.detect{|k| k < n} or -1}


# Метод select(Выбор элементов по критерию) Возвращает выбранные элементы
[ [30, 1], [25, 0], [64, 1], [64, 0], [33, 1] ].select{|e| e[0] == 64 && e[1] == 1 } #=> [[64, 1]]
# Метод reject(Отсечение элементов по критерию) Возвращает массив исключив выбранные элементы
[ [30, 1], [25, 0], [64, 1], [64, 0], [33, 1] ].reject{|e| e[0] > 30 or e[1] == 0 } #=> [[30, 1]]

# находит все элементы соотв условию(аналог select ?)
arr.find_all { |e| arr.count(e) > 1 }

# Метод find выбирает одно самое первое совпадение и останавливает итерацию
people.find { |element| element[1] == 1 } #=> [30, 1]

# Метод find_index/index(Ищет индекс элемента удовлетворяющего условию)
[false, false, false, true, false].index { |element| element == true } #=> 3

# Метод any?(Есть ли хотя бы один элемент удовлетворяющий условию)
[1, 2, 3, 4, 5].any? { |element| element == 3 } #=> true

# Метод all?(Все элементы должны удовлетворять критерию)
[20, 34, 65, 23, 18, 44, 32].all? { |element| element >= 18 } #=> true

# Метод max_by(максимальный из соответсвующих условию)
[1, 5678, 43].max_by { |num| num.to_s.size } #=> 5678

# Сортировка массива по 2м параметрам(параметр Numeric можно поставить перед ним знак минус, будет сортировать от наибольшего)
[[5,3],[5,4],[5,10],[3,1]].sort_by! {|a,b| [a, -b]} #=> [[3, 1], [5, 10], [5, 4], [5, 3]]

# sum - сумма элементов измененных при помощи условия
[1,2,3].sum{|e| e**2} #=> 14


puts
puts '                                         Двумерные массивы(2D array)'

# Элементами 2д массива являются массивы.

list_names = [["Mike", 56], ["Walt", 53]]

list_names[0] #=> ["Mike", 56]
list_names[0][1] #=> 56  # сначала нужно обратиться к строке (row), а потом к столбцу (column)
list_names[1][1] = 54 #=> [["Mike", 56], ["Walt", 54]]  # переназначение
list_names[1][2] = 67316 #=> [["Mike", 56], ["Walt", 54, 67316]]  # назначение нового элемента
list_names[0] << 62222 #=> [["Mike", 56, 62222], ["Walt", 54, 67316]]  # добавление нового элемента

# Наиболее часто встречающиеся наименования строк и столбцов:
# row - строка, column - столбец. Обращение к массиву: arr[row][column]
# y - строка, x - столбец. Обращение к массиву: arr[y][x]
# j - строка, i - столбец. Обращение к массиву: arr[j][i]


# запись элементов в пайпах блока 2мерного массива
[[1],[2],[3]].map{|(n)| n} # [1, 2, 3]
[[1, 10], [2, 20], [3, 30]].map{|(n, m)| m} #=> [10, 20, 30]


puts
puts '                         Инициализация 2мерного массива(контринтуитивный момент)'

arr = Array.new(10, []) # Так инициализировать не надо
arr #=> [[], [], [], [], [], [], [], [], [], []]
arr[4].push('some') # ожидание => [[], [], [], [], ["some"], [], [], [], [], []]
arr #=> [["some"], ["some"], ["some"], ["some"], ["some"], ["some"], ["some"], ["some"], ["some"], ["some"]]
# При инициализации массива мы передаем ссылку (reference) на один объект([]). Т.к. мы передаем параметр([]) один раз, то и объект в массиве всегда “размножается по ссылке”. Т.е. на самом деле при такой инициализации массива, все ячейки содержат ссылки на один и тот же объект. Чтобы этого не происходило, нужно чтобы ссылки на объекты были разные. При этом, конечно, и сами объекты будут разные - они будут располагаться в разных областях памяти, и если мы что-то изменим, то это не изменит состояние (state) других объектов.

# В случае с числами все еще проще:
arr = Array.new(10, 123) # В классе Integer нет опасных методов, поэтому, даже если у вас есть доступ к объекту, вы не сможете его изменить (но сможете заменить).
# Если вы напишите
arr[4] = 555 # то вы замените ссылку в массиве на новый объект, который будет представлять число “124”. Ссылки на один и тот же объект “123” в других частях массива сохранятся. Т.е. мы и получим то, что ожидаем:
arr #=> [123, 123, 123, 123, 555, 123, 123, 123, 123, 123]

# ПРАВИЛЬНЫЙ СИНТАКСИС для объявления двумерного массива 10 на 10 в руби (массив будет заполнен nil - объектом, представляющим пустое значение):
arr = Array.new(10) { Array.new(10) } # Метод “new” (на самом деле это метод “initialize”) принимает один параметр и один блок. Первый параметр (“10”) - фиксированный, это количество элементов массива. А второй параметр(“{ Array.new(10) }”) - блок, который надо исполнить для каждого элемента. Результат выполнения этого блока и будет новым элементом. Блок будет запускаться 10 раз (в нашем случае)

# ПРАВИЛЬНО. конструкция(arr1) при инициализации вызывает блок. В результате вызова блока каждый раз создается новое значение “something” в новой области памяти.
arr1 = Array.new(3) { 'something' }
arr1 #=> ["something", "something", "something"]
arr1[0].upcase!
arr1 #=> ["SOMETHING", "something", "something"] Изменилось только первое значение, тк ссылка везде разная.

# НЕПРАВИЛЬНО. (arr2) берется “something”, который мы передали через параметр. Он создается в области памяти перед тем, как параметр будет передан в метод new, и используется для всех ячеек массива, всегда один и тот же.
arr2 = Array.new(3, 'something')
arr2 #=> ["something", "something", "something"]
arr2[0].upcase!
arr2 #=> ["SOMETHING", "SOMETHING", "SOMETHING"] поменялся массив целиком, потому что ссылка на элемент во всех ячейках массива одинаковая

# Если бы мы перед “upcase!” переинициализировали какой-либо элемент, то этот элемент не был бы затронут:
arr2 = Array.new(3, 'something')
arr2[2] = 'something'
arr2[0].upcase!
arr2 #=> ["SOMETHING", "SOMETHING", "something"]
# элемент с индексом 2 не был затронут операцией “upcase!”, т.к. это совершенно другой объект, хотя при выводе на экран нам кажется что все одинаково

# Если нужно заполнить массив значением, отличным от nil, передаем его во второй конструктор:
# Создать массив в 4 строки и 10 столбцов и заполнить его значением “0”:
arr = Array.new(4) { Array.new(10, 0) }
# Создать массив в 2 строки и 3 столбца и заполнить каждую строку одинаковым объектом “something”:
arr = Array.new(2) { Array.new(3, 'something') }
# Создать массив 5 на 4 и заполните весь массив абсолютно случайными значениями от 0 до 9.
arr = Array.new(5) { Array.new(4) { rand(10) } }


puts
# 2D Methods

[[:a0, :a1], [:b0, :b1], [:c0, :c1]].transpose #=> [[:a0, :b0, :c0], [:a1, :b1, :c1]] # Делает строки столбцами и столбцы строками("поворачивает" 2д массив). Или создает 2в массив подмассивы которого содержат элементы с итыми игдексами изначальных подмассивов.

# Авттообрезка при помощи select(&:all?) если массивы разной длинны
[1, 2, 3].zip([1, 2]).select(&:all?) #=> [[1, 1], [2, 2]]

# Поиск(счет) массивов как элементов
sp.count(["pirate"])

# 2 параметра для 2х элементов подмассивов
[['ABC', 65], ['HGR', 74]].count{ |str, num| str.include?(num.chr) } #=> 1

# Отбор и сортировка элементов 2д массива по элементам подмассивов(uniq==uniq_by)
[["d",1], ["d",2], ["d",3], ["E",1], ["C",5]].uniq{|a| a[0]} #=> [["d", 1], ["E", 1], ["C", 5]]
[["d",1], ["d",2], ["d",3], ["E",1], ["C",5]].uniq(&:first) #=> [["d", 1], ["E", 1], ["C", 5]]

[["d",1], ["d",2], ["d",3], ["E",1], ["C",5]].sort_by(&:last)
#=> [["E", 1], ["d", 1], ["d", 2], ["d", 3], ["C", 5]]

# Сортировка с указанием подмассива в параметрах в скбках
arr = [[0, [2, -2, 3]], [5, [4, 2, 6]], [1, [2, -2, 3]], [4, [5, 4, 5]], [2, [1, -3, 2]], [3, [4, 1, 4]]]
arr.sort_by{|i,(a,b,c)| [-a,-b,-c]}
#=> [[4, [5, 4, 5]], [5, [4, 2, 6]], [3, [4, 1, 4]], [1, [2, -2, 3]], [0, [2, -2, 3]], [2, [1, -3, 2]]]

# параметр agrs
a[0].product(*a[1..-1]).uniq.size

# product для 2д массива
groups = [ %w[hello goodbye], %w[world everyone], %w[here there] ]
combinations = groups.first.product(*groups.drop(1))

#
[[1, 1], [2, 2], [1, 6] [7, 8]].take_while { |a, b| a == b } #=> [[1, 1], [2, 2], nil]


puts
# реверсирование 2х главных диагоналей матрицы
def diagonal_reverse_unit(matrix)
  0.upto(matrix.size/2-1) do |i|
    matrix[i][i], matrix[matrix.size-1-i][matrix.size-1-i] = matrix[matrix.size-1-i][matrix.size-1-i], matrix[i][i]
  end
  matrix
end
def reverse_on_diagonals(matrix)
  diagonal_reverse_unit(diagonal_reverse_unit(matrix).reverse).reverse
end

puts
# Диагонали 2д массива
arr = [
  [1, 2, 3, 4],
  [3, 4, 5, 6],
  [5, 6, 7, 8],
  [2, 3, 4, 5]
]
# Доп элементы к каждой строке
pattern = (0..arr.size-1).map{|i| [nil]*i} #=> [[], [nil], [nil, nil], [nil, nil, nil]]
# Добавляем справа и слева для смещения элементов
res = pattern.reverse.zip(arr).zip(pattern).map(&:flatten)
#=> [[nil, nil, nil, 1, 2, 3, 4], [nil, nil, 3, 4, 5, 6, nil], [nil, 5, 6, 7, 8, nil, nil], [2, 3, 4, 5, nil, nil, nil]]
res.transpose.map(&:compact)
#=> [[2], [5, 3], [3, 6, 4], [1, 4, 7, 5], [2, 5, 8], [3, 6], [4]]

# Все диагонали(с обоих углов)
def diags(matrix)
  [matrix, matrix.reverse].map do |m|
    pat = (0..m.size-1).map{|i| [nil]*i}
    res = pat.reverse.zip(m).zip(pat).map(&:flatten)
    res.transpose.map(&:compact)
  end
end
diags(arr)
#=> [[[2], [5, 3], [3, 6, 4], [1, 4, 7, 5], [2, 5, 8], [3, 6], [4]],
#   [[1], [3, 2], [5, 4, 3], [2, 6, 5, 4], [3, 7, 6], [4, 8], [5]]]


# Перебор элементов по диагонали от правого нижнего(отсюда можно вывести поворот массива по диагонали)
def diagonal(arr)
  arr.transpose.map(&:reverse).reverse.map.with_index{|a,i| a.map.with_index{|e,j| [e, i, j]}}.flatten(1)
  .sort_by{|a| [a[1]+a[2], a[1]]}.map{|a| a[0]}
end
p diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]])# [9, 6, 8, 3, 5, 7, 2, 4, 1]
#[[9, "0-0"], [6, "0-1"], [8, "1-0"], [3, "0-2"], [5, "1-1"], [7, "2-0"], [2, "1-2"], [4, "2-1"], [1, "2-2"]]


puts
# подсчет всех клеток 2д массива которые находятся в линии пересекающей точку посчета(не включая ее саму)
a*b*(a+b-2) # lines
a,b = [a,b].sort
2*a*(a-1)*(3*b-a-1)/3 # diagonals


puts
puts '                                            многомерные массивы(тензоры)'

# Если 2D массив это “массив массивов”, то 3D массив это “массив массивов массивов”. Иногда такие массивы называют “тензор”.

# массив 2 на 3 на 3: два блока, в каждом блоке 3 строки, в каждой строке 3 столбца.
arr = [
  [ %w(a b c), %w(d e f), %w(g h i) ],
  [ %w(aa bb cc), %w(dd ee ff), %w(gg hh ii) ]
]
arr[0][1][2] #=> 'f'


# Посчитать число вложенных подмассивов
a.to_s.count("[")


# способ записи параметров для многомерных массивов
points_list1 = [[1,2,-4], [-3, 2, 4], [7, 8, -4], [2, 3, 5], [-2, -1, 1]]
p_in_s.combination(3).to_a.each do |(x1,y1,z1),(x2,y2,z2),(x3,y3,z3)|
end


puts
puts '                                                 Matrix'

# https://ruby-doc.org/stdlib-3.0.0/libdoc/matrix/rdoc/Matrix.html
# перевод массива в матрицу
require 'matrix'
matrix1 = Matrix[[1,2,3],[4,5,6],[7,8,9]] #1
nested_array = [[1,2,3],[4,5,6],[7,8,9]] #2
matrix2 = Matrix[nested_array] #=> Matrix[[[1,2,3],[4,5,6],[7,8,9]]]
matrix3 = Matrix[*nested_array] #=> Matrix[[1,2,3],[4,5,6],[7,8,9]]

# Определитель(determinant)
Matrix[[7,6], [3,9]].determinant #=> 45
Matrix[[2,5,3], [1,-2,-1], [1, 3, 4]].det  #=> 20

# Решение матрицы
m = Matrix[[1, 0, 0], [4, -5, 1], [0, 0, 1]] #=> Matrix[[1, 0, 0], [4, -5, 1], [0, 0, 1]]
b = Vector[0, 0, 729] #=> Vector[0, 0, 729]
a = m.lup.solve(b).to_a #=> [(0/1), (729/5), (729/1)]  ( rescue 0  для вырожденных дописать)

# Диагональ
Matrix[ [1,2], [3,4] ].each(:diagonal).to_a #=>[1,4]
:all #(по умолчанию) возвращает все элементы
:diagonal# дает только элементы по диагонали
:off_diagonal# возвращает все элементы, кроме диагональных
:lower# дает только элементы на диагонали или ниже
:strict_lower# выдает только элементы ниже диагонали
:upper# возвращает только элементы на диагонали или выше
:strict_upper# выдает только элементы выше диагонали


require 'matrix'
p Matrix.identity(5).to_a #=> [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]]

# Сложение 2д массивов где складываются попарно все [i][j] элементы обоих массивов, образуя матрицу того же размера
require 'matrix'
(Matrix[*a] + Matrix[*b]).to_a
(Matrix.rows(a) + Matrix.rows(b)).to_a #альтер вариант

# Нахождение координат(индексов) элемента 2д массива
require 'matrix'
arr = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 'e', 0], [0, 0, 0, 0] ]
p Matrix[*arr].index('e') #=> [2, 2]
