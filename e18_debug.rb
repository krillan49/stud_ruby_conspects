puts '                                     Отладка программ(debugging)'

# Существует несколько способов отладки программы, написанной на языке руби. Вот некоторые из них:
# С использованием вывода в консоль (puts, print)
# С использованием консольного отладчика
# С использованием отладчика, встроенного в текстовый редактор или среду разработки (IDE)


puts
puts '                  Отладка с использованием вывода информации в консоль(puts something.inspect)'

# Это один из самых эффективных способов отладки программы. В любом месте программы мы можем написать выражение: puts something.inspect
# inspect это метод, который реализован в объекте любого типа. Этот метод возвращает строковое представление объекта.
# puts nil и puts "" выведут на экран пустую строку. Тогда как с .inspect на экран будет выведено nil и "" соответственно
puts nil #== puts(пустая строка)
puts nil.inspect #=> nil
p nil #=> nil
puts "" #== puts(пустая строка)
puts "".inspect #=> ""
p "" #=> ""

# Для тех, кто работает с фреймворком Ruby on Rails, полезна будет следующая конструкция:
something = '123'
puts 'Каша служебных сообщений'
puts '=' * 80
puts something.inspect
puts '=' * 80
puts 'Каша служебных сообщений'
# Вывод переменной в этом случае не затеряется среди «простыни» служебных сообщений, так как будет выделен знаками =.


puts
# чтобы прервать выполнение программы на этом участке кода, можно воспользоваться ключевым словом raise, которое выбросит исключение (стандартную ошибку) и завершит работу (фреймворк Ruby on Rails завершит только текущий запрос [request]):
puts '=' * 80
puts something.inspect
puts '=' * 80
raise


puts
# Т.к. руби — язык с динамической типизацией, по исходному коду не всегда можно сказать где именно определен тот или иной метод, пока программа не запустится и не дойдет до определенной точки. В RubyMine существует комбинация клавиш Cmd + B (на macOS) или Ctrl + B (на ОС Windows и Linux), которая покажет где именно находится тот или иной метод. Однако и RubyMine не всегда способен определить точное месторасположение вызываемой функции. В этом случае поможет следующая конструкция:
puts method(:something).source_location
# Если в объекте определен метод something, то на экран будет выведен путь к файлу с номером строки.

# Если код выполняется в цикле, то иногда полезно комбинировать if и puts:
puts something.inspect if i == 100


# В случае если требуется узнать стек вызова (stack trace, последовательность вызова функций), можно вывести массив caller. Это зарезервированное слово, которое доступно в любом месте:
def random_pow
  pow(rand(1..10)) # передаеем в метод pow рандомное число
end

def pow(x)
  puts "=" * 80
  puts caller     # вызываем последовательность работы методов
  puts "=" * 80
  x ** 2
end
puts random_pow
#=> ================================================================================
#=> E:/doc/ruby_exemples/test2.rb:3:in `random_pow'
#=> E:/doc/ruby_exemples/test2.rb:12:in `<main>'
#=> ================================================================================
#=> 9
# Читать stack trace нужно в обратном порядке. Мы видим, что первый вызов функции random_pow произошел на 12 строке, а второй вызов на 2-ой. Таким образом, caller ничто иное как call stack (стек вызовов).


puts
# В языке JavaScript тоже существует метод отладки в виде вывода в консоль. Вместо puts необходимо использовать console.log, который может принимать один или несколько параметров и также выводит информацию в консоль:
console.log(some_variable);
# Существует похожий метод, который выводит более подробную информацию об объекте:
console.dir(some_variable)


puts
puts '                                Отладка с использованием консольного отладчика'

# pry может использоваться не только как REPL, но и как отладчик.
# Например мрожно установить breakpoint(точку остановки) в определенном месте программы. И когда программа дойдет до этой точки, то будет остановлена и управление будет передано человеку. Человек с помощью специальных инструментов сможет проанализировать программу именно в этой точке: посмотреть на переменные, переданные параметры, на стек вызова.

require 'pry' # требуем (require) загрузки библиотеки pry

def random_pow
  pow(rand(1..10))
end
def pow(x)
  binding.pry # binding.pry это специальный синтаксис. Он говорит о том, что в этом месте должна произойти остановка программы и должен быть вызван отладчик.
  x ^ 2
end
puts random_pow
# братите внимание, что раньше мы запускали pry непосредственно из командной строки. А в этот раз мы запустили программу обычным способом:
#...
# $ ruby app.rb
# From: /Users/ro/work/book/app.rb @ line 8 Object#pow:
#    7: def pow(x)
# => 8: binding.pry
#    9: x ^ 2
#   10: end
# ...Теперь просто вводим в pry(main)> те параметры значения которых хотим проверить:
# [3] pry(main)> x
# 2
# [4] pry(main)> x ^ 2
# 0
#...
# Стрелка(=>) слева показывает где мы находимся. Если ввести команду whereami(надо запомнить) — то вы увидите место текущего брейкпоинта.
# Что это нам дает в плане отладки:
# Мы можем посмотреть значения переменных (например, переменной x)
# Мы можем изменить значения переменных
# Мы можем вызвать какой-либо метод один или несколько раз
# Мы можем вставить (например, скопированный из буфера обмена код) и посмотреть как он работает
# Мы можем попытаться вычислить результат выполнения следующей строки (например, путем ее копирования или просто ввода с клавиатуры) и посмотреть что произойдет

# Другие возможности pry, когда мы находимся в точке остановки:
# Команда next выполнит следующую строку. После этого снова можно посмотреть значение переменных, чтобы понять что не так с программой.
# Команда exit вернет выполнение в программу. Т.е. это выход из Pry, но не из программы. Можно было дать более правильное имя этой команде continue (продолжить).
# Команда exit! (с восклицательным знаком) прервет выполнение программы с выходом в терминал.
# Команда whereami (от англ. Where Am I — где я?) может быть полезна когда, например, после вывода большого текста на экран (или очистки экрана кодом из нашей программы) мы все еще хотим знать в каком месте программы мы в данный момент находимся.


puts
# system('reset'). Эта команда не является стандартной в pry: system это просто метод языка руби, который выполняет команду оболочки reset (она != reboot, которая перезагружает компьютер)
# system('ls') - можно получить список файлов в текущей директории
# system('pwd') - покажет путь к текущей директории процесса.
# man reset в вашем терминале - Справка по reset говорит о том, что команда используется для сброса настроек оболочки в настройки поумолчанию. В больших проектах существует множество gem’ов, которые могут выводить в консоль отладочную информацию, иногда эта информация сбивает настройки терминала и возникает необходимость вернуть эти настройки обратно без перезапуска отладчика. Сделать это можно с помощью system('reset') или просто взяв слово reset в обратные кавычки (backticks)
# [1] pry(main)> `reset`
# (произошла очистка экрана)
# ""
# [2] pry(main)> whereami
# ...
