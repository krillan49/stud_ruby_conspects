puts '                                   Associsted queries methods(AR)'

# Ассоциации между моделями позволяют эффективно работать с связанными данными. Для оптимизации запросов к базе данных используются методы includes, preload, eager_load, joins и references

#             | Количество запросов | Тип запроса          | Загрузка ассоциаций  |
# |-----------|---------------------|----------------------|----------------------|
# | includes  | 2                   | 2 отдельных запроса  | Да                   |
# | preload   | 2                   | 2 отдельных запроса  | Да                   |
# | eager_load| 1                   | JOIN                 | Да                   |
# | joins     | 1                   | JOIN                 | Нет                  |
# | references| 0                   | Уточняет условия     | Нет                  |

# Выбор метода зависит от потребностей в производительности и структуре данных:
# Если нужно избежать N+1 запросов, используйте includes или preload
# Если нужно фильтровать результаты по полям ассоциированных таблиц, используйте joins или eager_load



puts '                                             includes'

# includes - метод используется для предварительной загрузки ассоциированных данных. В зависимости от контекста и условий запроса, может выполнять один или два запроса. Если вы добавляете условия на ассоциированные данные в запросе, includes обычно выполняет один запрос с JOIN, это позволяет фильтровать результаты на основе полей ассоциированных моделей. Если условий нет, он выполняет два отдельных запроса (один для основной модели и один для ассоциированных)

# Может быть более производительным, если вам нужно фильтровать данные на основе ассоциированных таблиц, поскольку он может выполнить один запрос с JOIN

# Выполняет два запроса, если нет условий
@users = User.includes(:posts).all # Это приведет к выполнению двух запросов:
# 1. Запрос для загрузки пользователей.
# SELECT "users".* FROM "users";
# 2. Запрос для загрузки постов, связанных с этими пользователями.
# SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3, ...);

# Выполняет один запрос с JOIN, если есть условия
@users = User.includes(:posts).where(posts: { published: true })
# SELECT "users".* FROM "users" JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE posts.published = true;

@questions = Question.includes(:user).order(created_at: :desc) # загружаем все вопросы и для каждого вопроса сразу подгрузить юзеров, которым они принадлежат, тк иначе потом получится, что придеся делать для каждого вопроса отдельный запрос, который вытаскивает для него юзера. Это и есть проблема N+1 и мы ее так решили

# С includes(:user) в представлении все равно вызываем свойства из user от ассоциации user как и обычно, например:
question.user.email

# (??? если вызываем вопрос от ассоциации, например от текущего пользователя, то данные пользователя автоматом стыкуюися к подкастам и includes(:user) уже не нужно ??)



puts '                                             preload'

# preload - метод также загружает ассоциированные данные, но всегда выполняет отдельные запросы: один для основной модели и один для ассоциированных моделей. Он никогда не использует JOIN, что может быть полезно в ситуациях, когда нужно избежать сложных запросов и просто получить связанные записи

# Лучше подходит для случаев, когда вы хотите просто загрузить ассоциации без каких-либо условий, так как он избегает потенциальной сложности с JOIN

# Всегда делает два запроса:
@users = User.preload(:posts).all
# SELECT "users".* FROM "users";
# SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3, ...);

# Не может использовать JOIN
@users = User.preload(:posts).where(posts: { published: true }) # будет ошибка, если здесь есть условия



puts '                                            eager_load'

# eager_load - метод выполняет загрузку ассоциированных данных с использованием JOIN. Он выполняет один запрос с JOIN, что может быть более производительно в некоторых случаях, особенно если вы планируете фильтровать или сортировать по полям ассоциированных таблиц. Этот метод может быть менее эффективным, если у вас много связанных записей, так как он может возвращать дублирующиеся строки.

@users = User.eager_load(:posts).where(posts: { published: true })
# SELECT "users".* FROM "users" JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE posts.published = true;



puts '                                               joins'

# joins - метод используется для создания SQL JOIN между таблицами, но не загружает ассоциированные данные. Он позволяет фильтровать результаты на основе условий в связанных таблицах, но данные из этих таблиц не будут доступны в загруженных объектах. Для загрузки данных в дополнение к нему нужно использовать метод references. Этот метод полезен, когда вам нужно только отфильтровать записи, но не требуется загружать связанные объекты.

@users = User.joins(:posts).where(posts: { published: true })
# SELECT "users".* FROM "users" JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE posts.published = true;



puts '                                             references'

# references - метод используется вместе с joins и необходим для указания ActiveRecord, что вы хотите использовать условия на ассоциированных таблицах в вашем запросе. Он не выполняет никаких дополнительных запросов, а просто уточняет, какие таблицы должны быть включены в SQL-запрос

@users = User.joins(:posts).where(posts: { published: true }).references(:posts)



puts '                                               pluck'

# pluck - метод извлекает только указанные в параметрах столбцы из найденных записей и возвращает массив массивов со значениями этих полей в подмассиве для каждой строки из таблицы. 

# pluck эффективнее, чем select, так как select создает объекты модели (медленнее, но позволяет работать с методами модели), а pluck сразу возвращает массив значений из БД (быстрее)

# Используется:
# 1. Когда нужны только данные, без объектов ActiveRecord
# 2. Для оптимизации, если не требуется работа с полными объектами
# 3. Часто применяют для выпадающих списков (select_tag), где нужны только пары id-name


Provider.all.pluck(:id, :name) # выполняет запрос к таблице providers, извлекает только указанные столбцы (id и name) из найденных записей и возвращает массив массивов в виде пар [id, name] для всех поставщиков, например
[ [1, "Поставщик 1"], [2, "Поставщик 2"] ]

# Код генерирует следующий SQL:
<<-SQL SELECT providers.id, providers.name FROM providers; SQL


# Пример использования в контроллере, чтобы получить список поставщиков для выпадающего меню
@providers_for_select = Provider.where(cabinet: current_cabinet).pluck(:id, :name)
# Результат можно передать в options_for_select:
select_tag :provider_id, options_for_select(@providers_for_select)
