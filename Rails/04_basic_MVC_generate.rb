puts '                                               generate'

# Не обязательно пользоваться генераторами и можно все создавать вручную

# generate - команда для запуска генераторов с различными параметрами

# > rails generate генератор параметры_генератора
# > rails g генератор параметры_генератора
# > rails g                                        - проверить все существующие в проекте генераторы(как от Рэилс так и от гемов)

# Виды генераторов(бывают как от самого Рэилс так и от различных гемов):
# controller - генератор контроллеров с маршрутами и предсталениями для них
# model      - генератор моделей и миграций
# migration  - генератор миграции без модели
# scaffold   - генератор одновременно для модели, контроллера, экшенов, маршрутов, представлений, тестов по REST resourses.



puts '                                                  MVC'

# MVC(Model, View, Controller) - архитектура/паттерн, разделяющий приложение на 3 части, в каждой из которых высокая связанность, при слабой связанности между самими частями
# Model      - бизнес логика/функционал, упарвление базами данных, возвращает данные
# View       - виды/представления, то что видит пользователь
# Controller - управляющая прослойка между Model и View, осуществляет их взимодействие


# В случае с Рэилс запрос браузера сначало попадает в Rails router(его конфигурация находится в /config/routes.rb), а уже оттуда, в соответсвии с прописанными там машрутами, передается в контроллер, контроллер делает запрос к модели, модель обращается в БД, передает данные в виде сущности контроллеру, он передает их в представление, получает html-страницу, сенерированную на базе этого представления и отпрвлет эту html-страницу браузеру

# Controller - выполняет обработку URL запросов от браузера. В зависимости от типа и URL запроса, возвращает браузеру определенный HTML шаблон. Перед открытием шаблона контроллер может связаться с моделью и получить значения из БД, которые будут переданы в шаблон.
# View       - выполняет роль обычного HTML шаблона, который будет показан пользователю в качестве страницы веб сайта. Эти шаблоны вызываются при помощи контроллеров в зависимости от URL адреса запроса.
# Model      - отвечает за функциональную часть в приложении. В моделях происходит связь с базой данных, работа с API итд. Получив какие-либо значения из базы данных их можно передать обратно в контроллер и далее они будут переданы во view.

# Зачем вообще нужно разеление на слои M, V и C, а не например распихать все по отдельным сервисам? Чтобы код был более поддерживаемым и понятным?



puts '                                     Модели и миграции(ActiveRecord)'

# Миграции - это руби код, с помощью которого описывается, какие таблицы в БД нужно создать, модифицировать итд. Миграции располагаются по меткам времени(в названии 20230701043625_cr...), те можно четко отследить что и в какой последовательности делали. Когда наш проект переносится на другой носитель, то мы можем при помощи одной команды применить все миграции и таким образом наша БД оказывается сразу в нужном нам состоянии, со всеми нужными таблицами, связями итд

# config/database.yml  -  в этом фаиле содержится инфа о том какие БД присутствуют в проекте

# По умолчанию Rails настроен на работу с СУБД sqlite3

# Создание БД через командную строку(в Rails 7 уже есть по умолчанию development.sqlite3 и создаст только test.sqlite3):
# > rails db:create RAILS_ENV=development       -  для Виндоус
# > RAILS_ENV=development rails db:create       -  для *никс
# Если используется другая СУБД например PostgreSQL, перед выполнением команды она должна быть запущена

# Модели в Рэилс, хранятся в отдельных фаилах в каталоге app/models/

# Модели можно создавать при помощи генератора или вручную

# Примечание. Почти всегда таблица это множественное число от модели, но иногда Рэилс делает нестандартно, например для модели Person создаст таблицу people, а не persons
# В книге "Rails. Гибкая разработка веб-приложений" (Руби, Томас, Хэнссон) можно прочитать про соглашения об именах.



puts '                                      Генерация модели и миграции'

# 1. Создание модели и миграции при помощи команды:
# > rails g model Article title:string text:text
# model                  - генератор модели и миграции;
# Article                - название модели(тот класс что отвечает за сущности, те в единственном числе);
# title:string text:text - свойства класса модели, те столбцы таблицы и типы данных для них(при генерации модели :string не обязателен тк этот тип данных будет и по умолчанию);
# После запуска команды при помощи active record будет автоматически созданы и описаны в выводе:
# а. app/models/article.rb  -  фаил модели
class Article < ApplicationRecord # Название в единственном числе
  # Модели наследуются от главной модели ApplicationRecord, а она от ActiveRecord::Base (для методов AR ?) содержит has_many, validates итд
end
# б. db/migrate/20230701043625_create_articles.rb (articles - множественное число) - миграция(с уже заполненным методом change)
class CreateArticles < ActiveRecord::Migration[7.0]
  def change
    create_table :articles do |t|  # таблица создается в той БД, которая указана в конфигурации config/database.yml
      t.string :title
      t.text :text

      t.timestamps                 # добавлено автоматически без необходимости указания в команде генерации модели
    end
  end
end
# в. юнит тесты.

# 2. далее выполняем миграцию при помощи команды, которая создаст таблицу в БД и саму БД(если она еще не создана).
# Можно использовать или rake или rails как алиасы:
# > rake db:migrate
# > rails db:migrate

# 3. Отмена миграций, если сделали что-то не так
# > rails db:rollback         - отменит все сделанные миграции(именно выполнение, те удалятся из схемы, но фаилы миграций останутся, делает дроп тайбл, тоесть данные теряются)
# > rails db:rollback STEP=1  - отменит столько последних миграций какой указан параметр после STEP=



puts '                                     Rails console(работа с моделями)'

# Консоль Рэилс - можно писать в ней любой рубикод

# > rails console  -  вход в консоль
# > rails c        -  вход в консоль
# exit             -  выход

# Примеры работы:
Contact.attribute_names #=> ["id", "email", "message", "created_at", "updated_at"] # узнать какие свойства(поля) у сущности
Contact.all             #=> SELECT "contacts".* FROM "contacts"  => []
Article.find(6)         #=> SELECT "articles".* FROM "articles" WHERE "articles"."id" = ? LIMIT ?  [["id", 6], ["LIMIT", 1]]
Comment.last



puts '                                              Контроллеры'

# https://rusrails.ru/action-controller-overview

# Controller - это специальный класс (?или объект этого класса?), который часто взамодействует с какой-либо моделью, он находится в своем фаиле и отвечает за обработку запросов с пришедших с какого-то URL адреса и возврат представлений браузеру.

# Экшен - это метод в классе-контроллере, отвечающий за определенный обработчик(get, post итд) какого-либо URL

# Все контроллеры наследуются от ApplicationController, а ApplicationController наследуется от ActionController::Base
ApplicationController  # /app/controllers/application_controller.rb Не имеет своего маршрута. Методы и другие параметры из него унаследуют все наши контроллеры, поэтому подходит для добавления общего для всех контроллеров функционала
ActionController::Base # (для встроенных методов Рзэилс ?) содержит методы params, respond_to итд

# Контроллер(а так же маршруты, экшены, виды итд для него) можно полностью создать вручную, а можно при помощи специальных команд в терминале.

# Название фаила контроллера somename_controller.rb где somename обычно в множественном числе, например pages



puts '                                         Генерация контроллера'

# Команда создания контроллера:
# > rails generate controller home index
# controller     - генератор контроллера, говорит о том что мы будем создавать контроллер;
# home           - название контроллера;
# index          - action(название метода/действия), можно задать несколько.

# В итоге было сгенерировано(В отладочной инфе пишет все что добавилось):
# 1. app/controllers/home_controller.rb - фаил в котором находится код контроллера:
class HomeController < ApplicationController # контроллер это класс наследующий от главного контроллера
  def index # экшен/действие это метод в этом классе(отвечающий за обработку URL-запросов)
    # по умолчанию обрабатывает GET 'home/index'
    # по умолчанию рэндерит представление с именем экшена из поддиректории с именем контроллера, тоесть тут это будет views/home/index.html.erb
  end
end
# 2. маршрут home/index в config/routes.rb
# 3. поддиректорию home и фаил index.html.erb в ней(app/views/home/index.html.erb)
# 4. тесты и хэлперы



puts '                                Пошаговое создание контроллера(resourses)'

# Сделаем контроллер для работы с сущностями модели Article пошагово

# 1. http://localhost:3000/articles/new - выпадет ошибка Routing Error. Это происходит потому что у нас нет контроллера articles и соотв такого маршрута. Создадим контроллер(без указания экшенов):
# > rails g controller articles  (можно не использовать генератор вообще и создать вручную и фаил и сам класс)
# app/controllers/articles_controller.rb
class ArticlesController < ApplicationController
  # Создался пустым, тк мы не задавали 2й параметр(new)
end

# 2. http://localhost:3000/articles/new - выпадет ошибка Unknown action The action 'new' could not be found for ArticlesController. Тк как у нас не было метода экшена в классе контроллера, далее добавим его вручную:
class ArticlesController < ApplicationController
  def new
  end
end



puts '                                         Маршруты(routes.rb)'

# http://rusrails.ru/rails-routing             -  Rusrails: Роутинг в Rails
# https://guides.rubyonrails.org/routing.html

# Маршрут - это то что пишется в адресной строке браузера

# config/routes.rb - тут мы прописываем и изменяем маршруты, которые будут использоваться в нашем приложении. Когда приходит запрос с методом и маршрутом, то Рэилс смотрит в routes.rb, в какой контроллер и экшен его передавать для обработки

# /config/routes.rb - пропишем маршруты, те закрепим обработчики URLов за определенными экшенами определенных контроллеров:
Rails.application.routes.draw do
  # 1. Создадим корневой маршрут: home#index обычно создаётся для главной страницы, поэтому можно поменять 'home/index'(создан контроллером по умочанию) на корневой маршрут:
  get '/' => 'home#index'  # определяем маршрут вручную(хардкод). Теперь экшен index контроллера home будет обрабатывать GET-запросы, которые придут с URL-адреса '/'

  # 2. Создадим resources маршруты по паттерну REST которые будут обрабатываться контроллером ArticlesController, для работы с моделью Article:
  resources :articles
end
# Примечание: если мы прописываем несколько маршрутов URL для одного и тогоже экшена и контроллера, то он будет обрабатывать все эти маршруты


# > rails routes  -  (До версии Rails 6.1 - rake routes) эта команда из каталога конфигурации берёт файл config/routes.rb исполняет его и выводит нам список маршрутов - URLы, типы запросов и к каким представлениям они ведут.
# Так же можно смотреть маршруты в браузере введя несуществующий URL от нашего корня, либо перейти по адресу /rails/info/routes



puts '                           Контроллер и роутинг статических страниц(не по REST)'

# Статические страницы это те, которые не изменяются динамически, те не содержат динамической информации и всегда отображаются одинаково ?? не принимают переменные из экшенов ??. Подходит например для страниц "О нас", "Контакты" итд

# Удобно создать отдельный контроллер для статических страниц
# > rails g controller pages

# Создаётся контроллер /app/controllers/pages_controller.rb, добавим экшены:
class PagesController < ApplicationController
  def terms
  end

  def about
  end
end

# Пропишем маршруты(тк удобнее получать их от корня, а не от /pages) в /config/routes.rb:
Rails.application.routes.draw do
  get 'terms' => 'pages#terms'
  get 'about' => 'pages#about', as: 'about'
  # as: 'about' - для статических тоже можно создать хэлперы юрлов, тут about_path
end

# Создадим представления /app/views/pages/terms.html.erb и /app/views/pages/about.html.erb



puts '                      Полный цикл создания контроллера, маршрутов, модели, видов(resourse)'

# Сделаем страницу /contacts с формой для контактов. Чтобы на сервер и далее в БД передавались email и message из формы контактов.

# 1. > rails g controller contacts  -  Создаем новый контроллер без экшенов
# Создалось: app/controllers/contacts_controller.rb и app/views/contacts
class ContactsController < ApplicationController
  # Добавим в ContactsController экшены
  def new    # получение страницы(форма с текстовыми полями) от сервера  - get (new по REST)
  end
  def create # отправка и обработка данных введенных пользователем на сервер - post (create по REST)
  end
end

# 2. Прописываем маршруты. Внесём изменения в файл /config/routes.rb
Rails.application.routes.draw do
  resource :contacts, only: [:new, :create] # resource(единственное число).

  # Но так при GET-запросе на URL /contacts выпадет Routing Error. No route matches [GET] "/contacts", потому что у этого маршрута есть только POST-обработчик(create). Переназначим маршрут GET '/contacts', чтобы он обрабатывался в экшене new, соотв возвращался вид new.html.erb с формой.(У resource по этому запросу по умолчнию show.)

  # Способ 1(хардкод):
  get 'contacts' => 'contacts#new'    # добавим обработку запроса get 'contacts' в экшен new
  resource :contacts, only: [:create] # удаляем :new из [:new, :create], те удалим обработчик get 'contacts/new ' из экшена new
  # (Чтобы пользователь получал вид и при GET запросе и на /contacts/new и на /contacts то изменим последнюю строку на resource :contacts, only: [:new, :create], те обратоно добавим :new в маршрут)

  # Способ 2(Лучше тк меняет имя хэлпера и не будет ошибок, например с приемочными тестами):
  resource :contacts, only: [:new, :create], path_names: { :new => '' } # Перенаправление идет по базовому пути { :new => '' } (По умолчанию был {:new => '/new'} ). А базовый путь для контроллера contacts это как раз /contacts
end

# 3. Создаем модель и миграцию и запускаем миграцию.
# > rails g model Contact email:string message:text
# AR создал миграцию: db/migrate/20230704072035_create_contacts.rb
class CreateContacts < ActiveRecord::Migration[7.0]
  def change
    create_table :contacts do |t|
      t.string :email
      t.text :message

      t.timestamps
    end
  end
end
# AR создал модель: app/models/contact.rb
class Contact < ApplicationRecord
end
# rake db:migrate  -  запускаем миграцию и создаем таблицу в БД

# 4. Создадим представление contacts/new.html.erb и заполняем(формой)
# Добавим предствление /app/views/contacts/create.html.erb















#
