puts '                                  Колбэки для экшенов контроллера'

# https://rusrails.ru/action-controller-overview#kolbeki-ekshna

# Колбэки экшена - это методы, которые запускаются "до", "после" или "до и после" экшна контроллера. Нужен, например чтобы запускать повтопяющийся в нескольких экшенах код

# Метод-коллбек, запускаемый при помощи ..._action, так же называется фильтр.

# (До Rails 5 у before_action был алиас before_filter, как и многие другие action-свойства включавшие в имени filter)

# Колбэки экшна наследуются, поэтому, если добавить их в ApplicationController, они будет запускаться в каждом контроллере.



puts '                                           before_action'

# before_action  -  метод, который регистрирует "before"-колбэки экшена, он принимает в параметры имя метода в виде символа и исполняет этот метод, перед тем как запускается каждый экшен контроллера, соответсвенно иснициализированные в методе фильтра переменные экземпляра будут доступны в этом экшене. В качестве дополнительного параметра может принимать опции с указанием на экшены, перед которым коллбек будет выполнен, по умолчанию выполняется перед любым (всеми) экшенами

# Колбэки экшна "before" могут прерывать цикл запроса. Если колбэк экшна "before" рендерит какой-то шаблон или перенаправляет, экшен контроллера не запустится. Если есть дополнительные колбэки экшна в очереди, они также будут отменены.


# В экшенах контроллера Questions, есть повторяющийся код, пропишем его в отдельном методе set_question! и будем запускать при помощи before_action
class QuestionsController < ApplicationController
  before_action :set_question!, only: %i[show edit update destroy]
  # set_question!             - имя метода(фильтра) который будет запускаться перед экшеном
  # only: %i[destroy update]  - экшены перед которыми будет запускаться метод set_question! Если не указывать данный параметр, то будет исполняться перед всеми/каждым экшеном

  # Можно использовать несколько фильтров в одном контроллере:
  before_action :some1, except: %i[destroy update]
  # except: %i[destroy update]  - параметр означающий 'кроме', те кроме указынных экшенов(обратный смысл к only)
  before_action :some2, only: :update
  # only: :update               - можно указать и без массива, если только 1 экшен

  # Если мы используем несколько фильтров то их порядок важен в том случае, если данные из методов одних фильтров взаимодействуют с другими, например предыдущий создает объекты, которые использует следующий фильтр

  # Вызов одного и того же колбэка экшна несколько раз с разными опциями не будет работать, поскольку последнее определение колбэка экшна перезапишет предыдущие.

  # Все записи внутри экшенов ниже равноценны, перед(в) каждым исполняется метод set_question! определяющий переменную экземпляра, которая теперь доступна в экшене
  def show
    @question = Question.find params[:id]  # тоже самое будет сделано ниже
  end
  def edit
    set_question! # before_action :set_question! работает так же, тоесть это оналог простого помещения оператора метода в его тело
  end
  def update
    # @question = Question.find params[:id]  -  вызваается при помощи before_action :set_question!
  end
  def destroy
    # @question = Question.find params[:id]  -  вызваается при помощи before_action :set_question!
  end

  private

  def set_question! # метод-фильтр, который будет запускаться при помощи before_action. Именуем с восклицательным знаком, тк он может вернуть ошибку, если не существует такой вопрос
    @question = Question.find params[:id] # find для этой цели лучше чем find_by, тк если пользователь введет адрес несуществующего вопроса, например /questions/266666, то сразу возникнет ошибка ActiveRecord::RecordNotFound в контроллере(в этом методе), а не потом в виде, соответственно проще будет потом эту ошибку обработать
    # когда метод сработает то переменная @question будет объявлена, получит значение и будет доступна в экшенах
  end
end



puts '                                             after_action'

# Колбэки экшна after - запускаются после того, как экшен контроллера был выполнен

# Колбэки экшна "after" регистрируются с помощью after_action. Они похожи на колбэки экшна "before", но поскольку экшен контроллера уже был запущен, у них есть доступ к данным отклика, которые будут отосланы клиенту.

# Колбэки экшна "after" не могут остановить экшн от запуска.

# Колбэки экшна "after" выполняются только после успешного выполнения экшна контроллера, но не при возникновении исключения в цикле запроса.



puts '                                             around_action'

# Колбэки экшна around - запускаются и до, и после того, как экшен контроллера был выполнен. ?? Экшен контроллера запускается внутри метода колбека в точке yield ??

# Колбэки экшна "around" регистрируются с помощью around_action. Они ответственны за запуск связанных с ними экшнов с помощью yield, подобно тому, как работают промежуточные программы Rack.

# Например, на веб-сайте, где для изменений есть процедура утверждения информации, администратор может легко их просмотреть, применив их внутри транзакции:
class ChangesController < ApplicationController
  around_action :wrap_in_transaction, only: :show

  private

  def wrap_in_transaction
    ActiveRecord::Base.transaction do
      begin
        yield # тут запускается экшен контроллера ??
      ensure
        raise ActiveRecord::Rollback
      end
    end
  end
end
# Колбэки экшна "around" также оборачивают рендеринг. В частности, в вышеуказанном примере, если вьюха сама начнет считывать из базы данных (например через скоуп), она это осуществит внутри транзакции, предоставив, таким образом, данные для предварительного просмотра.
# Можно не вызывать yield и создать отклик самостоятельно, в этом случае экшн контроллера не будет запущен



puts '                                          skip_before_action'

# skip_before_action - метод, который отменяет действие какого-то фильтра, для всех или определенных экшенов данного контроллера, соответсвенно принимает имя фильтра и имена экшенов, для которых нужно деактивировать этот фильтр. По умолчанию деактивирует фильтр для всех экшенов. Полезен например для отмены унаследованного колбека


# "before"-колбэк, чтобы чтобы отфильтровать авторизованных пользователей для запуска экшна.
class ApplicationController < ActionController::Base
  before_action :require_login

  private

  def require_login # записывает сообщение об ошибке во flash и перенаправляет на авторизацию, если пользователь не авторизовался.
    unless logged_in?
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url # halts request cycle
    end
  end
end

# Колбэк добавлен в ApplicationController, и все контроллеры наследуют его и применяют ко всем экшенам. Так неавторизированный пользователь не сможет зарегистрироваться. Деактивируем запуск этого фильтра перед определенными экшнами с помощью skip_before_action:
class LoginsController < ApplicationController
  skip_before_action :require_login, only: [:new, :create]
  # :require_login        - фильр который будет деактивирован
  # only: [:new, :create] - экшены для которых фильр будет деактивирован

  # ...
end
# Теперь, экшны new и create контроллера LoginsController будут работать без требования к пользователю быть зарегистрированным



puts '                              Другие способы использования колбэков экшна'

# Хотя наиболее распространенный способ использование колбэков экшна - это создание private методов и использование before_action, after_action или around_action для их добавления, есть два других способа делать то же самое:


# 1. Передавать блок прямо в методы *_action. Блок получает контроллер как аргумент. Колбэк экшна require_login может быть переписан с использованием блока:
class ApplicationController < ActionController::Base
  before_action do |controller|
    unless controller.send(:logged_in?)
      # Колбэк экшна в этом случае использует метод send, так как logged_in? является private, и колбэк экшна не запустится в области видимости контроллера. Это не рекомендуемый способ применения такого особого колбэка экшна, но в простых задачах он может быть полезен.
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url
    end
  end

  # В частности, для around_action в блок также вкладывается action:
  around_action { |_controller, action| time(&action) }
end


# 2. Использовать класс для управления колбэком экшна. Это полезно для задач, которые сложно осуществить предыдущими способами из-за трудности читаемости и/или повторного использования.

# Класс должен реализовывать метод с тем же именем, что и колбэк экшна, поэтому для колбэка экшна before_action класс должен реализовать метод before, итд. Метод around должен иметь yield для выполнения экшна.

# Например тот же фильтр авторизации, но использовав класс:
class ApplicationController < ActionController::Base
  before_action LoginActionCallback
end

class LoginActionCallback
  def self.before(controller)
    unless controller.send(:logged_in?)
      controller.flash[:error] = "You must be logged in to access this section"
      controller.redirect_to controller.new_login_url
    end
  end
end














#
