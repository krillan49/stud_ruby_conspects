puts '                                   Авторизация при помощи гема Pundit'

# Аутентификация - проверка пользователя и пароля. Это процесс когда мы понимаем кто вошел в систему, пользователь предоставляет свои учетные данные, например логин и пароль или смарткарта или специальный токен от соцсети если вход через соцсеть, мы проверяем их, после чего по этим данным устанавливаем кто вошел в приложение

# Авторизация - наделение определёнными правами в зависимости от роли(юзер, админ итд). Это процесс когда мы проверяем может ли данный пользователь выполнять то или иное действие (например создать или удалить запись)

# Систему авторизации можно написать свою или воспользоваться готовым решением:
# https://github.com/varvet/pundit              -  наиболее простое и понятное решение
# https://github.com/CanCanCommunity/cancancan  -  решение с некоторым колличеством магии
# https://github.com/palkan/action_policy       -  как pundit на стероидах


# В данном случае (AskIt) воспользуемся Pundit, тк это самое простое и минималистичное решение. Оно позволит с помощью обычных классов Руби описывать то, что могут делать пользователи в зависимости, например от их роли
# https://www.rubydoc.info/gems/pundit
# https://github.com/varvet/pundit

# 1. Установим гем
# > bundle add pundit
# либо
gem 'pundit', '~> 2.3'
# > bundle i

# 2. Подключим автори зацию Pundit в application_controller.rb:
class ApplicationController < ActionController::Base
  include Pundit::Authorization
  # ...
end
# Но лучше создадим новый консерн authorization.rb (код в нем) и добавим туда, а в application_controller.rb подключим консерн
class ApplicationController < ActionController::Base
  include Authorization
  # ...
end

# 3. Запустим генератор pundit, который создаст базовый класс(базовую политику).
# pundit оперирует таким понятием как политика, которая является классом в отдельном фаиле, который описывает что пользователь может делать с экшенами контроллера, отвечающего за определенный ресурс(вопросы, ответы, юзеров итд)
# > rails g pundit:install
# app/policies/application_policy.rb - создалась директория для политик и главная политика (код там)



puts '                                    Политика для ресурса вопросов'

# app/policies/question_policy.rb - создадим новую политику для вопросов (политика как в названии фаила так и класса именуется в единственном числе) и переопределим в ней некоторые методы доступа к экшенам контроллера вопросов
class QuestionPolicy < ApplicationPolicy # тк мы наследуем у главной политики, то получаем оттуда все содержимое и остается только переопределить те методы что мы хотим изменить
  def index?
    true # просматривать все вопросы могут все посетители
  end

  def show?
    true # просматривать конкретные вопросы могут все гости
  end
end


# Модифицируем наш questions_controller.rb, чтобы можно было применить к нему политику question_policy.rb
class QuestionsController < ApplicationController
  include QuestionsAnswers
  before_action :require_authentication, except: %i[show index] # добавим проверку, что пользователь вошел в систему для всех контроллеров кроме просмотра(тк без этого мы не сможем проверить его права доступа)
  before_action :set_question!, only: %i[show destroy edit update]
  before_action :authorize_question! # собственно наш метод проверки доступа для экшенов контроллера через question_policy.rb
  after_action :verify_authorized    # на всякий случай вызовем метод(pundit) дополнительной проверки того, что мы в экшене или бефор_экшене сделали авторизацию, те проверили права доступа, если же права доступа проверены не были то вылезет ошибка

  # ...
  private
  # ...

  def authorize_question!
    authorize(@question || Question)
    # authorize - метод pundit, он создает экземпляр класса политики (тут QuestionPolicy), чтобы проверять имеет ли пользователь права на действия с соответсвующими экшенами контроллеров, относящимися к данной модели.
    # По умолчанию для того чтобы передать параметр user в initialize используется метод с названием current_user (можно при желании прописать, чтоб вызывался другой)
    # @question || Question - параметр передаваемый в record в initialize. Либо конкретный вопрос, если он есть(:set_question!), либо модель, если в каком-то экшене нет переменной с вопросом
  end
end


# Для примера в question_policy.rb в метод create? поставим false
def create?
  false
end
# Теперь при переходе на get 'questions/new' вылезет ошибка Pundit::NotAuthorizedError in QuestionsController#new, тк мы хотели использовать экшен new
# Тоесть метод authorize_question! вызвал authorize(@question || Question), а он посмотрел для экшена new в question_policy.rb метод new? а тот соответсвенно вызвал метод create?, в котором мы прописали false
# Обработаем данную ошибку, чтобы вместо нее было просто сообщение для пользователя и редирект, для этого в консерне authorization.rb используем обработчик ошибок rescue_from и для спасения ошибки свой метод обработки user_not_authorized


# question_policy.rb - разрешим некоторые экшены некоторым пользователям
class QuestionPolicy < ApplicationPolicy
  # ...

  def create?
    user.present? # тоесть если юзер существует(аутонтифицирован, тк проверяет по current_user), то он может создать вопрос
    # user - берется из attr_reader application_policy.rb от которого тут наследуем
  end

  def update?
    user.admin_role? || user.moderator_role? || user.author?(record) # тоесть редактировать могут админы, модеры и авторы вопросов
    # record - переменная из attr_reader с конкретным вопросом(тк пытаемся редактировать конкретный вопрос)
    # author? - наш кастомный метод, который добавим в модель(ниже), определяющий что юзер пытающийся редактировать это автор этого вопроса
  end

  def destroy?
    user.admin_role? || user.author?(record) # тоесть удалить может либо админ либо автор
  end
end

# user.rb - добавим метод author? в модель
class User < ApplicationRecord
  # ...

  # Метод(сделаем универсальным для вопросов, ответов и комментов) проверяет является ли юзер, что хочет произвечти действие(например редактировать) с объектом автором этого объекта(вопроса, ответа или коммента)
  def author?(obj)
    obj.user == self # проверяем юзер которому принадлежит объект это тот же юзер что вызывает метод author? или нет
  end
end

# Так же сделаем метод обратный методу author?, который будет проверять, написан ли данный вопрос ответ или коммент переданным через параметр юзером. Для этого создадим отдельный консерн в моделях models/concerns/authorship.rb (код там), и подключим этот консерн во все соответсвующие модели
include Authorship # подключим в модели Question, Answer, Comment



puts '                                            Гостевой юзер'

# Если мы будем заходить на метод update с незарегистритованного пользователя, то возникнет ошибка undefined method `admin_role?' for nil:NilClass, тк метод admin_role? вызывается от user, но у незарегистрированного гостя он имеет значение nil, тк current_user вернет nil, соотв от nil и вызывается метод admin_role?
# Можно конечно использовать &, но тогда это придется дублировать в куче мест, потому лучше внедрить концепцию гостевого пользователя


# services/guest_user.rb (полный код есть и в нем) - создадим новый сервисный объект
# Так же добавим экземпляр гостевого юзера в initialize в application_policy.rb, чтобы собственно был объект в переменной user от которой вызываем методы
class GuestUser
  def guest? # создадим в нем метод, который можно вызвать от user и определяющий гостся как true
    true
  end

  # Гостевой юзер должен уметь отвечать на все методы юзера(методы ролей, метод author? итд) тоесть эти методы тут нужно прописать:

  def author?(_) # параметр объекта не важен тк гость все равно ничему не автор
    false
  end

  # Так как ролей может быть много удобнее использовать method_missing, чем отдельные методы для каждой роли
  def method_missing(name, *args, &block)
    # *args  - параметры, чтобы проверить, например авторстсво записи или коллекции записей
    # &block - мб будут какие-то методы, что принимают блоки
    return false if name.to_s.end_with?('_role?') # тоесть если название метода оканчивается на '_role?' то это гость
    super(name, *args, &block) # в остальных случаях отправляем метод "выше по икрархии" (?? в ApplicationService или ApplicationPolicy ??)
  end

  # ?? respond_to_missing? ??
  def respond_to_missing?(name, include_private)
    return true if name.to_s.end_with?('_role?') # Образец нашего класса отвечает на методы, которые кончаются на '_role?'
    super(name, include_private)
  end
end

# В модели user.rb создадим точно такой же метод guest? только со значением false
class User < ApplicationRecord
  def guest?
    false
  end
end

# Теперь мы можем изменить политику вопросов question_policy.rb с использованием гостевого объекта для create?
def create?
  !user.guest? # теперь можем писать и так вместо user.present?. Тоесть пользователи могут создавать вопросы если они не гости
end



puts '                     Сокрытие элементов в представлениях, в зависимости от доступа'

# Это сокрытиие чисто косметический момент для того чтоб пользователь не переходил по ссылкам, которые изза отказа в доступе приведут к редиректам, тк политика все равно закроет доступ к экшенам

# Синтаксис сокрытия элементов в представлении:
if policy(obj).edit? # тоесть если политика для данной сущьности данного экшена, для данного юзера вернет true
  # ... какойто элемент разметки
end
# просто обрамляем элемент в условный оператор с этой проверкой, которая проверяет в соотв политике (тут для вопросов) соответсвующий метод (тут edit?) и показывает или скрывает элемент в зависимости от того true или false
# edit? - например для кнопки редактирования, destroy? - для кнопки удаления итд
# obj - может быть как объектом сущьности, так и обозначением класса сущьности, например :question

# Для представлений questions/ :
# _question.html.erb и show.html.erb - скроем кнопки редактирования и удаления пользователям которым не разрешены эти функции
# index.html.erb - скроем кнопку нового вопроса



puts '                   Политики для ответов и комментов. Проверка в экшенах без доп метода'

# Политика для ответов:
# policies/answer_policy.rb - (код там) создадим политику для ответов, код будет точно таким же как и был для вопросв
# answers_controller.rb     - (код там) добавим так же как и для вопросов фильтры и метод проверки доступа authorize_answer!
# answers/_answer.html.erb  - скроем кнопки ответов


# Политика для комментариев:
# policies/comment_policy.rb - (код там) создадим политику для комментариев, код будет точно таким же как для вопросв и ответов
# comments_controller.rb     - сделаем авторизацию прямо в экшенах, без фильтра и отельного метода authorize_comment!, тк в контроллере всего 2 экшена
class CommentsController < ApplicationController
  # ...
  after_action :verify_authorized

  def create
    @comment = @commentable.comments.build comment_params
    authorize @comment # создаем экземпляр политики и проверяем роль прямо тут, до создания комментария естественно
    # ...
  end

  def destroy
    comment = @commentable.comments.find params[:id]
    authorize comment # создаем экземпляр политики и проверяем роль прямо тут, до удаления комментария естественно
    # ...
  end
  # ...
end
# comments/_commentable.html.erb - скроем тело формы для тех кому недоступно создание комментов
# comments/_comment.html.erb     - скроем кнопку удаления коммента



puts '                                    Политики для юзеров и админ/юзеров'

# 1. Политика для юзеров:

# policies/user_policy.rb - создадим политику для юзеров
class UserPolicy < ApplicationPolicy
  def index?
    false # никто, тк у админа свой контроллер, а обычному юзеру статка других незачем
  end

  def create?
    user.guest? # зарегистрироваться(создать пользователя) может только гость, те еще не вошедший в систему
  end

  def show? # чисто на будущее, тк такого экшена нет
    true # чужие профили можно дать смотреть кому угодно
  end

  def update?
    record == user # тк в случае контроллера UsersController record это и есть юзер, тоесть обновлять межет только юзер сам себя
    # Тут не прописываем админа, тк у него отдельный контроллер в нэймспэйсе
  end

  def destroy?
    false # никто, тк у админа свой контроллер, хотя можно и разрешить пользователю удалять свою учетную запись
  end
end

# В users_controller.rb добавим фильтр и метод проверки прав
class UsersController < ApplicationController
  # ...
  before_action :authorize_user!
  after_action :verify_authorized

  # ...

  def authorize_user!
    authorize(@user || User)
  end
end


# 2. Политика для админ-юзеров(тк есть одельный нэймспейс админов):

# policies/admin/user_policy.rb - создадим нэймспэйс и политику для админского контроллера юзеров
module Admin # естественно в модуле
  class UserPolicy < ApplicationPolicy
    # Везде разрешаем доступ к любым экшенам только админу
    def index?
      user.admin_role?
    end
    def create?
      user.admin_role?
    end
    def show?
      user.admin_role?
    end
    def update?
      user.admin_role?
    end
    def destroy?
      user.admin_role?
    end
  end
end

# Для удобства применения политики в controllers/admin создадим базовый контроллер base_controller.rb от которого будут наследовать все остальные админские контроллеры (и юзеров и какие угодно еще)
module Admin
  class BaseController < ApplicationController # наследует у главного контроллера
    # переопределим для всех админских контроллеров метод Pundit-а authorize
    def authorize(record, query = nil)
    # query - у нас этого параметра не будет, так что пофиг что он делает(?? хотя мб это куда добавляется current_user ??)
      super([:admin, record], query) # добавляем родительскому методу :admin, тоесть так мы указываем пространство имен, где лежит в политиках наша политика(? или контроллер ?), будет добавлять его во все проверки по умолчанию, чтобы не писать везде authorize([:admin, user])
    end
  end
end

# В admin/users_controller.rb добавим фильтр и метод проверки прав
module Admin
  class UsersController < BaseController # теперь наследует от админского базового контроллера
    # ...
    before_action :authorize_user!
    after_action :verify_authorized

    # ...

    def authorize_user!
      authorize(@user || User) # теперь метод будет модифицированный из базового адмиского контроллера, те он будет по умодчанию добавлять :admin и без этого прилось бы писать authorize([:admin, (@user || User)])
    end
  end
end

# shared/_menu.html.erb - добавим пункт просмотра всех юзеров в главное меню, с доступом только для админа



puts '                                           TODO'

# Можно дальше все это усложнять например:
# 1. Внедрить для пользователей состояние "забанен", не обязательно роль. И соотв модифицировать политику например комментов, чтобы забаненый не мог комментировать
# 2. Новые роли, например подмодер, который модеррит только комменты

# Так же Пандит умеет работать(есть в доках) со:
# 1. Скоупами (записываются прямо в конкретной политике) - они позволяют выдавать список записей из БД в зависимости от роли, например админам все, а комуто только определенные(WHERE)
# 2. Так же можно выдавать разные разрешенны_атрибуты(из форм) в зависимости от роли пользователя
# 3. Внизу доков так же есть инфа как тестировать, как работать с Девайс, как переходить с КанКанКан итд















#
