puts '                          Импорт/экспорт Excel, архивы ZIP. Сервисные объекты'

# (На примере AskIt) Создадим функционал, который позволит администратору сайта выгружать(скачивать) информацию о пользователях в формате Excel, разбитую по отдельным Excel фаилам для каждого пользователя и чтобы все эти фаилы вместе помещались в один архив ZIP, чтобы можно было скачать этот архив и работать с фаилами в нем. А так же администратор сможет добавлять новых пользователей в БД загрузив через форму Excel фаил

# Будем использовать Excel-фаилы с расширением xlsx, тк с ними работать намного проще чем с фаилами с расширениями xls



puts '                          Обработка запросов разных форматов на примере zip'

# /admin/users(.:format)  - format в маршруте обозначает что мы можем запрашивать данные с этого маршрута в разном формате, по умолчинию запрашиваются данные в формате html, поэтому в ответ на запрос из представления генерируется html-страница. Но с такого маршрута можно запросить данные в любом другом формате, если наше приложение может на этот формат отвечать(тоесть есть под него функционал в контроллере и представление соответсвующего формата)


# 1. Добавим в Gemfile гем который позволяет работать с архивами zip
gem 'rubyzip', '~> 2' # https://github.com/rubyzip/rubyzip
# > bundle i


# 2. Добавим в admin/users/index.html.erb новую ссылку-кнопку которая будет посыласть запрос в формате zip, чтобы выгружать для пользователя zip архив


# 3. Научим наше приложение правильно отвечать на разные запрошенные форматы (тут zip). Для этого дополним контроллер controllers/admin/useres_controller.rb:
module Admin
  class UsersController < ApplicationController
    def index
      respond_to do |format|
        # respond_to метод принимающий в параметр блока все форматы на которые мы хотим отвечать
        # format - объект к которому мы применим метод формата и правила по которым будем его обрабатывать

        format.html do # формат html, пишем в блоке тоже что писали в контроллере по умолчанию, тк это формат по умолчанию
          @pagy, @users = pagy User.order(created_at: :desc)
          # так же как и всегда по умолчанию рендерит admin/users/index.html.erb
        end

        format.zip { respond_with_zipped_users } # формат zip, опишем для удобства его обработку в отдельном методе ниже
      end
    end

    private

    def respond_with_zipped_users # в консерн можно не переносить, тк использовать будем только тут
      # Сгенерируем zip-фаил в котором будут находиться фаилы Excel:
      compressed_filestream = Zip::OutputStream.write_buffer do |zos|
        # OutputStream - специальный объект, который является временным архивом (нигде у нас на диске храниться не будет), который мы будем пересылать пользователю(админу), в ответ на его запрос.
        User.order(created_at: :desc).each do |user| # создадим отдельный Excel фаил для каждого пользователя из этого запроса
          zos.put_next_entry "user_#{user.id}.xlsx" # указываем имя фаила (с расширением xlsx) для след записи
          zos.print render_to_string(
            # print - метод который записывает фаил (тут сгенерированный в render_to_string) в архив
            # render_to_string - метод который генерирует Excel-фаил, данный рендер будет происходить просто в памяти и создавать некую строку
            layout: false, handlers: [:axlsx], formats: [:xlsx], template: 'admin/users/user', locals: { user: user }
            # layout: false - тк никакой лэйаут нам не нужен, а только голый фаил Excel
            # handlers: [:axlsx] - обработчик шаблона который мы будем использовать (как erb в some.html.erb)
            # formats: [:xlsx] - формат самого фаила (как html в some.html.erb)
            # template: 'admin/users/user' - шаблон/представление который мы хотим рендерить (user.xlsx.axlsx) для генерации данного Excel-фаила
            # locals: { user: user } - локальная переменная которую передаем в шаблон/вид, которая содержит объект юзера из праметра user запроса User.order...
          )
        end
      end
      compressed_filestream.rewind # нужно "перемотать" созданный фаил архива, тк во время записи "индексы" сместились в конец фаила (какаято непонятная фигня)
      send_data compressed_filestream.read, filename: 'users.zip'
      # send_data - стандартный метод Рэилс, который пересылает фаилы пользователю
      # compressed_filestream.read - параметр метода send_data - фаил архива который передаем с методом read(читать)
      # filename: 'users.zip' - имя передаваемого фаила архива
    end
  end
end


puts
puts '                     Способ создания xlsx фаилов. axlsx.xlsx шаблоны и их редактирование'

# https://www.sitepoint.com/generate-excel-spreadsheets-rails-axlsx-gem/  - статья Круковского по работе с Excel в Рэилс

# Excel-фаилы xlsx которые мы генерируем выше в контроллере controllers/admin/useres_controller.rb, лучше всего генерировать при помощи гемов caxlsx и caxlsx_rails. Но эти гемы могут только записывать/создавать новые Excel-фаилы, а читать и парсить не могут
# https://github.com/caxlsx
# https://github.com/caxlsx/caxlsx
# https://github.com/caxlsx/caxlsx_rails
gem 'caxlsx', '~> 4'
gem 'caxlsx_rails', '~> 0.6'  # подгем для правильной работы с представлениями Рэилс
# > bundle i


# Создадим xlsx.axlsx шаблон/представление при помощи которого будем генерировать Excel-фаилы xlsx. Создадим его в той же директории где лежат html-представления vievs/admin/users/user.xlsx.axlsx
# Содержание фаила рассмотрим тут так в самом фаиле нет подсветки:

wb = xlsx_package.workbook # создаем новый рабочий документ Excel

s = wb.styles # создаем стили для визуала ячеек таблицы Excel (не обязательно)
# https://github.com/caxlsx - тут можно посмотреть стили и примеры использования, втч графики
highlight_cell = s.add_style(bg_color: 'EFC376') # создаем новый стиль(имя переменной любое) с цветом фона
right_cell = s.add_style(border: Axlsx::STYLE_THIN_BORDER, alignment: { horizontal: :right }) # создаем стиль сразу с двумя ситлями, гораницей ячеек и выравниваем контента в ячейке по правому краю
date_cell = s.add_style(format_code: 'yyyy-mm-dd') # создаем стиль с форматом даты

wb.add_worksheet(name: 'User') do |sheet| # добавляем (?? в документ Excel) новый лист с именем 'User'
  sheet.add_row ['ID', user.id], style: [nil, highlight_cell]
  # sheet.add_row - добавляет на этом листе новый ряд/колонку таблицы Excel
  # ['ID', user.id] - каждый элемент массива это ячейка в строке таблицы Excel
  # style: [nil, highlight_cell] - применяем стиль. К 1й ячейке(имя колонки) не применяем стили потому nil, а во второй применяем стили созданные за переменной highlight_cell
  # style: highlight_cell - если без массива, тогда стиль применится ко всем ячейкам
  sheet.add_row ['Name', user.name], style: [nil, right_cell]
  sheet.add_row ['Email', user.email], style: [nil, right_cell]
  sheet.add_row ['Created at', user.created_at], style: [nil, date_cell]
  sheet.add_row ['Updated at', user.updated_at], style: [nil, date_cell]
end


puts
puts '                    Загрузка данных из xlsx из архива в БД приложения. Сервисные классы'

# (!!! Тут не записывает в БД, незаархивированный xlsx. Потом если понадобиться можно улучшить, чтоб применял и незазипованный)

# Сделаем так чтобы админ мог загрузить архив с Excel фаилами и внести данные из них в БД, тоесть создать новых юзеров в БД, на основании строк из таблицы Excel. Это хороший вариант наполнения БД админом если нужно ввести в систему сразу множества новых пользователей.

# Нам нужно загрузить фаил zip в приложение, там открыть фаил zip, вытащить из него фаилы Excel, обработать каждый из них и на основе них создать пользователей в БД, так же проделать и валидации.


# 0. гем для считывания xlsx фаилов rubyXL (тк caxlsx только для генерации)
# https://github.com/weshatheleopard/rubyXL
gem 'rubyXL', '~> 3.4'
# > bundle i


# 0. гем для оптимизации запросов при заполнении БД (добавляет множество записей одним запросом)
# https://github.com/zdennis/activerecord-import
gem 'activerecord-import', '~> 1.5'
# > bundle i


# 1. Добавим форму для загрузки фаила(zip архива) в представление admin/users/index.html.erb, чтобы создавать новых юзеров


# 2. Добавим в admin/user_controller.rb экшен create обрабатывающий zip фрхив загруженный админом
module Admin
  class UsersController < ApplicationController
    # ...
    def create
      if params[:archive].present?  # проверяем был ли передан архив в форме
        UserBulkService.call params[:archive] # передаем zip архив переданный из формы на обработку в сервисный класс в метод self.call. Тоесть это как работа с моделью, только с сервисным классом, функционалом другого типа.
        flash[:success] = 'Users imported!'
      end
      # потом при желании можно модифицировать, например если архив не передан, то надо создать только одного пользователя на основе переданных параметров (стандартно). Можно сделать одельную страницу или отдельную форму.
      redirect_to admin_users_path
    end
    # ...
  end
end


# 3. Создадим сервисный класс для обработки архива:
# Сервисный класс нужен для того чтобы отделить дополнительный функционал от контроллера, тоесть это чтото вроде модели но более общее и не для БД
# а) Создадим дирректорию app/services
# б) Создадим базовый/материнский сервисный класс services/application_service.rb от которого будут наследовать другие и напишем в нем функционал
# г) Создадим наш сервисный класс для обаботки архива services/user_bulk_service.rb и напишем в нем методы обработки и записи в БД


# В более сложных случаях (очень сложный и долгтй импорт), все лучше будет делать в фоновом режиме(Актив Джоб), тк синхронное выполнение может подвесить сервер или браузер может сбросить соединение через определенное время















#
