puts '                                   Как работает Реилс приложение'

# 1. Вне(до) Реилс-приложения:
# a) Компьютер (сервер) на котором установлено Рэилс приложение постоянно "слушает" 80й порт(тк это именно тот порт на который по умолчанию приходят http-запросы)
# b) Когда запрос http-приходит тоесть специальный веб-сервер(например nginx) который этот запрос обрабатывавет  использует часть данных запроса, чтобы определить что с ним дальше делать
# c) Если веб-сервер(например nginx) понимает, что этот запрос нужно отдать на обработку в Рэилс-приложение то он сперва отдает его App-серверу(например puma, unicorn, passenger). А уже App-сервер внутри себя запускает Рэилс-приложение(при настройке/деплое на сервер)

# 2. Внутри Реилс-приложения:
# a) Чтобы понять что делать с запросом в Рэилс есть специальный Router, который мы конфигурируем и в соотвествии с этими правилпми роутер выбирает какому контроллеру передать запрос
# b) Далее запрос попадает в соответсвующий экшен контроллера, который взаимобдействует с моделями и вьюхами, модель сваязывается с БД(которая как бы вне Рэилс приложения отдельно) и возвращает данные, а вьюхи(шаблоны) помогают добавить эти данные в html-страницу, json или что-то еще, что будет отправлено обратно nginx-у, а он соответсвенно передост дальше браузеру



puts '                                         Модели и сервисы'

# https://dev.to/cherryramatis/simple-repository-pattern-for-ruby-on-rails-2lje    модель-репозиторий паттерн

# https://softwareengineering.stackexchange.com/questions/230307/mvc-what-is-the-difference-between-a-model-and-a-service       отличия модели и сервиса

# Модель это потомок ActiveRecord, это класс-обертка над записью из БД.

# Чтобы не пихать лишнюю логику в Модель, можно ее делегировать в консерн (предложение DDH), тоесть в модуль, который будет содержать методы, подключаемые в модель.

# Либо можно вынести какую-то большую логику в сервис-класс используя сервисне объекты и применять его во многих местах. Но минус сервисов в том что на реальных проектах, они начинают использоваться в разных слоях MVC, даже во вьюхах, что не очень хорошо тк нарушает разделение слоев

# Сервис это класс, который взаимодействует с одним или несколькими другими классами, моделями или сервисами или другими типами
# Тоесть сервис это управляющий класс для взаимодействия других классов, как контроллер, только не для взаимодейсвия моделей и вьюх, а для чегото другого

# В сервис норм запихать внешние зависимости, например работу с каким-то внешним API или еще чем-то не относящимся к модели напрямую и уже в модели вызывать этот сервис

# Есть еще один популярный паттерн — query object, он очень похож на сервисы, но там только работа с базой, всякие огромные запросы с фильтрами и т.п.
# Как пример, построенный вокруг юзера: нам нужно создать юзера и назначить ему ментора плюс подключить рассылку. Реализация:
# * в UsersController#create вызываем сервис CreateUser
# * в сервисе CreateUser создаем пользователя, тут все обычно
# * в сервисе CreateUser вызываем сервис AssignMentor
# * в сервисе AssignMentor запускаем query-объект класса SelectNotStupidUsers, выбираем наименее занятого, назначаем новому юзеру
# * возвращаемся в сервис CreateUser, вызываем сервис SubscribeToSpam
# * в SubscribeToSpam создаем объект Subscription с нашим юзером
# * возвращаемся в сервис CreateUser, выходим из него



puts '                                       Фронт для Рэилс-проекта'

# Как делать фронт для приложения на rails? Интегрировать вёрстку?
# Зависит от потребностей/бизнес требований/идей Пишите фуллстак на рельсе хотвайр, ерб, слим и прочее. Если нужно разделить пилите апиху на рельсе и фронт на чем умеете/знаете/понимаете/готовы изучить. По хорошему однозначного ответа нет, в разработке всё очень ситуативно
# Зависит от версии рельс и предпочтений заказчика/тебя. Я бы рекомендовал фронт и бэк делить на два проекта. По фронту используй Vite+Vue, рекомендую



puts '                                           Rails разное'

# load_async - метод позволяет в контроллере создавать ассинхронные запросы к БД(тоесть не один за другим а парраллельно). Это значительно ускоряет загрузку данных на страницу если запросы между собой не связаны
def index
  @tags = Tag.where(id: params[:tag_ids]).load_async # просто добавляем его последним методов в запросе
  @questions = Question.all.load_async
  # Теперь эти запросы будут выполняться параллельно
end



puts '                                       Форматы представлений'

# some.xlsx.axlsx
# some.html.erb
# axlsx и erb - это хэндлеры, которые обрабатывают програмный код написанный на Руби, для последующей генерации фаила
# xlsx и html - это формат в котором мы генерируем итоговый фаил


# Представления формата json. Пример для использования с jBuilder:
# index.json.jbuilder - название
# Пример содержания фаила с отображением свойств коллекции объектов
json.array! @tags do |tag|
  # json.array! - создаем массив из json объекта переданного сюда
  # @tags - коллекция сущностей из БД
  json.id tag.id
  # json.id - будет название поля в json объекте
  # tag.id - будет значение поля в json объекте
  json.title tag.title
end
{ id: 1, title: 'some' } # На выходе на странице получим такие записи для каждого объекта



puts '                                     Настройка временной зоны'

# Настройка временной зоны проиводится в фаиле config/application.rb
module AskIt
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 7.0

    config.i18n.available_locales = %i[en ru]
    config.i18n.default_locale = :en
    # Configuration for the application, engines, and railties goes here.
    #
    # These settings can be overridden in specific environments using the files
    # in config/environments, which are processed later.
    #
    # config.time_zone = "Central Time (US & Canada)"               # Вот тут можно ее переопределить
    # config.eager_load_paths << Rails.root.join("extras")

    # Don't generate system test files.
    config.generators.system_tests = nil
  end
end

















#
