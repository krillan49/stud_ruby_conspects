puts '                           Итераторы: times, upto, downto, each и step. Оператор sleep'

# Итераторы — это не что иное, как методы, поддерживаемые коллекциями. Объекты, в которых хранится группа элементов данных, называются коллекциями. В Ruby массивы и хэши можно назвать коллекциями.

# Итерация - это процесс многократного выполнения чего-либо. (например, "Этот цикл повторяет элементы массива".)
# Итерация - это один проход цикла. (например, "На первой итерации этого for цикла i будет 0".)

# Создают новую область для локальных переменных - локальная переменная заданная в блоке итераторов { тут }, будет существовать только в этом блоке, за его пределами ее существовать не будет


puts
puts '                                                times'

3.times #=> #<Enumerator: 3:times>

# Итератор times нельзя найти в других языках программирования, так как он присутствует только в языке Ruby.
2.times{  # 2 раза выпонить код передаваемого блока.
  puts("Ruby exercises")
}

3.times{print "sisya "} # Можно в одну строку

# times с переменной. Цикл times считает от 0. Переменная задается пайпом(|переменная|)(pipe  в переводе труба), он означает что переменная внутри это параметр цикла, принимающий поочередно все задаваемые циклом значения
10.times{|i| (print "i = " + i.to_s + ", ")}

# Синтаксис do end вместо {} для оператора times. Обычно он используется для большего чем 1 коллич операторов в теле цикла.
10.times do |el|  # задает в переменную el поочередно числа от 0 до 9
	print el
end

n.times do str.chop! end # Можно писать и так в одну строку

# Использование методов в условии цикла times:
str = "Kroker"
str.size.times do |i|
  print str[i]
  sleep rand(0.02..0.3)
  print "-"
end


puts
puts '                                                each'

names = ["Bob", "Kevin", "Alex", "George"]

# names.each - каждый элемент массива names
names.each #=> #<Enumerator: ["Bob", "Kevin", "Alex", "George"]:each>

names.each do |nameA|
  puts nameA += "?"
end


puts
puts '                                             map(collect)'

# Используется метод collect, когда хотите что-то сделать с каждым из значений, чтобы получить новый массив. Например, этот код создает массив b , содержащий по 10 раз каждое значение в a
# map - подставляет заданное значение вместо каждого элемента

a = [1,2,3,4,5]
b = a.collect{|x| 10*x}
p b #=> [10, 20, 30, 40, 50]
p a #=> [1, 2, 3, 4, 5]

# Меняет каждый элемент, соотв если условие в блоке не описывает какие-то элементы, то они заменяются на nil
c = a.map{|e| e*2 if e.odd?}
p c #=> [2, nil, 6, nil, 10]


puts
puts '                                    upto(вверх до) и downto(вниз до)'

# upto работает только в порядке возрастания
5.upto(10) #=> #<Enumerator: 5:upto(10)>

5.upto(10) {|x| print x} # Пока х между 5 и 10 включительно выводим х

"5".upto("10") {|x| print x} # Можно использовать и строки

5.upto(10) {|x| print x, " "} # Добавляем в цикл строку-пробел(новый элемент) при помощи запятой

-2.upto 2 do |x| # Пока х между -2 и 2 включительно выводим х
  print "#{x} "
end

puts
# downto работает только в порядке убывания
9.downto(2) {|x| print x}


puts
puts '                                               step'

# числа от 2х до 10, начиная с 2х с шагом в 3 помещаются в переменную
2.step 10, 3 do |x|
  print "#{x} "
end #=> 2 5 8

# тоже самое можно сделать с числами в порядке уменьшения, тогда нужно задавать шаг отрицательным числом
10.step 2, -3 do |x|
  print "#{x} "
end #=> 10 7 4

2.step(10, 3).to_a #=> [2, 5, 8]

# С диапазоном
(2..10).step(2).sum #=> 30
(-2..-10).step(-2).to_a #=> [-2, -4, -6, -8, -10]


puts
puts '                                        Комбинированные итераторы'

p 3.times.map{'A'} #=> ["A", "A", "A"]
p 3.times.map{|n| n} #=> [0, 1, 2]
p 3.times.to_a #=> [0, 1, 2]


puts
puts '                                          Вложенные итераторы'

# двойной цикл (иногда его называют “вложенный цикл”, “double loop”, если имеют в виду цикл по `i` - то “inner loop”, “внутренний цикл”)
arr = [ %w(a b c), %w(d e f), %w(g h i) ]
arr.each do |arr0|
  arr0.each {|el| print el}
end


puts
puts '                                          Оператор sleep'

# Оператор sleep позволяет ставить задержку с указанием времени в секундах.
def sl()
  p 'hi'
  sleep 3 # ждет 3 секунды
  p 'hi after 3 seconds'
  sleep 0.5 # ждет пол секунды
end
