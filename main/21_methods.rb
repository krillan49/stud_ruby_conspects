puts '                                  Методы/функции, return, alias, undef'

# Метод всегда имеет получателя - объект, вот его можно передать, если присвоить константе. Если вы видете глобальный метод - это иллюзия, у него все-равно есть объект. когда определяешь функции или в файле, то они определяются к объекту main, у него класс Object
# в Ruby функций нет, есть только методы. Методы не существуют в отрыве от объекта. Объекты можно передавать между файлами. Поэтому если вы объявляете метод в одном файле, а он автоматом цепляется к глобальному объекту main, то в другом файле вы его тоже вызовете - потому, что там тоже этот глобальный объект есть (но файлы придется связать при помощи require, сами по себе они не свяжутся). А вот с локальными переменными, которые тоже с маленькой буквы объявляются, уже такое не прокатит. Локальная переменная не передастся, а классы, константы, модули и методы - передаются.

# Ruby - полностью объектно-ориентированный язык. В любой момент времени вы действуете в рамках какого-то объекта, даже если все выглядит так, что вы работаете вне объекта. В языке нет функций и процедур в привычном понимании, только методы, причем метод не может вызываться без получателя, т.е. объекта.

# Точка перед ключевым словом метода ставится, когда это ключевое слово, тоесть начинается с буквы, а если оператор метода задается символом, то точка не обязательна.

# &:  указатель на функцию.
[0, 0, 1, 1, 0, 0, 1, 0].count(&:zero?) #=> 5 проверяя массив методом count применяет метод zero? к каждому элементу
[11, 22, 33, 44, 55].count(&:even?) #=> 2

# 2+3 следует читать как 2.+(3) где + это метод вызванный на объекте 2 с аргументом 3
2+3 #=> 5
2.+(3) #=> 5

# Защита от вызова метода от nil при помощи синтаксиса амперсанта & (либо rescue nil)
p nil&.some_meth #=> nil
str1, str2 = 'aaa', nil
p str1.split('') #=> ["a", "a", "a"]
p str2.split('') #=> undefined method `split' for nil:NilClass (NoMethodError)
p str2&.split('') #=> nil


puts
puts '                                               Методы/Функции'

# Так как в Руби все данные это объекты то все функции в Руби являются методами.

# функции - это обособленный фрагмент кода(подпрогрпмма), который называется по имени. В нее могут быть переданны данные для работы(параметры). Функция может опционально возвращать данные (возвращаемое значение). Все данные, передаваемые функции, передаются явно.

# Метод в объектно-ориентированном программировании — это функция, принадлежащая какому-то классу или объекту. Методы классифицируются по применимости к объектам: статические и простые/нестатические; по возможности использования: public, private, protected. Метод может работать с данными, содержащимися в классе (помня, что объект является экземпляром класса - класс является определением, объект является экземпляром этих данных).

# процедуры - альтернативное название функций и методов.

# Основная задача - выделить какие-то логические блоки и сделать программу более читаемой для человека(например вынести повторяющийся код и обращаться к нему, когда это будет нужно). Часто такой процесс называется рефакторингом (а эту технику рефакторинга - extract method/выделить метод). В результате рефакторинга большой участок программы разбивается на несколько маленьких.
# рефакторинг кода — это процесс реструктуризации существующего компьютерного кода — изменение факторинга — без изменения его внешнего поведения. Рефакторинг предназначен для улучшения дизайна, структуры и/или реализации программного обеспечения (его нефункциональных атрибутов) при сохранении его функциональности.

# Методы должны быть определены до их вызова

def kroker_say # def (define/определить) Обозначение(ключевое слово) начала(открытия) метода, def определяет/задает функцию, имя метода/функции в Руби пишется без больших букв, разделяя слова нижним подчеркиванием
  puts "Я Крокер!" # тело метода между def и end
end # обозначение конца(закрытия) метода end

# Вызов метода(и его работа) производится его названием в любом месте(сколько угодно раз), например между других строк
kroker_say() #=> "Я Крокер!"
puts "Нихуясе!"
kroker_say() #=> "Я Крокер!"


puts
puts '                                            Методы с параметрами'

# параметр в методе == локальная переменная
# Методы с параметрами. Если значения указанных параметров не заданы ни при вызове метода ни по умолчанию, выдаст ошибку
def kroker_say2(word = "Я огромен!", num = 9000) # word и num - параметры, после = значения параметров по умолчанию
  puts "Я Крокер!"
  puts ("Крокер говорит: " + word + " Крокер достает и измеряет: " + num.to_s)
  puts "Hello, #{word}"
end
kroker_say2("Вот мой огромный меч!", 100500) # В скобках заданы значения параметров для word и num
kroker_say2() # Если не указать значение параметров после вызова метода, то выдаст значение параметров заданных по умолчанию
kroker_say2 'Roman'  # Синтаксис без скобок

# сумма параметров
def sum(x, y)
  puts (x + y)
end
sum(5, 20) #=> 25

# хэш в виде параметра
def hash_1 hash
  print hash
end
hh = {1=> :a, 2 => :b}
hash_1 hh #=> {1=>:a, 2=>:b}

# Неопределенное колличество параметров. Помещаются в массив при помощи символа * перед параметром
def sum(*args)
  args
end
p sum(1, '2', 3, 'gbcz') #=> [1, '2', 3, 'gbcz']

# Неопределенное колличество параметров, включая элементы хэша
def args_count(*args, **kwargs)
  p args #=> [1, 2]
  p kwargs #=> {:a=>1, :b=>2}
end
args_count(1, 2, a: 1, b: 2)

# альтернативный синтаксис неопределенного числа параметров
def some(...)
  1.step(...).to_a
end
p some(10, 2) #=> [1, 3, 5, 7, 9]


# Вызов метода внутри самого себя(зацикленный метод/рекурсия)
def total(arr)
  return arr.first if arr.size == 1
  total(arr.each_cons(2).map{ |a,b| a+b })
end

# метод в одну строку
def met(a) a+1 end
p met(1) #=> 2


puts
puts '                                           Оператор return'

# Оператор return возвращает из функции указанную после него строку кода к оператору вызова метода и завершает работу метода
# По умолчанию функция возвращает последнюю строку кода(для ее возврата return не обязателен)
def raznoe(x = 100, y = 50)
  puts "пися"
  return x - y, 70, "Сися"  # Возвращает что либо из метода и так же выходит из него(не учитывает все последующее тело метода)
  puts (x + y)
end
raznoe() #=> [50, 70, "Сися"] # Выполняет все, что идет до и в return, не выпоняет все что после return.
# Если задано более двух выражений, возвращаемым значением будет массив, содержащий эти значения. Если выражение не задано, возвращаемым значением будет nil

puts
# По умолчанию Руби возвращает результат последнего выражения. Тоесть любой строки когда находящейся последней в теле метода. Соответсвенно return в этом случае можно не ставить.
def get_command
	"left" # аналогично retutn "left"
end
p get_command() #=> "left"

# без выражения вернет nil
def some
end
p some #=> nil

puts
# Если возвращать условие, то return при выводе будет проверять это условие и выдавать false/true
def zad?(x, y) # имя метода, которое возвращает булевое значение пишется с вопросительным знаком
  return (x < 20 and y == 10) # return так же необязателен
end
puts zad?(15, 10) #=> true
puts zad?(21, 10) #=> false

puts
# Не смотря на то что метод возвращает только то что идет в return или в последней строке, но выполняет он весь код соответсвенно все что в нем есть на вывод выводится, а на инициальзацию инициализируется
def some(x = 100, y = 50)
  @a = x
  b = x
  y
end
p some() #=> 50
p @a     #=> 100
p b      #=> undefined local variable or method `b' for main:Object (NameError)

puts
# return без параметров возвращает nil
def some
  return
  'a'
end
p some #=> nil

# return без параметров после and
@a = 0
def some
  @a += 1 and return
  'a'
end
p some #=> nil
p @a #=> 1


puts
puts '                             Помещение результата выполнения метода в переменную'

res = raznoe(25, 10)  # Помещение результата выполнения метода в переменную
p (res) #=> "пися\n" [15, 70, "Сися"]
puts (res[2]) #=> "Сися"  # Можно обращаться через переменную к return(не учитывает и то что в теле метода до return) как к массиву, если возвращаем несколько значений
puts "Получена команда #{res[1]}" #=> "Получена команда 70"

puts
# Пример метода для ввода данных(gets)
def get_number(what)
  print "Введите #{what}: "
  gets.to_i
end
age = get_number('возраст')
salary = get_number('зарплату')
rockets = get_number('количество ракет для запуска')


puts
puts '                                              Переменные экземпляра'

# Локальная(local) - это любая переменная, объявленная внутри метода. Внутри тела метода переменная определяется заново(переменная с тем же именем вне метода это другая переменная) отдельно для пространства "внутри" этой функции
# Переменные экземпляра класса работают(доступны) по всей программе(но ограниченны классами либо внутри либо вне) как внутри отделых методов так и вне их. Назначаются при помощи символа @(Желательно использовать только в классах)
a = 1
@b = 1
def a_a
  a = 2
  @b = 2
  puts "#{a}, #{@b}"
end
a_a #=> "2, 2"
puts a #=> 1
puts @b #=> 2


puts
puts '                                               options'

# Если в метод нужно задать много параметров и потом некоторые убрать/добавить/поменять местами, то придется их менять и в каждом месте вызова метода. Поэтому удобнее вместо отдельных параметров использовать один параметр в который передать хэш содержащий отдельные параметры. Так параметры удобно добавлять, убирать и они не будут зависеть от порядка. К тому же точно видно какие параметры мы передаем, т.к. мы явно указываем названия этих параметров

def add_person (options = {}) # С указанием значений по умолчанию({} - пустой хэш). Так не будет ошибки если вызвать метод без параметров, тк переменные “a, b, c” будут инициализированы значением nil и метод можно будет вызывать без параметров.
  age = options[:age]
end
list = { name: 'Mike', age: 65 } # Вариант передачи с помещением хэша в переменную для наглядности
add_person(list)
add_person(name: 'Mike', age: 65) # Вариант 2. Фиг скобки не обязательны, Руби понимает что это хэш.


puts
# Так же в месте с хэшем можно передать и другой параметр.
# Если в функцию передается и хэш и отдельный параметр, то хэш всегда располагается по порядку последним. Происходит так потому что мы не знаем какое колличество элементов будет в хэше, а тк мы передаем их через запятую, то параметр записанный после хеша может быть воспринят ключем очередного элемента хэша.
def met(a, hh)
  # Какой-то код
end
met(125, name: 'Mike', age: 65)


puts
# nil || true. Если не задавать параметр(или испотзуемые элементы хэша) при вызове метода, то могут возникнуть проблемыы изза операций заданных методом, которые не могут проводиться со значением nil. Для предотвращения можно использовать оператор ||(or/или).
# nil || true => true;  nil || 100 => 100;  nil || 'aaa' => "aaa"
def total_weight(options = {})
  a = options[:soccer_ball_count] || 0 # Будет 0 вместо nil
  b = options[:tennis_ball_count] || 0
  c = options[:golf_ball_count] || 1 # Удобно задавать другие альтернативные решения(например 1 мяч в подарок если нет заказа)
  (a * 410) + (b * 58) + (c * 45) + 29
end
p x = total_weight() #=> 74   # (0 * 410) + (0 * 58) + (1 * 45) + 29
p x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1) #=> 1429


puts
puts '                                           Метод от объекта'

#  Можно добавлять методы не только в любые классы, но и в любые объекты. Например, вы можете добавить к некоторой строке произвольный метод.
str = "Привет"
def str.bye # str. указывает, кому принадлежит метод (по умолчанию Object) bye - имя метода
  "Пока!"
end
puts str.bye #=> Пока!


puts
puts '                                        alias (псевдонимы методов)'

# Дает псевдоним методам или глобальным переменным. Псевдонимы не могут быть определены в теле метода.
# Псевдоним метода сохраняет текущее определение метода, даже если методы переопределены.
# Создание псевдонимов для пронумерованных глобальных переменных ($1, $2,...) запрещено. Переопределение встроенных глобальных переменных может вызвать серьезные проблемы.

# Синтаксис для метода: alias alias_method_name method_name => method_name === alias_method_name
def bar
  puts 'i am Kroker'
end
alias foo bar #=> Здесь мы определили псевдоним foo для метода bar
foo #=> "i am Kroker"

# Псевдоним метода сохраняет текущее определение метода если изначальный метод переопределен.
def bar
  puts 'aaa'
end
bar #=> "aaa"
foo #=> "i am Kroker"

# Альтернативный синтаксис переопределения через = ??
def aaa = bbb
def bbb
  'bbb'
end
p aaa #=> "bbb"

# Синтаксис для глоб переменной: alias global_variable_alias_name global_variable_name
$a = 10
alias $b $a #=> $b — это псевдоним для $a.
p $b #=> 10


puts
puts '                                      undef(отмена определения метода)'

# отменяет определение метода. undef не может появляться в теле метода

# undef method-name
def aaa
  puts 'aaa'
end
aaa #=> aaa
undef aaa
aaa #=> undefined local variable or method `aaa' for main:Object (NameError)


# Используя undef и alias, интерфейс класса можно изменить независимо от суперкласса, но это может привести к поломке программ внутренним вызовом метода self.


puts
puts '                                        Меморизация'

# При помощи константы или другой переменной с доступом в метод
HH = [0, 1]
def fibonacci(n)
  return HH[n] if HH.size >= n
  n.times do
    HH << HH.last(2).sum
  end
  HH[n]
end












#
