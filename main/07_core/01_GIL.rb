puts '                                             GIL (GVL)'

# GIL (Global Interpreter Lock | Глобальная блокировка интерпретатора) или GVL (Global VM Lock) - это механизм, который позволяет только одному потоку в стандартной реализации Ruby-интерпретатора (MRI - Matz's Ruby Interpreter, основная реализация Ruby) выполнять Ruby-код в любой момент времени. Это означает, что даже на многоядерном процессоре, только один поток Ruby сможет активно использовать процессор для выполнения Ruby-кода

# GIL - это своеобразный "ключ", который позволяет только одному потоку Ruby "зайти" в критическую секцию интерпретатора и изменить его состояние.

# Зачем нужен GIL?:
# 1. GIL значительно упрощает управление памятью. Он позволяет избежать race conditions (гонки данных) при работе с общими структурами данных интерпретатора (например, при сборке мусора). Без GIL было бы необходимо использовать сложные и дорогостоящие механизмы синхронизации для защиты этих данных, что бы значительно замедлило работу Ruby.
# 2. Совместимость с существующим C-кодом: Многие расширения Ruby написаны на C, и GIL обеспечивает простую интеграцию Ruby с этими расширениями. C-расширения часто не являются потокобезопасными. GIL предотвращает одновременный доступ нескольких потоков к этим расширениям.

# Недостатки GIL:
# 1. GIL является серьезным ограничением для параллелизма в Ruby. Он не позволяет Ruby эффективно использовать многоядерные процессоры для выполнения нескольких потоков Ruby-кода одновременно. Это означает, что приложения, интенсивно использующие CPU, могут не получить выгоды от многопоточности в Ruby.
# 2. Если один поток Ruby блокируется (например, при выполнении операции ввода-вывода), GIL остается захваченным этим потоком, и другие потоки не могут выполняться, даже если они готовы.

# Существует несколько способов обойти ограничения GIL в Ruby:
# 1. Многопроцессность (Processes): Использовать `Process` вместо `Thread`. Каждый процесс имеет свою собственную копию интерпретатора и памяти, что позволяет избежать ограничений GIL. Это более ресурсоемкий подход, чем многопоточность, но он позволяет добиться настоящего параллелизма.
# 2. Использовать неблокирующие операции ввода-вывода (Non-blocking I/O), чтобы избежать блокировки GIL при ожидании данных.
# 3. Использовать альтернативные реализации Ruby, такие как JRuby (на Java) или TruffleRuby, которые не используют GIL. JRuby использует потоки Java, а TruffleRuby имеет другие механизмы параллелизма.
# 4. C-расширения: Написать CPU-интенсивные операции на C и освободить GIL во время их выполнения. Это требует более глубокого понимания C и Ruby API.












#
