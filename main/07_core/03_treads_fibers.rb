puts '                                 Файбры (Fibers) и Потоки (Threads)'

# Файбры и потоки предоставляют разные способы достижения конкурентности и параллелизма (параллельного выполнения кода) в Ruby, но они работают на разных уровнях и имеют разные характеристики. Потоки управляются операционной системой и могут выполняться параллельно, а файбры управляются программистом и обеспечивают конкурентность в рамках одного потока

# Таблица сравнения:
#                  | Потоки (Threads)                          | Файбры (Fibers)                                  |
# |----------------|-------------------------------------------|--------------------------------------------------|
# | Параллельность | Могут быть параллельными                  | Конкурентность, но не параллельность             |
# | Управление     | Операционная система                      | Программист                                      |
# | GIL (MRI Ruby) | ограничивает параллельное выполнение кода | ограничивает параллельное выполнение кода        |
# | Создание       | Тяжелое                                   | Легкое                                           |
# | Сложность      | Сложно (синхронизация)                    | Сложно (явное управление переключением)          |
# | Применение     | I/O, фоновые задачи                       | Сопрограммы, итераторы, генераторы, асинхронщина |

# Используйте потоки, когда:
# 1. Нужно действительно параллельное выполнение на многоядерных процессорах (если вы используете реализацию Ruby без GIL, такую как JRuby или Rubinius).
# 2. Есть задачи, которые в основном связаны с вводом-выводом (I/O), и нужно, чтобы программа не блокировалась во время ожидания завершения этих операций

# Используйте файбры, когда:
# 1. Нужно управлять переключением между задачами на более низком уровне.
# 2. Нужно реализовать сопрограммы, итераторы или генераторы.
# 3. Нужно реализовать асинхронное программирование без использования потоков (особенно полезно в однопоточных средах, таких как EventMachine)



puts '                                          Потоки (Threads)'

# Параллельность: Потоки могут выполняться действительно параллельно, особенно на многоядерных процессорах. Это значит, что разные потоки могут занимать разные ядра и работать одновременно

# Управление потоками осуществляется операционной системой. Операционная система решает, когда переключаться между потоками, используя алгоритмы планирования. Программист имеет ограниченный контроль над переключением контекста между потоками.

# GIL: В MRI (Matz's Ruby Interpreter) GIL позволяет только одному потоку выполнять байт-код Ruby за раз. Это означает, что даже на многоядерном процессоре, только один поток Ruby может одновременно выполнять код Ruby. Потоки все еще полезны для выполнения задач ввода-вывода (I/O), где поток может ждать завершения операции, не блокируя всю программу. Другие реализации Ruby, такие как JRuby и Rubinius, не имеют GIL.

# Создание потока относительно "тяжелое" с точки зрения ресурсов, так как требует выделения памяти для стека и других структур данных, необходимых для работы потока.

# Сложность: Работа с потоками может быть сложной из-за необходимости синхронизации доступа к общим ресурсам, чтобы избежать гонок данных и других проблем

# Применение:
# 1. Выполнение задач ввода-вывода (I/O), таких как чтение из файла, отправка сетевых запросов, где поток может "ждать" завершения операции, не блокируя всю программу.
# 2. Выполнение долго выполняющихся задач в фоновом режиме, чтобы не блокировать основной поток.

require 'thread'

thread1 = Thread.new do
  puts "Thread 1 started"
  sleep(2)
  puts "Thread 1 finished"
end

thread2 = Thread.new do
  puts "Thread 2 started"
  sleep(1)
  puts "Thread 2 finished"
end

thread1.join
thread2.join



puts '                                          Файбры (Fibers)'

# Параллельность: Файбры обеспечивают конкурентность, но не параллельность. Они выполняются в одном потоке операционной системы

# Управление файбрами полностью осуществляется программистом. Программист явно указывает, когда нужно приостановить выполнение файбра и передать управление другой файбре.

# GIL влияет на производительность файберов точно так же, как и на потоки в MRI Ruby.

# Создание файбра относительно "легкое" с точки зрения ресурсов.

# Сложность: Работа с файбрами может быть сложной, так как требует явного управления переключением контекста

# Применение:
# 1. Реализация сопрограмм (coroutines), которые позволяют приостанавливать и возобновлять выполнение кода в определенные моменты.
# 2. Реализация итераторов и генераторов.
# 3. Реализация асинхронного программирования, когда код может переключаться между различными задачами без использования потоков.
# 4. Реализация кооперативной многозадачности.

fiber1 = Fiber.new do
  puts "Fiber 1 started"
  Fiber.yield  # Приостановка выполнения Fiber 1
  puts "Fiber 1 resumed"
  puts "Fiber 1 finished"
end

fiber2 = Fiber.new do
  puts "Fiber 2 started"
  puts "Fiber2 finished"
end

fiber1.resume # Запуск Fiber 1
fiber2.resume # Запуск Fiber 2 (который сразу завершится)
fiber1.resume # Возобновление Fiber 1











#
