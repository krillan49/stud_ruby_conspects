puts '                                           Методы/функции'

# Ruby - полностью объектно-ориентированный язык, в котором все действия осуществляются в рамках какого-то объекта. В Ruby нет функций и процедур в привычном понимании, только методы, которые всегда имеет получателя - объект

# Глобальный метод - это иллюзия, у него все-равно есть объект. Если определить "глобальную" функцию, то она определяются к объекту main, инстансу класса Object

# Объекты можно передавать между файлами. Поэтому если вы объявить метод в одном файле, он автоматом цепляется к глобальному объекту main, то в другом файле(при помощи require) его тоже можно вызовать потому, что там тоже есть этот глобальный объект main. Тоесть между фаилами передаются классы, константы, модули и методы, но не передаются локальные переменные (?? добавить в отдельный фаил про require ??)

# Методы и блоки в Руби сами не являются объектами и в случае методов ими управляет специальный класс Method


# Точка перед методом ставится, когда это ключевое слово - тоесть начинается с буквы, а если оператор метода задается символом, то точка не обязательна:
# Например 2+3 следует читать как 2.+(3) где + это метод вызванный на объекте 2 с аргументом 3
2+3    #=> 5
2.+(3) #=> 5


# & (rescue nil) - защита от вызова метода от nil при помощи синтаксиса амперсанта
nil.split('')    #=> undefined method `split' for nil:NilClass (NoMethodError)
nil&.split('')   #=> nil
false&.split('') #=> undefined method `split' for false:FalseClass (NoMethodError)


# Проверить отвечает ли объект на метод (например чтобы потом избежать ошибок)
p 'asdfg'.respond_to?(:split)       #=> true
p %w[a s d f g].respond_to?(:split) #=> false


# ?? То что ниже потом вынести в тему функционального программирования ??

# Метод можно вызвать внутри другого метода или внутри самого себя(зацикленный метод/рекурсия)
def total(arr)
  return arr.first if arr.size == 1
  total(arr.each_cons(2).map{ |a,b| a+b })
end

# &: - указатель на функцию, значит что переданная далее функция применится к каждому элементую Работает только для 1го метода
[0, 0, 1, 1, 0, 0, 1, 0].count(&:zero?)      #=> 5      применяет метод zero? к каждому элементу
[0, 0, 1, 1, 0, 0, 1, 0].count{|e| e.zero?}  # работает так же



puts '                                       Определение и вызов метода'

# Методы должны быть определены до их вызова

# def (define/определить) - ключевое слово для открытия/определения метода

# Имя метода в Руби пишется в snake_case - слова разделяются символом нижнего подчёркивания (_), каждое слово обычно пишется с маленькой буквы:
def kroker_say
  p "Я Крокер!" # тело метода между def и end
end             # для обозначение закрытия метода используется ключевое слово end

# Вызов метода(тоесть выполнение кода из его тела) производится его оператором - названием метода в любом месте, вызвать можно сколько угодно раз:
kroker_say() #=> "Я Крокер!"
p "Нихуясе!" #=> "Нихуясе!"
kroker_say   #=> "Я Крокер!"
# Круглые скобки для вызова оператора метода по его имени в Руби можно опускать

# Можно переопределить метод, просто определив его еще раз ниже в коде
def kroker_say
  p "У меня огромный меч!"
end
kroker_say   #=> "У меня огромный меч!"



puts '                                           Метод в 1 строку'

# Метод в одну строку синтаксис 1:
def met(a) a+1 end
p met(1) #=> 2

# Метод в одну строку синтаксис 2:
def list(n) = 5+n
p list(6) #=> 11



puts '                                         Способы вызова метода'

# Есть 3 способа вызвать метод в Руби: через его название, через send и через method().call

# На примере метода object_id объекта класса Object
object = Object.new
p object.object_id                #=> 60
p object.send(:object_id)         #=> 60
p object.method(:object_id).call  #=> 60

# На примере "глобального" метода
def some
  "Some"
end
p some                #=> "Some"
p send(:some)         #=> "Some"
p method(:some).call  #=> "Some"



puts '                                     undef (отмена определения метода)'

# undef - ключевое слова отменяет определение метода по его имени (undef method-name). undef не может появляться в теле метода

def aaa
  puts 'aaa'
end

aaa        #=> aaa
undef aaa
aaa        #=> undefined local variable or method `aaa' for main:Object (NameError)

# Используя undef и alias, интерфейс класса можно изменить независимо от суперкласса, но это может привести к поломке программ внутренним вызовом метода self.



puts '                                        alias (псевдонимы методов)'

# alias - ключевое слово дает псевдоним методам или глобальным переменным. Псевдонимы методов не могут быть определены в теле метода. Псевдоним метода сохраняет текущее определение метода, даже исходный метод переопределен.

# Синтаксис: alias alias_method_name method_name
def bar
  p 'i am Kroker'
end
alias foo bar # Здесь мы определили псевдоним foo для метода bar
foo #=> "i am Kroker"

# Псевдоним метода сохраняет текущее определение метода если изначальный метод переопределен:
def bar
  p 'aaa'
end
bar #=> "aaa"
foo #=> "i am Kroker"

# Альтернативный синтаксис алиаса/переопределения метода: def method_name1 = method_name2
def aaa
  'aaa'
end
def aaa = bbb # переопределяем/назначаем алиас метода aaa для bbb
def bbb
  'bbb'
end
p aaa #=> "bbb"

# Используя undef и alias, интерфейс класса можно изменить независимо от суперкласса, но это может привести к поломке программ внутренним вызовом метода self.


# Проверить являются ли методы алиасасми
Kernel.instance_method(:kind_of?) == Kernel.instance_method(:is_a?) #=> true
# is_a? и kind_of? методы алиасы реализованы в модуле ядра, который добавлен в класс Object.



puts '                                          Методы с параметрами'

# Параметр в методе это локальная переменная в области тела метода

# Если значения, указанных в проеделении метода параметров и не заданы по умолчанию, и не переданы в оператор при вызове метода, то выбросит ошибку

# Метод с параметрами:
def sum x, y   # скобки использовать не обязательно
  puts (x + y) # использование параметров в теле метода
end
# Передаем параметры через оператор вызова метода:
sum(5, 20) #=> 25      # в скобках заданы значения параметров для x и y
sum 7, 8   #=> 15      # скобки использовать не обязательно



puts '                                         Параметры по умолчанию'

# Значения по умолчанию для параметров будут использованы, если соответсвующие параметры не переданны через оператор. Значения по умолчанию для параметров пишутся через = после имен параметров
# Все параметры/аргументы со значениями по умолчанию принято(но не обязательно) писать в конце

def kroker_say2(word="Я огромен!", num=9000)
  p "Крокер говорит: #{word}. Крокер достает и измеряет: #{num}"
end
# Если не передать параметры в оператор вызова метода, то метод применит значения параметров заданных по умолчанию:
kroker_say2()    #=> "Крокер говорит: Я огромен!. Крокер достает и измеряет: 9000"
# При передаче nil значение считается переданным и присваивает его а не значение параметра по умолчанию:
kroker_say2(nil) #=> "Крокер говорит: . Крокер достает и измеряет: 9000"


# Тк параметры - это просто определение локальных переменных принимающих значение из оператора или по умолчанию, то можно писать код прямо в параметрах и определять его как значение парвметра по умолчанию:
def bt_rec(w, i=1, size=w.length-i) # код использующий переменные из параметров, должен быть записан после них
  size
end
p bt_rec("trie")          #=> 3
p bt_rec("trie", 3)       #=> 1
p bt_rec("trie", 2, 9000) #=> 9000



puts '                                      Хэш-синтаксис для аргументов'

# Можно записать параметры как шаблон для хэша аргументов

def new_way(arg1: 1, arg2:, arg3: 100) # ключи-аргументы можно оставлять без значений, либо добавить значения по умолчанию, при этом если значение не переданно через оператор и не выставлено по умолчанию, то будет выброшена ошибка а не nil как в обычном хэше
  [arg1, arg2, arg3] # вызываются такие параметры как обычные локальные переменные
end

# При вызове порядок следования параметров не важен
p new_way(arg2: "hello!", arg1: "hi") #=> ["hi", "hello!", 100]



puts '                                           Хэш options/params'

# Часто удобнее вместо отдельных параметров использовать один параметр в который передать хэш содержащий значения, что будут использованы как отдельные параметры. Так параметры будет можно передавать в любом порядке, в любом колличестве с любой вложенностью, плюс точно видно какие параметры мы передаем, по названию их ключей

# Обычно принято называть такой хэш с параметрами options или params

# Так же параметру в который ожидается хэш можно по умолчанию задать значением пустой хэш({}), чтобы не было ошибки если никакие параметры не переданы, тк при вызове от несуществующего ключа хэша всегда возвращает nil

def add_person (options = {})
  age = options[:age]
end
# Вариант передачи с помещением хэша в переменную для наглядности
list = { name: 'Mike', age: 65 }
p add_person(list)                   #=> 65
# Вариант 2. Фигурные скобки не обязательны, Руби понимает что это хэш.
p add_person(name: 'Mike', age: 65)  #=> 65
p add_person                         #=> nil

# Если не задавать, испотзуемые как параметры элементы хэша при вызове метода, то могут возникнуть проблемы из-за операций заданных методом, которые не могут проводиться со значением nil. Для предотвращения можно использовать оператор ||(or/или).
def total_weight(options = {})
  a = options[:soccer_ball_count] || 0 # Будет 0 вместо nil
  # Удобно задавать другие альтернативные решения(например 1 мяч в подарок если нет заказа):
  b = options[:golf_ball_count] || 1
  (a * 410) + (b * 58) + 29
end
p total_weight() #=> 87   # (0 * 410) + (1 * 58) + 29
p total_weight(soccer_ball_count: 3, golf_ball_count: 1) #=> 1317


# Так же в месте с хэшем можно передать и другой параметр. Если в метод передается и хэш и отдельный параметр, то хэш всегда располагается по порядку последним. Происходит так потому, что мы не знаем какое колличество элементов будет в хэше, а тк мы передаем их через запятую, то параметр записанный после хеша может быть воспринят ключем очередного элемента хэша.
def met(a, hh)
  # Какой-то код
end
met(125, name: 'Mike', age: 65)

# Если метод принимает 2 хэша то у 2го в операторе скобки писать обязательно, иначе будет непонятно где начинается 2й хэш
def met(a, hh, hh2)
  # Какой-то код
end
met(125, {name: 'Mike', age: 65}, name: 'Vasya', age: 7)



puts '                                             *args, **kwargs'

# Неопределенное колличество параметров помещаются в массив при помощи символа * перед именем параметра. Неопределенное колличество параметров прописываются после обязательных параметров.
def sum(n, *args)
  args
end
p sum(1, '2', 3, 'gbcz') #=> ['2', 3, 'gbcz']

# Неопределенное колличество параметров, включая элементы хэша при помощи синтаксиса ** перед именем параметра, которые прописываются после *параметров
def args_count(n, *args, **kwargs)
  p args #=> [1, 2]
  p kwargs #=> {:a=>1, :b=>2}
end
args_count(0, 1, 2, a: 1, b: 2)

# Альтернативный синтаксис неопределенного числа параметров-массива
def some(...)
  1.step(...).to_a # можно использовать как параметр
end
p some(10, 2) #=> [1, 3, 5, 7, 9]



puts '                                           Оператор return'

# return - оператор возвращает из функции указанную после него строку кода к оператору вызова метода и завершает работу метода. По умолчанию любой метод возвращает последнюю строку кода тоесть для ее возврата прописывать return не обязательно

# Если в return передано более двух выражений, возвращаемым значением будет массив, содержащий эти значения
# Если в return пусто и выражение не задано, возвращаемым значением будет nil
# Если возвращать условие, то return при выводе будет проверять это условие и выдавать false/true

def raznoe(x = 100, y = 50)
  p "пися"
  return x - y, 70, "Сися"  # Возвращает массив из метода и выходит из него, не учитывает все последующее тело метода
  p (x + y)
end
raznoe()
#=> "пися"
#=> [50, 70, "Сися"]


# По умолчанию Руби возвращает результат последнего выражения. Тоесть любой строки когда находящейся последней в теле метода.
def get_command
	"left" # аналогично retutn "left"
end
p get_command() #=> "left"


# return без параметров возвращает nil
def some
  return
  'a'
end
p some #=> nil

# return без параметров после and
@a = 0
def some
  @a += 1 and return # если написать && то придется ставить скобки
  'a'
end
p some #=> nil
p @a   #=> 1


# Если возвращать условие, то return при выводе будет проверять это условие и выдавать false/true
def zad?(x, y) # имя метода, которое возвращает булевое значение пишется с вопросительным знаком
  x < 20 && y == 10
end
zad?(15, 10) #=> true
zad?(21, 10) #=> false



puts '                             Помещение результата выполнения метода в переменную'

# Тк любой метод что-то возвращает, то результат его выполнения можно присвоить в переменную через оператор вызова метода

def get_number(what)
  print "Введите #{what}: "
  gets.to_i
end
# Помещение результата выполнения метода в переменную:
age = get_number('возраст')
salary = get_number('зарплату')



puts '                                       Методы с rescue, else, ensure'

# В методе можно применять ключевые слова (блоки ?) rescue, else, ensure

# ensure - выполнит код в этом блоке в любом случае, даже если метод вызвал return
def some(n)
  return n + 1 if n < 10
  n
ensure
  @a = "B" # этот код будет выполнен в любом случае
end
p @a      #=> nil
p some(5) #=> 6
p @a      #=> "B"

# rescue - обработает ошибку, если она выловлена в осноавном блокке метода и выполнит свой код
# else   - выполнит свой код если блок rescue не отловил ошибок
def some(arg)
  res = '1' + arg     # действие
rescue StandardError => e
  'arg is not string' # возвращаем если в основном разделе есть ошибка
else
  res                 # возвращаем если нет ошибки
end
p some(1)   #=> "arg is not string"
p some('1') #=> "11"



puts '                                         Переменные и меморизация'

# Локальная(local) - это любая переменная, объявленная внутри метода. Внутри тела метода переменная определяется заново(переменная с тем же именем вне метода это другая переменная) отдельно для пространства "внутри" этой функции

# Переменные экземпляра класса доступны по всей программе(но ограниченны классами либо внутри либо вне) как внутри отделых методов так и вне их(Желательно использовать только в классах)

a = 1
@b = 1
def a_a
  a = 2
  @b = 2
  puts "#{a}, #{@b}"
end
a_a #=> "2, 2"
puts a #=> 1
puts @b #=> 2


# Меморизация При помощи константы или другой переменной с доступом в метод
HH = [0, 1]
def fibonacci(n)
  return HH[n] if HH.size >= n
  n.times do
    HH << HH.last(2).sum
  end
  HH[n]
end



puts '                                           Метод от объекта'

# Можно добавлять методы не только в любые классы, но и в любые объекты. Например, можно добавить к некоторой строке (? с символом не работает почемуто ?) произвольный метод, который будет вызываться только от нее (по айди объекта)

str = "Привет"
def str.bye # переменная указывает, какому объекту принадлежит метод (по main класса умолчанию Object ??)
  "Пока!"
end
p str.bye      #=> Пока!
p 'Vasya'.bye  #=> undefined method `bye' for "Vasya":String (NoMethodError)
p 'Привет'.bye #=> undefined method `bye' for "Привет":String (NoMethodError)


# Так 2 объекта одного класса используют разные методы с одним названием
str1 = "Vasya"
def str1.is
  "Pidor"
end
str2 = "Petya"
def str2.is
  "Norm"
end

p [str1, str2].map{ |name| name.is } #=> ["Pidor", "Norm"]














#
