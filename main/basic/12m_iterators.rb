puts '                                              Итераторы'

# Итерация - (например итерация массива) это процесс многократного выполнения чего-либо

# Итерация - это один проход цикла. (например, "На первой итерации этого for цикла i будет 0".)

# Итераторы — это методы, поддерживаемые коллекциями. В руби это - times, upto, downto, step, each, map итд

# Объекты, в которых хранится группа элементов данных, называются коллекциями. В Ruby массивы и хэши можно назвать коллекциями.

# Итераторы создают новую область для локальных переменных - локальная переменная заданная в блоке итераторов { тут }, будет существовать только в этом блоке, за его пределами ее существовать не будет
# Переменная задается пайпом(|переменная|)(pipe  в переводе труба), он означает что переменная внутри это параметр цикла, принимающий поочередно все задаваемые циклом значения



puts '                                                times'

# times - итератор производит число итераций равное объекту целого числа от которого вызывается, может принимать блок с переменной. Его нельзя найти в других языках программирования, так как он присутствует только в языке Ruby.

3.times #=> #<Enumerator: 3:times>

# 2 раза выпонить код передаваемого блока.
2.times { puts("Ruby exercises") }

# times передает в переменную блока значения начиная от нуля и до заданного значения не включительно
10.times { |i| print "i=#{i} " } #=> "i=0 i=1 i=2 i=3 i=4 i=5 i=6 i=7 i=8 i=9 "

# Синтаксис do end вместо {}. Обычно он используется для большего чем 1 коллич операторов в теле цикла.
10.times do |i|
	print "i=#{i} "
end

# do end тоде можно писать в одну строку
10.times do |i| print "i=#{i} " end

# 
a, b, c = 3.times.map { STDIN.gets.to_i }



puts '                                           upto и downto'

# upto(вверх до) - итератор принимает и итерирует значения начиная об объекта целого числа, от котрого вызван и до целого числа в параметре включительно. Работает только в порядке возрастания

5.upto(10) #=> #<Enumerator: 5:upto(10)>

5.upto(10) {|x| print x}
"5".upto("10") {|x| print x}  # Можно использовать и строки
5.upto(10) {|x| print x, " "} # Добавляем в цикл строку-пробел(новый элемент) при помощи запятой

-2.upto 2 do |x| # Пока х между -2 и 2 включительно выводим х
  print "#{x} "
end


# downto(вниз до) - итератор работает аналогично upto, но только в порядке убывания
9.downto(2) {|x| print x}



puts '                                               step'

# step - итератор вызывается либо от числа(начальное значение) и принимает 2 параметра (конечное значение и шаг), либо от диапазона с начальным и конечным значением и параметра(шаг). Шаг можно задавать отрицательным числом, тогда начальное значение должно быть больше конечного и соответсвенно мы не можем использовать диапазон. Часть элементов соответсвующих шагу передаются в переменную блока

1.step(10,3)                            #=> (1.step(10, 3))
(1..5).step                             #=> ((1..5).step)
(1..5).step(2)                          #=> ((1..5).step(2))
(1..5).step.class                       #=> Enumerator::ArithmeticSequence

# В порядке возразтания с положительным шагом
2.step 10, 3 do |x|
  print "#{x} "
end #=> 2 5 8

# В порядке уменьшения, с отрицательным шагом
10.step 2, -3 do |x|
  print "#{x} "
end #=> 10 7 4

2.step(10, 3).to_a #=> [2, 5, 8]

# С диапазоном
(2..10).step(2).sum     #=> 30
(-2..-10).step(-2).to_a #=> [-2, -4, -6, -8, -10]



puts '                                                each'

# each - итератор вызывается от объектов-коллекций, передает в переменную блока каждый элемент коллекции поочередно.

["Bob", "Kevin", "Alex", "George"].each #=> #<Enumerator: ["Bob", "Kevin", "Alex", "George"]:each>
(1..5).each                             #=> #<Enumerator: 1..5:each>
({a: 1, b: 2}).each                     #=> #<Enumerator: {:a=>1, :b=>2}:each>

# Возвращает всегда Enumerator
["Bob", "Kevin", "Alex", "George"].each { |name| name + "?" } #=> #<Enumerator: ["Bob", "Kevin", "Alex", "George"]:each>



puts '                                              map/collect'

# map/collect - итератор подставляет возвращенное блоком значение вместо каждого элемента. Используется, когда нужно что-то сделать с каждым из значений, чтобы получить новый массив.

["Bob", "Kevin", "Alex", "George"].map #=> #<Enumerator: ["Bob", "Kevin", "Alex", "George"]:map>
(1..5).map                             #=> #<Enumerator: 1..5:map>
({a: 1, b: 2}).map                     #=> #<Enumerator: {:a=>1, :b=>2}:map>

# При использовании с блоком, возвращает всегда новый массив
["Bob", "Kevin", "Alex"].map { 'Vasya' } #=> ["Vasya", "Vasya", "Vasya"]
(1..5).map { |e| e+1 }                   #=> [2, 3, 4, 5, 6]
({a: 1, b: 2}).map { |k, v| k }          #=> [:a, :b]

a = [1, 2, 3, 4, 5]
b = a.collect { |x| 10*x }
p b #=> [10, 20, 30, 40, 50]
p a #=> [1, 2, 3, 4, 5]

# Меняет каждый элемент, соотв если условие в блоке не описывает какие-то элементы, то они заменяются на nil
c = a.map { |e| e*2 if e.odd? }
p c #=> [2, nil, 6, nil, 10]



puts '                                         Комбинации итераторов'

p 3.times.map{'A'}   #=> ["A", "A", "A"]
p 3.times.map{|n| n} #=> [0, 1, 2]
p 3.times.to_a       #=> [0, 1, 2]



puts '                                          Вложенные итераторы'

arr = [ %w(a b c), %w(d e f), %w(g h i) ]
arr.each do |arr0|
  arr0.each {|el| print el}
end














#
