puts '                                              Range(Диапазоны)'

# Ruby поддерживает и позволяет нам использовать диапазоны различными способами — Диапазоны как последовательности; Диапазоны как условия; Диапазоны как интервалы

# Диапазон это один экземпляр клааса Range и в нём хранится непрерывная последовательность целых чисел, он содержит ссылки на два объекта Fixnum.

# Диапазоны чисел(только целые числа, диапазон из Float будет создан но его нельзя будет итерировать)
d1 = 1..5   #=> 1..5        # 1, 2, 3, 4, 5    # Две точки — от 1 до 5 включительно.
d2 = 1...5  #=> 1...5       # 1, 2, 3, 4       # Три точки — от 1 до 4, а 5 уже не входит в этот диапазон.
d3 = (25..) #=> 25..        # Открытый диапазон - аналог >= 25. Обязательно в скобках

# Диапазоны символов. Интерпритирует комбинации символов как цифры числа в системе исчисления заданной числом символов
d4 = "a".."c"     #=> "a".."c"         # a, b, c
d5 = "aa"..."bb"  #=> "aa"..."bb"      # aa, ab, ac, ... az, ba
d6 = "cde".."fff" #=> "cde".."fff"

# Обратный порядок в диапазоне не выдает ошибку, но не возвращает набор чисел, для обратного диапазона есть метод reverse_each
d7 = 4..1 #=> 4..1
d7.to_a #=> []


# Создание объекта диапазона требует 2 элемента
r1 = Range.new(0, 2)     #=> 0..2
r1.to_a                  #=> [0, 1, 2]
r2 = Range.new(0, 1, 2)  #=> 0...1
r2.to_a                  #=> [0]
r3 = Range.new(*[0, 2])  #=> 1..2
r3.to_a                  #=> [0, 1, 2]
r4 = Range.new(2, 1)     #=> 2..1
r4.to_a                  #=> []



puts '                                              Methods'

# Проверка попадает ли какое-либо значение в диапазон с помощью === (оператора равенства регистров).
(1..10) === 5      #=> true
('a'..'j') === 'z' #=> false

# реверс диапазона
(1..7).reverse_each.to_a #=> [7, 6, 5, 4, 3, 2, 1]

# step - задает шаг для диапазона
(2..10).step(2).to_a #=> [2, 4, 6, 8, 10]

(0..6).include?(5) #=> true  Включает ли диапазон элемент заданный параметром

(1..100).max  #=> 100
(1..100).last #=> 100
(100..1).max  #=> nil
(100..1).last #=> 1

# Преобразовать диапазон в массив, используя метод to_a
(1..10).to_a        #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
('bar'..'bat').to_a #=> ["bar", "bas", "bat"]

# Метод “each” для типа Range:
(1001..1005).each{|x| puts "Я робот #{x}"}
("10aa".."20bb").each{|x| print "#{x} "}

# Поиск находит ближайшее слева направо
(1..100).find{|n| n.digits.uniq.size == 2}



puts '                                         Метод inject/reduce'

# inject/reduce  - возвращает объект, сформированный из операндов с помощью метода, заданного символом.
(1..4).reduce(:+)        #=> 10 (1 + 2 + 3 + 4)
(1..4).reduce(:-)        #=> -8 (1 - 2 - 3 - 4)
(1..4).reduce(:*)        #=> 24 (1 * 2 * 3 * 4)

# Примеры с первым операндом (который является self.first) различных типов:
(1..4).inject(2, :+)               #=> 12                         # Integer.
(1..4).inject(2.0, :+)             #=> 12.0                       # Float.
(1..4).inject(Complex(2, 2), :+)   #=> (12+2i)                    # Complex.

# С блоком для задания дополнительных условий операции
(1..4).inject{|sum, n| sum + n*n }    #=> 30 (1*1 + 2*2 + 3*3 + 4*4)
(1..4).inject(2){|sum, n| sum + n*n } #=> 32 (2 + 1*1 + 2*2 + 3*3 + 4*4)

# Строковые значения
('a'..'d').inject(:+)            #=> "abcd"
('a'..'d').inject('foo', :+)     #=> "fooabcd"

# С методом в качестве типа орперации
('a'..'d').inject(['x'], :push)      #=> ["x", "a", "b", "c", "d"]


# Вариант когда надо и with_index и with_object
arr.each_with_index.inject({}) do |hh, (e, i)|
  hh[e] = i
  # какието действия
  hh # теперь при каждой итерации hh берется из предыдущей итерации
end

















#
