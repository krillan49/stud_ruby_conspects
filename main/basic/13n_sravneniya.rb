puts '                                         Операторы сравнения'

# https://stackoverflow.com/questions/7156955/whats-the-difference-between-equal-eql-and

# ==, ===, eql?, equal?  – 4 компаратора, т.е. 4 способа сравнить два объекта в Ruby.

# <=>  - оператор сопоставления:

# Поскольку в Ruby все компараторы (и большинство операторов) на самом деле являются вызовами методов, можно самостоятельно изменять семантику этих методов сравнения.



puts '                                               == и !='

# == - оператор "равенство" или "двойное равенство", возвращает true, если оба объекта равны, и false, если это не так.
"koan" == "koan" #=> true
"koan" == "some" #=> false

# != - оператор "неравенство", является противоположностью ==. Он вернет true, если оба объекта не равны, и false, если они равны.
"koan" != "some" #=> true
"koan" == "koan" #=> false

# Массивы с одинаковыми элементами в разном порядке не равны, прописные и строчные варианты одной и той же буквы не равны итд

# При сравнении чисел разных типов (например, целых и с плавающей запятой), если их числовое значение одинаково, == вернет true.
2 == 2.0 #=> true



puts '                               equal?(Сравнение идентичности объектов)'

# equal? - проверяет, относятся ли два операнда к одному и тому же объекту. Это самая строгая форма равенства в Ruby. Этот метод (класса BasicObject) не предполагается перезаписывать.

# Есть две строки с одинаковым значением. Однако это два разных объекта с разными идентификаторами
a, b = "zen", "zen"
a.object_id  #=> 20139460
b.object_id  #=> 19972120
a.equal? b   #=> false

# Но если b будет ссылкой на a, то id объектов одинаков для обеих переменных, поскольку они указывают на один и тот же объект.
a = "zen"
b = a
a.object_id     #=> 18637360
b.object_id     #=> 18637360
a.equal? b      #=> true
a.equal? a.dup  #=> false



puts '                                     eql? и hash(Сравнение по хэш-кодам)'

# eql? - метод в классе Hash, который используется для проверки ключей на равенство.

# В большинстве случаев eql? ведет себя аналогично методу ==. Однако есть несколько исключений. Например, eql? не выполняет неявное преобразование типов при сравнении целого числа с числом с плавающей запятой.
2 == 2.0    #=> true
2.eql? 2.0  #=> false

# Эта запись аналогична той что ниже:
"zen".eql? "zen"          #=> true
# Запись выше это тоже самое что и:
"zen".hash == "zen".hash  #=> true

# hash - встроенный метод для генерации хеш-кодов, он принимает объект и возвращает хеш-код. Объекты с одинаковым значением всегда(в рамках одной интерпритации, тоесть запуска скрипта) имеют один и тот же хеш-код, даже если они являются разными объектами (разные id).
"meditation".hash  #=> 1396080688894079547
"meditation".hash  #=> 1396080688894079547
[1, 2, 3].hash  #=> -386494181
[1, 2, 3].hash  #=> -386494181

# Метод hash реализован в модуле Kernel, включенном в класс Object, который по умолчанию является корневым для всех объектов Ruby. Некоторые классы, такие как Symbol и Integer, используют реализацию по умолчанию, другие, такие как String и Hash, предоставляют свои собственные реализации.
Symbol.instance_method(:hash).owner  #=> Kernel
Integer.instance_method(:hash).owner #=> Kernel
String.instance_method(:hash).owner  #=> String
Hash.instance_method(:hash).owner    #=> Hash

# В Ruby, когда мы сохраняем что-то в хеше (Hash/коллекции), объект, предоставленный как ключ (например, строка или символ), преобразуется и сохраняется как хеш-код. Позже, извлекая элемент из хеша (коллекции), мы предоставляем объект в качестве ключа, который преобразуется в хэш-код и сравнивается с существующими ключами. Если есть совпадение, возвращается значение соответствующего элемента. Это сравнение производится с помощью команды eql? метод под капотом.



puts '                                               ==='

# === - Сравнение регистров (регистр-равенство / тройное равенство) метод используется в разной роли в зависимости от контекста в котором он находится и классов объектов к которым применяется


# 1. Многие встроенные классы(как String, Range и Regexp), предоставляют свои собственные реализации оператора ===. В каждом классе он реализован по-разному, соответсвенно будет вести себя по-разному в зависимости от типа объекта, к которому он был вызван. Обычно он возвращает true, если объект справа «принадлежит» или «является членом» объекта слева.

# Например, его можно использовать для проверки того, является ли объект экземпляром класса (или одного из его подклассов).
String === "zen"   #=> true
Range === (1..2)   #=> true
Array === [1,2,3]  #=> true
Integer === 2      #=> true

# Целые числа являются экземплярами класса Fixnum, который является подклассом класса Integer. Методы is_a? и instance_of? возвращают true, если объект является экземпляром данного класса или каких-либо подклассов.
2.is_a? Integer        #=> true
2.kind_of? Integer     #=> true      # алиас
2.instance_of? Integer #=> true

# is_a? и kind_of? методы алиасы реализованы в модуле ядра, который добавлен в класс Object.
Kernel.instance_method(:kind_of?) == Kernel.instance_method(:is_a?) #=> true


# 2. Реализация диапазона - когда оператор === вызывается для объекта диапазона, он возвращает true, если значение справа попадает в диапазон слева. === вызывает метод === левого объекта. (1..4) === 3 эквивалентно (1..4).=== 3. Gозиции операндов не являются взаимозаменяемыми.
(1..4).=== 2.345   #=> true
(1..4) === 2.345   #=> true
(1..4) === 6       #=> false
("a".."d") === "c" #=> true
("a".."d") === "e" #=> false


# 3. Реализация регулярного выражения - возвращает true, если строка справа соответствует регулярному выражению слева.
/zen/ === "practice zazen today" #=> true
# Это то же самое, что и:
"practice zazen today" =~ /zen/


# 4. case-when условный оператор неявно использует оператор ===. Это его наиболее распространенное использование. Если бы Ruby неявно использовал оператор двойного равенства (==), то диапазон 10..20 не считался бы равным целому числу. Они совпадают, поскольку оператор тройного равенства (===) неявно используется во всех операторах case/when.
minutes = 15
case minutes
when 10..20
  "match"
else
  "no match"
end #=> match

# Код в приведенном выше примере эквивалентен:
(10..20) === minutes ? "match" : "no match" #=> match



puts '                                             =~ и !~'

# =~ (тильда равенства) и !~ (тильда-тильда) - операторы/методы сопоставления с образцом, они используются для сопоставления строк и символов с шаблонами регулярных выражений.
# =~ - когда строка или символ соответствует шаблону регулярного выражения, возвращается целое число, которое является позицией (индексом) совпадения. Если совпадений нет, возвращается nil.
# !~ - является противоположностью оператора =~: он возвращает true, если совпадений нет, и false, если совпадение есть.

# Реализация этих методов в классах String и Symbol ожидает, в качестве аргумента, регулярное выражение (экземпляр класса Regexp).
"practice zazen" =~ /zen/                #=> 11
"practice zazen" =~ /discursive thought/ #=> nil
:zazen =~ /zen/                          #=> 2
:zazen =~ /discursive thought/           #=> nil

# Реализация класса Regexp ожидает в качестве аргумента строку или символ.
/zen/ =~ "practice zazen"     #=> 11
/zen/ =~ "discursive thought" #=> nil

# в Ruby любое целочисленное значение является «истинным», а nil — «ложным», поэтому оператор =~ можно использовать в операторах if и тернарных операторах.
"yes" if "zazen" =~ /zen/       #=> yes
"zazen" =~ /zen/ ? "yes" : "no" #=> yes

# Операторы сопоставления с образцом также полезны для написания более коротких операторов if, чтобы вместо такого
true if meditation_type == "zazen" || meditation_type == "shikantaza" || meditation_type == "kinhin"
# Написать что-то такое:
true if meditation_type =~ /^(zazen|shikantaza|kinhin)$/



puts '                                            <=>'

# <=> - оператор сопоставления, возвращает 1 - если 1й параметр больше 2го, 0 - если они равны и -1, если 2й больше

2 <=> 3 #=> -1
2 <=> 2 #=> 0
4 <=> 3 #=> 1

'a' <=> 'b'   #=> -1
'aa' <=> 'aa' #=> 0
'ab' <=> 'aa' #=> 1
















#
