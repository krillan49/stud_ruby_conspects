puts '                               File I/O: Работа с файлами и каталогами'

# (! fileutils - модуль для создания фаилов и директорий - потом какнить проверить)

# File - класc отвеч за раб с фаилами.
# Dir - класс отвеч за работу с директориями

# ВАЖНО: обрабатываются в путях только такие / слэши


puts
puts '                                      Сохранение в фаил в консоли'

# работает и в досе и в юниксе. Это фича операционки а не Руби.

# >  Символ перенаправления ввода. Замещает фаил если он уже существует, так что нужно быть осторожнее
# Если у нас есть некий вывод на экран(консоль) и мы хотим сохранить его в фаил:
a = gets.strip
puts "Your word is #{a}"
# Тогда в консоли вводим(для данного фаила и расположения):
# PS E:\doc\ruby_exemples> ruby example4m.rb > fale.txt
# ruby имя_фаила.rb > fale.txt (или например fale.html)
# В итоге создается txt фаил содержащий результат вывода в консоли фаила example4m.rb

# >>  Другой оператор перенаправления ввода. Не замещает фаил, а просто дописывает в конец уже существующего фаила.


puts
puts '                              File создание/чтение фаила. File.new и File.open'

# File.open и File.new - методы открытия/создания фаила. File.open может быть связан с блоком, а File.new не может.

# Режимы открытия/создания фаила( не совсем полная инфа ?? ):
# r	  (read) Открытие файла лишь для чтения. Курсор помещается в начало файла перед первым символом.
# r+  Открытие файла для чтения и записи. Курсор помещается в начало файла перед первым символом.
# w   (write) Открытие файла лишь для записи. Файл будет полностью перезаписан новой информацией. Если файла нет, то он будет создан.
# w+	Открытие файла для записи и чтения. Файл будет полностью перезаписан новой информацией. Если файла нет, то он будет создан.
# a   (append - добавить) Только запись в файл. Курсор будет поставлен в конце файла, если файл существует, в противном случае создается новый файл для записи. Данные записываются в конец фаила, после последнего символа либо с новой строки, если текстовый фаил сохранен с новой пустой строкой
# a+	Запись и чтение из файла. Курсор будет поставлен в конце файла, если файл существует, в противном случае создается новый файл для записи.
# b	  Режим двоичного файла (может использоваться с любой из перечисленных команд).
# t	  Режим текстового файла (может использоваться с любой из перечисленных команд, кроме «b»).


# 1. File.new - создать/открыть объект File, используя метод .new, для чтения, записи или того и другого, в зависимости от строки режима.
file = File.new("./text/simple.txt", "r")
puts file.read #=> содержание фаила
file.close # метод чтобы закрыть этот файл.


# 2. File.open - метод для созжания/открытия фаилов, 1й параметр внутри которого указывает на необходимый фаил, а второй - режим в котором мы хотим войти.

# a. Чтение фаила без блока, с присвоением объекта фаила в переменную
input = File.open("./text/simple.txt", "r") # название переменной любое не обяз input
puts input.read
input.close # Закрытие файла для этого способа производится методом close

# б. Чтение фаила с блоком
File.open("./text/simple.txt", "r") do |file| # в переменную file присвоится указанный фаил.
  puts file #=> #<File:0x0000016a90a9bb08>  # метаданные объекта
  puts file.read # read - метод выдаст содержание фаила в формате строки
  p file.read #=> ""  # Почемуто второе применение чтения фаила выдает пустую строку
  puts file.read.include?("Перед") # При помощи read мы получаем строку, с которой можем проделывать все строковые операции
  p file.readline # readline читает фаил построчно в формате строки. так же (не работает после read ??)
  p file.readline #=> "\n" при повторении читает следующую(2ю) строку(В нашем тексте она пустая)
  p file.readchar # читает 1й символ, 2й readchar прочитает след символ. После readline читает первый символ следующей строки.
  p file.readlines #=> массив элементы которого строки фаила

  # Так же мы можем пользоваться циклами:
  for line in file.readlines
    puts line # Получается построчная прочитывание всего фаила
  end # начало читать со 2го символа 3й строки, тк предыдущ операции учлись.
end


puts
puts '                                            Запись в фаил'

# Запись в фаил без блока в режиме w
output = File.open("./text/simple.txt", "w")
output.write "Something"  # оператор write записывает в фаил строку "Something"
output.close

# a (append) Запись в фаил с блоком
File.open("./text/simple.txt", "a") do |file|
  file.write("\nTEST записи") # метод для записи, можно пользоваться \n, чтоб записывалось с новой строки
end # Если повторить запуск, то запишется еще раз, после посл символа. После запусков и записи фаил автоматически сохраняется

# w (write) Запись в фаил с блоком
File.open("./text/simple2.txt", "w") do |file| # Перезаписывает фаил, либо создает новый, если такого нет
  file.write("TEST записи")
end


puts
# Запись в фаил помощи одного метода write(любые методы записи). Создаст новый фаил если такого нет
filename = "SOME_#{Time.now.strftime('%Y-%m-%d_%H-%M-%S')}.txt" # имя(относительный путь) для фаила уникальное при помощи даты
File.write(
  filename,              # имя(относительный путь) фаила
  "Текст для записи\n",  # собственно текст для записи
  mode: 'a'              # опция для типа записи (тут открыть файл только для записи и дописывать в конец фаила)
)


puts
puts '                               Альтернативный способ чтения и записи(file.gets)'

# Чтение фаила строка за строкой
input = File.open "./text/simple.txt", "r"
p input.gets #=> file.gets читает строку из файлового объекта file(просто gets читает строку из стандартного ввода)
while (line = input.gets) # пока строка присудствует в фаиле на который ссылается переменная(?)
  puts line
end
input.close


# Пример: подсчет суммы числел в фаиле вида "200, cats\n100, dogs\n"
input = File.open "list.txt", "r"
n = 1
sum = 0
while (line = input.gets)
	puts "#{n} #{line}"
	sum += line.split(',')[1].to_i
	n += 1
end
puts "\nTotal sum = #{sum}"
input.close


# Пример 2: выборка из фаила и запись в другой фаил
input = File.open("passwords.txt", "r")
arr = []
while (line = input.gets)
  arr << line if line.chomp.size == 6
end
input.close

output = File.open("pass_output.txt", "w")
arr.each do |str|
  output.write(str)
end
output.close


# Другие примеры в Lessons18.rb


puts
puts '                                      Методы работы с фаилами(File)'

# Работа со строкой пути фаила
file = "./text/simple2.txt"
File.basename(file)                  #=> "simple2.txt"
File.basename(file,".txt")           #=> "simple2" # 2й аргумент удаляет расширение
File.extname(file)                   #=> ".txt"
File.dirname("/var/www/test.txt")    #=> /var/www  # Получение директории без имени файла
File.rename 'file1.ext', 'file2.ext' # Переиминовывает file1 в file2
File.delete("tekst2.txt")            # удаления существующего файла tekst2.txt

# IO.each_line. метод читает фаил построчно выгружая из памяти уже прочитанные строки, что позволяет экономить память при работе с большими фамлами
File.new('passwords.txt').each do |line|
  password = line.chomp
  p password.size
end

# sysread(метод системного чтения) - для чтения файла с возможностью указать колличество читаемых символов. Можно открыть файл в любом из режимов
file = File.new("./text/simple.txt", "r")
puts file.sysread(20) # выведет первые 20 символов файла. Указатель файла теперь будет размещен на 21-м
#=> "Работа с фа"    # ? Почему-то не 20 а меньше, мб изза русского алфавита

# syswrite(метод системной записи). Нужно открыть файл в режиме записи при использовании метода syswrite
file = File.new("ruby_exemples/text/simple2.txt", "r+")
file.syswrite("ABCDEF")


puts
puts '                                     Права доступа к фаилу в Linux'

# chmod - команда линукса(а так же мак и андроид) для смены прав доступа к фаилу.

File.chmod 765 # команда Руби меняющая права доступа в фаилы

# $ chmod 765 file1.rb
# где значение 765 это новые параметры доступа к фаилу file1.rb

# Цифры параметра/прав доступа(например 765):
# 1я цифра - права доступа для owner(владелец фаила)
# 2я цифра - права доступа для group(группа)
# 3я цифра - права доступа для всех остальных
# Значения каждой из 3х цифр может быть от 0 до 7

# Каждая цифра в параметрах доступа означет 3хзначное двоичное число:
# 000 = 0, 001 = 1, 010 = 2, 011 = 3, 100 = 4, 101 = 5, 110 = 6, 111 = 7.
# где цифры 2ичного числа обозначают "rwx" (1я цифра - "r", 2я - "w", 3я - "x"), те r - четверки, w - двойки, x - единицы
# r - (read) возможность прочитать/открыть фаил
# w - (write) возможность записать/изменить в фаил
# x - (exequte) возможность запустить/исполнить фаил
# Каждое из этих свойств может быть включено или отключено - всего комбинаций 8(2**3)
# 1 в соотв положении значит включен режим, 0 - выключен.

# Соответсвенно 765 == (111 110 101) == (rwx rw- r-x) Тоесть владелец имеет полный доступ, группа не может исполнять, а остальные записать


puts
puts '                                          Методы класса IO'

# Класс File является подклассом класса IO. Класс IO также имеет несколько методов, которые можно использовать для управления файлами.

# IO.readlines . Этот метод возвращает содержимое файла построчно в виде массива
arr = IO.readlines("./text/simple.txt")
arr[0] #=> "Работа с файлами это распространенная вещь в программировании. Нам постоянно ... "

# IO.foreach. Этот метод также возвращает вывод построчно, но метод foreach связан с блоком и не возвращает массив.
IO.foreach("./text/simple.txt"){|line| puts line}


puts
puts '                                           Фаиловые запросы'

# File::exists? проверяет, существует ли файл перед его открытием:
File.open("file.rb") if File::exists?("file.rb")

# выясняет, действительно ли файл является файлом
File.file?( "ruby_exemples/text/simple.txt" ) #=> true

# определяет, является ли данное имя файла каталогом
File::directory?( "/usr/local/bin" ) # => true
File::directory?( "file.rb" ) # => false

# доступен ли файл для чтения, записи или исполняемого файла
File.readable?( "test.txt" )   # => true
File.writable?( "test.txt" )   # => true
File.executable?( "test.txt" ) # => false

# имеет ли файл нулевой размер или нет
File.zero?( "test.txt" )      # => true
# возвращает размер файла(??)
File.size?( "text.txt" )     # => 1002

# определяет тип файла, возвращая одно из следующих значений: file, directory, characterSpecial, blockSpecial, fifo, link, socket, or unknown.
File::ftype( "test.txt" )     # => file

# определения времени создания, изменения или последнего доступа к файлу
File::ctime( "test.txt" ) # => Fri May 09 10:06:37 -0700 2008
File::mtime( "text.txt" ) # => Fri May 09 10:44:44 -0700 2008
File::atime( "text.txt" ) # => Fri May 09 10:45:01 -0700 2008


puts
puts '                                              Dir Каталоги'

# Все файлы находятся в разных каталогах, каталоги обрабатываются классом Dir .

# вернуть текущую директорию
Dir.pwd #=> E:/doc

# Изменение относительного(текущего каталога) пути/сменить директорию(можно указать полный путь)
Dir.chdir "C:/Projects" # процесс, все его действия в файловой системе происходят относительно какого то места, оно и называется текущим каталогом после запуска обычно оно равно местоположению программы, а chdir позволяет его сменить. Удобно использовать как в коде так и в irb
# Пример с неполным путем: будет изменение на текущий относительный + новый
puts Dir.pwd #=> E:/doc
Dir.chdir("new_dir")
puts Dir.pwd #=> E:/doc/new_dir

# Все фаилы директории в виде массива(к которому можно будет применить методы массивов)
p Dir.entries "E:/doc" #=> [".", "..", "pic", "ruby_exemples", "Гайд шатдаун DOXAхРоскомсвобода 27.02.2022.pdf", "ГВД", "з.txt", "мма", "паспорт", "покер", "текст", "учеба"]
# Особенности: "E:"(без слэша) == "E:/doc"
p Dir.entries "E:/" #=> ["$RECYCLE.BIN", "doc", "games", "msdownld.tmp", "programs", "System Volume Information", "Безымянный.jpg", "видео", "загрузки", "музыка"]
p Dir.entries "E:" #=> [".", "..", "pic", "ruby_exemples", "Гайд шатдаун DOXAхРоскомсвобода 27.02.2022.pdf", "ГВД", "з.txt", "мма", "паспорт", "покер", "текст", "учеба"]
# Все фаилы директории за исключением "." и ".."
p Dir.children("E:") #=> ["pic", "ruby_exemples", "Гайд шатдаун DOXAхРоскомсвобода 27.02.2022.pdf", "ГВД", "з.txt", "мма", "паспорт", "покер", "текст", "учеба"]

# Создаем новую директорию
Dir.mkdir("new_dir")

# Удаляем директорию, директория должна быть пустой (не иметь файлов или других директорий в ней)
Dir.delete("new_dir")

# Проверяем пустая ли директория
Dir.empty?("new_dir")

# Итерация по папке с получением имен файлов и директорий в заданной папке (., .. - в элементах это норма, это указатели текущей и корневой директорий). Во вложенных директориях файлы показаны не будут (не рекурсивно).
Dir.foreach("test_dir") do |entry|
  puts entry
end

# Тоже самое что выше, но умеет работать рекурсивно и фильтровать выборку.
contents = Dir.glob("**/*") # ** - рекурсия, * - условия выборки aka wildcard (* - никаких, *.txt - только .txt)
contents.each do |entry|
  puts entry
end

# Поиск фаила(пути к фаилу) по полному имени с расширением
p Dir.glob('E:/**/Heather Locklear.jpeg') #=> ["E:/doc/pic/pictures/неон/Heather Locklear.jpeg"]
Dir.glob('E:/**/*/Heather Locklear.jpeg') #=> ["E:/doc/pic/pictures/неон/Heather Locklear.jpeg"]
# поиск по части имени не обязательно расширение
p Dir.glob('E:/**/*Locklear*') #=> ["E:/doc/pic/pictures/неон/Heather Locklear.jpeg"]
# Поиск фаилов по расширению
p Dir.glob('E:/**/*.jpg') #=> ["E:/$RECYCLE.BIN/S-1-5-21-1390554581-1841657848-2307281156-1001/$IRVMUGP.JPG", "E:/doc/pic/foto/фотки/2002-2011/2002 общага 49я/x_45bc2ccf.jpg", "E:/doc/pic/foto/фотки/2002-2011/2002 общага 49я/x_52b287d7.jpg", "E:/doc/pic/foto/фотки/2002-2011/2002 общага 49я/x_8e5a3fe1.jpg", ... и так далее все фаилы на диске с таким расширением

# Вариант 2 "в ручную" при помощи рекурсии
@dir=nil
def filefinder_e(failname, dir)
  return @dir if @dir # возвращаемся если фаил найден
  Dir.chdir(dir) # меняем директорию на заданную
  start_dir=Dir.pwd # начальная директория данного этапа рекурсии
  fold=Dir.children(Dir.pwd) # массив элементов директории
  if fold.find{|e| e==failname} # проверяем есть ли в ней искомый фаил
    @dir=Dir.pwd # если есть присваиваем путь в переменную
    return @dir
  end
  dirs=fold.select{|e| File::directory?(e)} # выбираем среди элементов директории
  dirs.each do |d|
    filefinder_e(failname, Dir.pwd+"/#{d}") # рекурсия - применяем метод к поддиректориям
    Dir.chdir(start_dir) # если не найдено меняем директорию на изначальную для этого этапа рекурсии
  end
  @dir ? @dir : 'не найдено'
end
filefinder_e('Heather Locklear.jpeg', 'E:/doc/pic') #=> "E:/doc/pic/pictures/неон"


puts
puts '                                   Создание временных файлов и каталогов'

# Временные файлы — это файлы, которые могут создаваться на короткое время во время выполнения программы, но не являются постоянным хранилищем информации.

Dir.tmpdir #предоставляет путь к временному каталогу в текущей системе, хотя по умолчанию этот метод недоступен. Чтобы сделать Dir.tmpdir доступным, необходимо использовать require 'tmpdir'.
# Можно использовать Dir.tmpdir с File.join для создания независимого от платформы временного файла —
require 'tmpdir'
tempfilename = File.join(Dir.tmpdir, "tingtong")
tempfile = File.new(tempfilename, "w")
tempfile.puts "This is a temporary file"
tempfile.close
File.delete(tempfilename)
# Этот код создает временный файл, записывает в него данные и удаляет его.

# Стандартная библиотека Ruby также включает библиотеку Tempfile , которая может создавать для вас временные файлы —
require 'tempfile'
f = Tempfile.new('tingtong')
f.puts "Hello"
puts f.path
f.close
