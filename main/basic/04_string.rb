puts '                                             Строки(String)'

#"ABCDEFGHIJKLMNOPQRSTUVWXYZ"  "abcdefghijklmnopqrstuvwxyz"

# Строка — изменяемый массив(последовательность) байтов, представляющий символы в кодировке UTF-8. Реализуются классом String.

# Пример изменения кодировки с заменой неподходящих символов
"abcΣΣΣ".encode("ASCII", "UTF-8", invalid: :replace, undef: :replace, replace: "") # "abc"



puts '                                     Типы ограничителей и их свойства'

# Если строка ограничена апострофами, внутри неё распознаются только специальные последовательности «\\» и «\’», обозначающие соответственно, обратный слэш и апостроф.
puts 'Строка с табуляцией "\t" и символом переноса \'\n\'' #=> Строка с табуляцией "\t" и символом переноса '\n'

# Если строка ограничена двойными кавычками, то в ней распознаются также управляющие символы «\t» (знак табуляции), «\n» (перенос строки), «\010» (любой символ в восьмеричной кодировке) и другие.
puts "Строка с табуляцией \"\\t\" и символом переноса '\\n'" #=> Строка с табуляцией "\t" и символом переноса '\n'

# Ограничители %q[…] или %Q[…] (можно использовать круглые, квадратные, фигурные, угловые скобки и другие символы) позволяют записывать строки с использованием апострофов и кавычек без экранирования. Форма %q[…] также обеспечивает непосредственный вывод управляющих последовательностей:
puts %q[Строка с табуляцией "\t" и символом переноса '\n'] #=> Строка с табуляцией "\t" и символом переноса '\n'

# Для вывода многострочного текста имеется ещё одна форма представления строк:
puts <<EOF
В этом тексте
  всё, включая переводы строк,
         кавычки и отступы,
    будет выведено "как есть".
EOF
# Вместо «EOF» может использоваться любое слово или число, важно, чтобы финальный ограничитель был написан с начала строки и за ним непосредственно следовал перевод строки. В многострочных текстах работает вывод спецсимволов, как и в строках, ограниченных двойными кавычками.
# Учитывает все пространство слева, в том числе и табуляции с пробелами от метода, когда вложено например в метод

# разбить длинную строку можно указав обратный слэш(отменяет перевод новой строкой(аналог ; в Руби)):
p ' строка1 -' \
' строка2 ' #=> " строка1 - строка2 "



puts '                                      Создание новой строки'

myStr = String.new("THIS IS TEST")

# Упрощенное создание строки
words = "чето там про фигню"
words2 = "    иЛи пРо иХ оТсУдСтВиЕ\n" # \n - Перенос строки в выводе(puts)



puts '                                        Строковые операции'

# + оператор осуществляет конкатенацию строк
"aaa" + "bbb" #=> aaabbb
# Для конкатенаци строки и переменной/числа, нужно перевести их в тип данных строка через .to_s
"результат остатка от деления 11 на 5 равен: " + (11 % 5).to_s #=> результат остатка от деления 11 на 5 равен: 11


# += и << - складывают строки мутируя изначальную строку
str = 'A'
str += 'B'
p str #=> "AB"
str << 'B'
p str #=> "ABB"


# String * Integer - строку умножаем на число. Наоборот число на строку выйдет ошибка, тк это не операция умножения, а это оператор * для типа данных String, для мультипликации строки.
"abc" * 3 #=> abcabcabc
'=' * 10 #=> ==========


# == Сравнение строк
"aaa" == "aaa" #=> true
"aaa" == "bbb" #=> false


# Изменение символа строки по индексу(Строки в Руби мутируемы):
a = "abcdefg"
a[3] = 'R'    #=> "abcRefg"

# Выделение части строки дапазоном индексов символов строки:
text = "vasya"
text[0..1] #=> "va"

# Особенности присвоения значений переменным:
a = "abcdefg" # => "abcdefg" - переменная a инициализирована новой строкой.
b = a         # => "abcdefg" - переменная b получает ссылку на ТУ ЖЕ строку.
a[3] = 'R'    # => "abcRefg" - строка, присвоенная a, изменяется.
b             # => "abcRefg" - при изменении a неявно изменилось и b, так как они ссылаются на ОДИН объект.



puts '                                        Интерполяция строк'

# 1. Интерполяция переменных c символьными префиксами #имя_переменной. Не имнтерполирует выражения
$global, CONST, @instanse, local = 10, 9, 8, 7
"This is #$global #CONST #@instanse #local"  #=> "This is 10 #CONST 8 #local"
# Не работает с одинарными кавычками
'This is #$global #CONST #@instanse #local' #=> "This is \#$global #CONST \#@instanse #local"


puts
# 2. Интерполяция выражений #{...}. Можно встраивать в строку выражения, условия математические действия итд.
# Интерполяция строк производится при помощи управляющих символов #{...} внутри строки.
"The area is #{3.141592653}." #=> "The area is 3.141592653."

# Инетрполяция строк и специальные символы не работает в одинарных кавычках(''), а работает только в двойных("")
text = 'Kroker'
'Hi #{text} bay' #=> "Hi \#{text} bay"
"hi #{text} bay" #=> "hi Kroker bay"

# если в строке встречается конструкция #{ }, то сначала всё, что находится внутри фигурных скобок, вычисляется интерпретатором, преобразуется в строковый формат и помещается в данное место создаваемой строки.
puts "Осталось #{i} секунд#{case i
                            when 2..4 then "ы"
                            when 1 then "а"
                            else ""
                            end }..."
# при использовании вставки всё, что находится внутри фигурных скобок, является обычным ruby-кодом, в частности, там не требуется экранирование кавычек.

#Примеры интерполяции
"#{arr[0][n] ? arr[0][n] : ' '} #{arr[1][n] ? arr[1][n] : ' '}\n"
"#{str_1[i] || ' '} #{str_2[i] || ' '}"



puts '                                               Методы'

# Информационные методы
"Хуb рыGaeb".length            #=> 10    # длинна/коллич символов в строке, учитывает и пробелы
"Хуb рыGaeb".count("eb")       #=> 3     # Считает число заданных символов(в данном случае 3(2 - b и 1 - e))
"Хуb рыGaeb".include?("ыGa")   #=> true  # Оператор для поиска символов
"Хуb рыGaeb".start_with?("Ху") #=> true  # Проверяет начинается ли строка с заданной подстроки
"Хуb рыGaeb".empty?            #=> false # Проверяет пустая строка или нет

# Методы изменения регистра
'vaSYa'.upcase     #=> "VASYA"
'vaSYa'.downcase   #=> "vasya"
'vaSYa'.swapcase   #=> "VAsyA"
'vaSYa'.capitalize #=> "Vasya"

# Методы изменения строки
" \n текст с пробелами \r".strip #=> "текст с пробелами" # убирает все пробелы(' ','\n','\t' итд) в начале и конце строки
"Хуb рыGaeb".chop!               #=> "Хуb рыGae"         # для удаления последнего символа в строке
'stressed'.reverse               #=> "desserts"
"Хуb рыGaeb".delete("ХG")        #=> "уb рыaeb"          # для удаления символов(не обязательно стоящих подряд)
'stressed,,  ff'.squeeze         #=> "stresed, f"        # убирает элементы повторяющиеся подряд
'stressed,,  ff'.squeeze("m-z")  #=> "stresed,,  ff"     # уберает только повторяющиеся символы из диапазона

# Методы итерации/разбиения строки
"hello\nworld\n".lines           #=> ["hello\n", "world\n"]
'hello'.each_char { |x| puts x } #=> итерация для string
'hello'.chars                    #=> ["h", "e", "l", "l", "o"]  # Это сокращение для str.each_char.to_a.

" Abf  b G ".split(/ /)              #=> ["", "Abf", "", "b", "G"]
" Abf  b G ".split(/ /,-1)           #=> ["", "Abf", "", "b", "G", ""]    # Сохранение пробела в конце
"0 9026315 -827&()".split(/[^0-9]/)  #=> ["0", "9026315", "", "827"]

# Разбивка вокруг заданного элемента
'abcPgty'.partition('P') #=> ["abc", "P", "gty"]

# Срезы, альтернатива [...]
str = "Хуb рыGaeb";
str.slice! "рыG"         #=> "рыG"
str                      #=> "Хуb aeb"
"Хуb рыGaeb".slice(1)    #=> "у"
"Хуb рыGaeb".slice(1, 2) #=> "уb"
"Хуb рыGaeb".slice(1..2) #=> "уb"

# scan Вырезать из строки
'f0ff8ff'.scan('ff')        #=> ["ff", "ff"]
'stressed'.scan(/.../)      #=> ["str", "ess"] #разбивка по числу символов(число точек)
'stressed'.scan(/e.s/)      #=> ["ess"]  # Вырезать строки по части их символов
'stressed'.scan(/#{'e.s'}/) #=> ["ess"]  # для переменной


# Побуквенная замена(по соотв индексам в аргументах)
"hello".tr('el', 'ip')              #=> "hippo"  Замена символо e на i и символа l на p
"hello".tr('a-k', '')               #=> llo
"hello".tr('aeiou', '*')            #=> "h*ll*"
"1 _heKKl+lo".tr('^a-z0-9_', '')    #=> "1_hello"
'abz'.tr('a-yz', 'b-za')            #=> "bca"
'AabBzZ'.tr('a-yzA-YZ', 'b-zaB-ZA') #=> "BbcCaA"
a.tr("^#{b}", '')                   # Общие символы 2х строк

# Замена заданной подстроки на заданную подстроку
"heelloel".gsub(/el/, '+-89') #=> "he+-89lo+-89"


# буквенный счет(например для номеров колонок в xl)
'aa'.succ # => "ab"
'az'.succ # => "ba"

'122.99.9.99.999'.next #=> "123.00.0.00.000"


eval("{:a=>1, :b=>2, :c=>3}") #=> {:a=>1, :b=>2, :c=>3}
eval("{:a=>1, :b=>2, :c=>3}").class #=> Hash
arr = eval("[1,[2,[3]]]") #=> [1, [2, [3]]]
arr.class #=> Array

# Возвращает целочисленный порядковый номер односимвольной строки.(англ буквы с 97)
'A'.ord #=> 65
'Z'.ord #=> 90
'a'.ord #=> 97
'z'.ord #=> 122
'0'.ord #=> 48
'9'.ord #=> 57
"abc".bytes #=> [97, 98, 99]
"hel".sum #=> 313  #('h.ord' + 'e'.ord + 'l'.ord)

97.chr #=> "a" вывести символ по его закодированному номеру



puts '                                              Разное'

# субпатерны строки
#https://www.codewars.com/kata/5a4a2973d8e14586c700000a/solutions/ruby
#https://www.codewars.com/kata/5a4a391ad8e145cdee0000c4/solutions/ruby
#https://www.codewars.com/kata/5a49f074b3bfa89b4c00002b/solutions/ruby

@nums = %w[zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen]

# Обязательно 2 знака нуля после запятой:
"#{'%.2f' % 1}" #=> "1.00"


puts
# сопоставление текста на общие элементы(поиск наиболее похожнго)
require "rubygems/text"
def find_most_similar(word)
  @words.sort_by{|w| levenshtein_distance(word, w)}.first
end

















#
