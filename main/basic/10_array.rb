puts '                                           Array (Массивы)'

# Массивы используются для представления последовательности данных, элементов идущих по-порядку

# Массивы Ruby представляют собой упорядоченные коллекции(наборы) объектов любого типа с целочисленным индексом. Каждый элемент массива связан с индексом и ссылается на него. Сам массив как и все в Руби объект.



puts '                                      Создание/инициализация массивов'

# Через метод Array.new
Array.new #=> []
# При инициализации этим способом, можно передать параметры при инициализации, задав число изначальных элементов и сами элементы или блок их создающий
Array.new(10)        #=> [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil]
Array.new(10, 1)     #=> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Array.new(10){|i| i} #=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # блок по умолчанию принимает индексы

# Через другие Array конструкции
Array.[]   #=> []
Array[]    #=> []
Array.[]() #=> []
# Создать пустой массив не получится так: Array[]() или Array.() или Array()]
Array[3, 5, 9, true, "Сися", 6.25] #=> [3, 5, 9, true, "Сися", 6.25]
Array.[](1, 2, 3, 4, 5)            #=> [1, 2, 3, 4, 5]
Array(0..9)                        #=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# Создать заполненный массив не получится так Array.[3, 5, 9, true, "Сися", 6.25]

# Сокращенный способ через []:
[]           #=> []
[1, 3, "rr"] #=> [1, 3, "rr"]

# Через присвоение нескольких значений в 1 переменную
arr = :a, "b", 3
arr #=> [:a, "b", 3]

# Специальный синтаксис для массивов строк(%w) и символов() без необходимости написания кавычек и двоеточий
%w[Roman 32 Mike]           #=> ["Roman", "32", "Mike"]
%w(one two three four five) #=> ["one", "two", "three", "four", "five"]
%i[en ru ua]                #=> [:en, :ru, :ua]
%i(pzdc dungeon)            #=> [:pzdc, :dungeon]

# Создание через eval
arr = eval("[1,[2,[3]]]") #=> [1, [2, [3]]]
arr.class #=> Array



puts '                                        Индексы, срезы, методы выборки'

names = ["Гонзик", "Влаженка", "Крокер", 1, 5, 100]

# Индексы в массивах начинают свой счет слева-напаво с нуля. Выход за пределы массива возвращает nil
names[0] #=> "Гонзик"
names[1] #=> "Влаженка"
names[2] #=> "Крокер"
names[9] #=> nil

# Индексы в массивах можно брать и справа-налево, тогда отсчет начинаются с минус единицы
names[-1] #=> 100
names[-2] #=> 5

# Срезы с указанием индекса начала(1й параметр) и числа элементов в срезе (2й параметр). Если число элементов превышено вернет весь массив
names[1, 3]   #=> ["Влаженка", "Крокер", 1]
names[1, 50]  #=> ["Влаженка", "Крокер", 1, 5, 100]
names[-3, 2]  #=> [1, 5]

# Срезы с указанием диапазона в качестве параметра, 1й элемент будет индексом начала, а второй индексом конца среза включительно. Если индекс конца выйдет за границы массива то вернет массив целиком. Можно использовать открытые диапазоны и отрицательные индексы
names[0..3]   #=> ["Гонзик", "Влаженка", "Крокер", 1]
names[0...3]  #=> ["Гонзик", "Влаженка", "Крокер"]
names[1..1]   #=> ["Влаженка"]
names[1...1]  #=> []
names[1..100] #=> ["Влаженка", "Крокер", 1, 5, 100]
names[1..]    #=> ["Влаженка", "Крокер", 1, 5, 100]
names[1...]   #=> ["Влаженка", "Крокер", 1, 5, 100]
names[..3]    #=> ["Гонзик", "Влаженка", "Крокер", 1]
names[-3..-1] #=> [1, 5, 100]
names[-3..]   #=> [1, 5, 100]
names[..-3]   #=> ["Гонзик", "Влаженка", "Крокер", 1]

# Тк срез возвращает новый массив то можно обращаться к его индексам или применять к нему срезы
names[1..4]       #=> ["Влаженка", "Крокер", 1, 5]
names[1..4][1]    #=> Крокер
names[1..4][1..2] #=> ["Крокер", 1]

# Примеры применения срезов и индесов
names[-1] + 10 + names[-2]  #=> 115    # операции с эементами массивов
names[0..2][rand(0..2)]     # возвращает случайный элемент среза
names[rand(0...names.size)] # возвращает случайный элемент массива

# first/take - ищзвращает элементы из начала(сам массив не изменяется)
[11, 22, 33, 44, 55].first(2) #=> [11, 22]
[11, 22, 33, 44, 55].take(2) #=> [11, 22]

# last - ищзвращает элементы из конца(сам массив не изменяется)
[11, 22, 33, 44, 55].last(2) #=> [44, 55]

# drop - возвращает элементы в колличестве заданном параметорм из начала массива и возвращает новый массив без них. Не изменяет исходный массив
[1, 2, 3, 4, 5, 6].drop(2) #=> [3, 4, 5, 6]

# sample - возвращает один или несколько случайных элементов массива
[:right, :left, :up, :down].sample    #=> :right
[:right, :left, :up, :down].sample(2) #=> [:right, :down]

# uniq - выбирает не повторяющиеся(исключает повторяющиеся) элементы массива
[1, 1, 3, 1, 3].uniq #=> [1, 3]

# detect/find Ищет первое совпадение слева
[1, 2, 3, 4, 5].find{|e| e == 2} #=> 2

# fetch - ищет элемент по индексу если такого нет то выдает default_value
[11, 22, 33, 44, 55].fetch(2, 'такого индекса нет') #=> 33
[11, 22, 33, 44, 55].fetch(5, 'такого индекса нет') #=> "такого индекса нет"

# grep - фильтрует по различным типам параметров: константе класса, диапазону, регулярке
[0, 3.3, 5, 'ff', 7].grep(Integer)                #=> [0, 5, 7]
[4,5,8,9,4,5,1,3,6].grep((3...7))                 #=> [4, 5, 4, 5, 3, 6]
['abcde', 'adeab', 'abdgse', 'bdefa'].grep(/^ab/) #=> ["abcde", "abdgse"]



puts '                              Добавление и изменение элементов массива'

list = Array.new

# Добавление элементов в массив по индексам при помощи [i]=:
list[0] = 29
list[2] = 90
# Недостающие элементы перед заданными, автоматически заполняютмя значением nil (nil - это null object/нулевой объект)
list #=> [29, nil, 90]

# Переназначение элементов по индексу
list[0] = "Сдох"
list #=> ["Сдох", nil, 90]

# Изменение элемента по индексу методом с !
list[0].upcase!
list #=> ["СДОХ", nil, 90

# Метод << модифицирует(деструктивно) исходный массив. Добавляет элемент в конец массива после последнего элемента
list << "ggg"
list << 'one' << 'two'
list #=> ["СДОХ", nil, 90, "ggg", "one", "two"]


# push - модифицирует(деструктивно) исходный массив. Добавляет элемент в конец массива после последнего элемента. возвращает self
[1, 2, 3].push(5, 'fuu', :a) #=> [1, 2, 3, 5, "fuu", :a]

# unshift - добавляет элемент в начало массива
[1, 2, 3].unshift('a', :b) #=> ["a", :b, 1, 2, 3]

# insert  -  Вставляет заданные объекты с заданным смещением; не заменяет элементы. Вставляет заданные объекты до или после элемента со смещением целочисленного индекса; возвращает self. Когда индекс неотрицателен, вставляет все заданные объекты перед элементом со смещенным индексом:
[1, 2, 3].insert(1, :bat, :bam) #=> [1, :bat, :bam, 2, 3]

# Срез со вставкой (присвоение массива вместо срезанных элементов)
arr = [1, 2, 3, 4, 3]
arr[1..3] = [7, 7]
p arr #=> [1, 7, 7, 3]



puts                                      'Удаление элементов массива'

# pop - удаляет и возвращает 1 или несколько элементов из конца массива. Изменяет массив
arr = [1, 2, 3, 4, 5, 6]
arr.pop    #=> 6
arr        #=> [1, 2, 3, 4, 5]
arr.pop(2) #=> [4, 5]
arr        #=> [1, 2, 3]

# shift - удаляет и возвращает 1 или несколько элементов из начала массива. Изменяет массив
arr = [1, 2, 3, 4, 5, 6]
arr.shift    #=> 1
arr          #=> [2, 3, 4, 5, 6]
arr.shift(2) #=> [2, 3]
arr          #=> [4, 5, 6]

# Удаление из массивов по индексу. Изменяет массив. Возвращает удаленный элемент
list4 = [:a, :b, :c, :d]
list4.delete_at 1 #=> b
list4             #=> [:a, :c, :d]

# Удаление из массивов по элементу. Изменяет массив. Возвращает удаленный элемент
list5 = [:a, :b, :c, :d]
list5.delete :c  #=> c
list5            #=> [:a, :b, :d]



puts '                                       Операции над массивами'

# сложение массивов
mas1 = [1, 2, 3, 5, 5]
mas2 = [4, 5]
mas1 + mas2 #=> [1, 2, 3, 5, 5, 4, 5]

# вычитание массивов - вычитаются все элементы что вхлдят во 2й массив  в том числе и дубликаты
mas1 - mas2 #=> [1, 2, 3]

# сравнение массивов по последовательным членам(ранние важнее поздних)
mas1 <=> mas2 # -1   # массив 1 меньше потому что его 1й член меньше первого члена второго массива

# *   - превращает массив или диапазон в последовательность аргументов
list = [1, 2]
[0, 0, *list, 0, 0] #=> [0, 0, 1, 2, 0, 0]

# заполнение массива массивами или диапазонами
[*1..10]                                #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[*('a'..'c'), *('D'..'F'), *('4'..'7')] #=> ["a", "b", "c", "D", "E", "F", "4", "5", "6", "7"]
# Разбивка и вырезка позволяющая избегать ошибок сложения при некорректных индексах
arr = ["a", "b", "c", "d", "e", "f", "g", "h"]
[*arr[0...2], *arr[2...5].reverse, *arr[5..-1]] #=> ["a", "b", "e", "d", "c", "f", "g", "h"]

[1, 2, 3].to_s #=> "[1, 2, 3]"

# при вводе с puts элементы массива будут выводиться в столбик, а через print уже будут выведены в строку
print(names[1, 2],"\n") #=> ["Влаженка", "Крокер"]



puts '                              Копирование массива(контринтуитивный момент)'

# Невозможно сделать копию массива, переназначив его в новую переменную, тк это просто будет та же ячейка памяти которую вызывают несколько переменных и соответсвенно тот же объект-массив.

# Массив - изменяемый объект сам по себе, соответственно, при изменении значения переменной Руби не создает новый массив, а изменяет старый:
arr1 = [1, 1, 1, 1]
arr2 = arr1
arr2[0] = 'A'
[arr1, arr2] #=> [["A", 1, 1, 1], ["A", 1, 1, 1]]

# Дла копирования нужно использовать дополнительные методы, например clone или dup
arr1 = [1, 1, 1, 1]
arr2 = arr1.clone
arr3 = arr1.dup
arr2[0] = 'A'
arr3[1] = 'B'
[arr1, arr2, arr3] #=> [[1, 1, 1, 1], ["A", 1, 1, 1], [1, "B", 1, 1]]

# Для многомерных массивов похоже надо клонировать и все подмассивы, например рекурсивно



puts '                                         replace(изменение на месте)'

matrix = [[1, 2],[3, 4]]
matrix.replace(matrix.reverse.transpose)
p matrix #=> [[3, 1], [4, 2]]


def izm_na_meste(m)
  m.replace(m.reverse.transpose)
end
matrix = [[1, 2],[3, 4]]
izm_na_meste(matrix)
p matrix #=> [[3, 1], [4, 2]]



puts '                                          Методы информационные'

# length/size считает длинну(по числу элементов) массива
[1, 2, 3, 4, 5].length #=> 5
[1, 2, 3, 4, 5].size #=> 5

# count - Cчитает число элементов массива(можно задавать условия и блоки для выборки)
[1, 2, 3, 4, 5].count              #=> 5
[1, 2, 3, 4, 5].count(2)           #=> 1
[1, 2, 3, 4, 5].count{|n| n.even?} #=> 2

# empty? - проверяет пустой ли массив(nil считается элементом)[в Рэилс есть отличия см книгу стр 131-132]
[].empty? #=> true

# include? - ищет элемент true - нашел, false - не нашел
[1, 2, 3, 4, 5].include? 28 #=> false

# any? - проверяет соответсвует хотябы один элемент массива параметру или условию
[0, nil, false].any?            #=> true
[0, 1, 2].any?(0)               #=> true
[1, 2, 3, 4, 5].any?{|n| n > 6} #=> false

# all? - проверяет соответсвуют ли все элементы массива параметру или условию
[0, nil, false].all?            #=> false
['a', 'a', 'a'].all?('a')       #=> true
[1, 2, 3, 4, 5].all?{|n| n < 6} #=> true



puts '                                          Методы сортировки'

# reverse - располагает элементы массива в обратном порядке
[1, 2, 3, 4, 5].reverse #=> [5, 4, 3, 2, 1]

# rotate - сдвигает элементы массива
[1, 2, 3, 4, 5].rotate(2)  #=> [3, 4, 5, 1, 2]
[1, 2, 3, 4, 5].rotate(-1) #=> [5, 1, 2, 3, 4]

# sort - возвращает новый отсортированный массив
[2, 3, 1].sort #=> [1, 2, 3]



puts '                               Разбивка массива на подмассивы 2d массива'

# each_slice - разбивает массив на части заданной длинны
[1, 2, 3, 4, 5, 6, 7].each_slice(3).to_a #=> [[1, 2, 3], [4, 5, 6], [7]]

# slice_when - разбивает массив в точке между 2мя последовательными элементами соответсвующими условию.
[0,4,4,4,0,4,3,3,0].slice_when{|x, y| x == 0 or y == 0}.to_a #=>[[0], [4, 4, 4], [0], [4, 3, 3], [0]]
# Тут разбиваем между 1м и 2м параметром когда выполняется условие для послндовательных членов

# chunk_while - разбивает массив в точке между 2мя последовательными элементами не соответсвующими условию
[1,2,4,9,10,11,12,15,16,19,20,21].chunk_while {|i, j| i + 1 == j}.to_a #=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
[1000, 0, 1, 0, 0, 0, 0].chunk_while(&:==).to_a                        #=> [[1000], [0], [1], [0, 0, 0, 0]]

# each_cons - разбивает массив на отрезки по n последовательных элеметнов, начиная от каждого элемента по порядку
[1,2,3,4,5,6,7].each_cons(3).to_a #=> [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]]

# Распределяет элементы по индексам четные и нечетные
[1, 2, 3, 4].partition.with_index{|_, i| i.even?} #=> [[1, 3], [2, 4]]


# Разбивка массива по шаблону
def razbiv(form, arr)
  form.map{|e| arr.shift(e)}
end
razbiv([1,2,3,4], [1,2,3,4,5,6,7,8,9,10]) #=> [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]
razbiv([4, 2, 6, 3, 5], ["g", "k", "g", "v", "k", "y", "u", "n"]) #=> [["g", "k", "g", "v"], ["k", "y"], ["u", "n"], [], []]


# Разбивка массива по индексам
arr=[1, 3, 7, 'a']
inds=[[1], [1, 3]]
inds.map{|a| arr.map.with_index{|c, i| a.include?(i) ? ' ' + c.to_s : c}.join.split} #=> [["1", "37a"], ["1", "37", "a"]]



puts '                                          Разное'

# Поиск общих элементов массивов (не учитывает повторы)
%w[a b b c d] & %w[g f d b b b s a k c] #=> ["a", "b", "c", "d"]
[%w[a a b c c d], %w[g f d s a a k c c]].inject(:&) #=> ["a", "c", "d"]

# Поиск общих элементов (учитывает повторы)
def common(a, b, c)
  ha, hb, hc = a.tally, b.tally, c.tally
  (ha.keys + hb.keys + hc.keys).uniq.map do |k|
    values = [ha[k], hb[k], hc[k]]
    values.compact.size < 3 ? nil : [k]*values.min
  end.compact.flatten
end
common([1,2,2,3],[5,3,2,2],[7,3,2,2]) #=> [2, 2, 3]

# найти отсутствующее число в массиве последовательных чисел при помощи арифм прогрессии (s=(a1+an)*n/2)
(a[0] + a[-1]) * (a.size + 1) / 2 - a.sum

# содержит ли массив все элементы другого массива(с повторяющимися)
needle.uniq.all?{|e| haystack.count(e) >= needle.count(e)}

# Разница массивов с повторными элементами
s2.chars.select{|x| s1.count(x) < s2.count(x)}
a.uniq.map{|n| [n, [a.count(n), b.count(n), c.count(n)]]}

# поиск дубликатов в массиве(быстрый)
ary.group_by{|e| e}.select{|k, v| v.size > 1 }

# Подсчет числа повторов каждого элемента
[10,9,8,9,6,1,2,4,3,2].group_by{|e| e}.map{|k, v| [k, v.size]}.to_h #=> {10=>1, 9=>2, 8=>1, 6=>1, 1=>1, 2=>2, 4=>1, 3=>1}
[10,9,8,9,6,1,2,4,3,2].tally #=> {10=>1, 9=>2, 8=>1, 6=>1, 1=>1, 2=>2, 4=>1, 3=>1}
[1,2,5,5,6].sort.chunk{|e| e}.to_a #=> [[1, [1]], [2, [2]], [5, [5, 5]], [6, [6]]] # chunk arra->enumerable

# Найти зацикленную последовательность(1939) в массиве(если она начинается с верного элемента)
arr, res = [1, 9, 3, 9, 1, 9, 3, 9, 1, 9, 3], []
arr.each do |n|
  res << n
  break if (res*(arr.size/res.size+1))[0..arr.size-1] == arr
end
res #=> [1, 9, 3, 9]

# Оптимизация перед пермутацией(сокращение максимального числа повторяющихся элементов до колличества в пермутации(тут n))
arr = ["3", "7", "7", "7", "3", "3", "3", "7", "8", "8", "8"]
n = 3
hh = arr.tally
moda = hh.map{|k, v| v > n ? [k]*3 : [k]*n}.flatten #=> ["3", "3", "3", "7", "7", "7", "8", "8", "8"]



puts
puts "                                         Методы-итераторы с блоками"

# cycle Зацикленный вывод(будет выводить значения массива по кругу до принудительной остановки или бесконечно):
counter = 0
["a", "b", "c"].cycle{|x|
  print "#{x} "
  counter += 1
  break if counter > 10
} #=> a b c a b c a b c a b

# Считает индексы большие чем есть в массиве
[1, 2, 3].cycle.with_index do |n,i|
  print i
  break if i == 9
end
#=> 0123456789

# Заполнение подмассивов при помощи присвоения цикла cycle в переменную
def custom(s, n)
  w = s.chars.cycle # присвоение цикла в переменную  w.class#=>Enumerator
  (1..n).map{|i| i.times.map{w.next}}
end
custom('abc', 3) #=> [["a"], ["b", "c"], ["a", "b", "c"]]


puts
# each(каждый) Передает каждый последующий элемент массива в блок(проводит итерацию); возвращает исходный массив:

names = ["Гонзик", "Влаженка", "Крокер"]
x = 0
names.each do # Без переменной просто сделает число итераций равное числу элементов массива
	puts x
  x += 1
end

# С локальной переменной области блока, которая принимает каждый раз новый элемент массива
names2 = ["Гонзик", "Влаженка", "Крокер"]
names2.each do |name|
	puts "#{x}.#{name} - ok"
end #=> ["Гонзик", "Влаженка", "Крокер"]


# изменение массива во время итерации
arr = [1, 2, 3]
arr.each.with_index do |n, i|
  arr[i] *= 2
  p arr #=> [2, 2, 3] ... [2, 4, 3] ... [2, 4, 6]
end


# Присвоение новых значений через переменную per в  - each do |per|, если это массив(иначе не присваивается)
items = [[1, 'a'], [2, ['b']], [3, 'c']]
items.each do |per|
  per[1] = 'new'
end
p items #=> [[1, "new"], [2, "new"], [3, "new"]]


# Метод-расширение each_with_index передает 2 параметра для того чтоб обойтись для подсчета при помощи переменной
names2.each_with_index{|name, i| puts "#{i + 1}.#{name} - ok"}

# замена элементов в массиве при помощи each в процессе итерации, меняет и индексы в процессе
def unflatten(arr)
  arr.each_with_index do |n, i|
    arr[i..n+i-1] = [arr[i..n+i-1]] if n > 2
  end
end
unflatten([1, 4, 5, 2, 1, 2, 4, 5, 2, 6, 2, 3, 3])#=> [1, [4,5,2,1], 2, [4,5,2,6], 2, [3, 3] ]


# Метод map/collect, map!/collect! map выполняет действие с каждым элементом в массиве и возвращает его результат в виде массива.
[1, 3, 4, 5, 7].map {|n| "#{n + 2} summ"} #=> ["3 summ", "5 summ", "6 summ", "7 summ", "9 summ"]

# Условие с or в map
arr.map.with_index{|n, i| arr[0..i].reverse.detect{|k| k < n} or -1}


# Метод select/filter(Выбор элементов по критерию) Возвращает выбранные элементы
[ [30, 1], [25, 0], [64, 1], [64, 0], [33, 1] ].select{|e| e[0] == 64 && e[1] == 1 } #=> [[64, 1]]
# Метод reject(Отсечение элементов по критерию) Возвращает массив исключив выбранные элементы
[ [30, 1], [25, 0], [64, 1], [64, 0], [33, 1] ].reject{|e| e[0] > 30 or e[1] == 0 } #=> [[30, 1]]

# Смесь map и select
[1, 2, 3, 4, 5].filter_map{|n| n.odd? ? n*2 : nil } #=> [2, 6, 10]

# находит все элементы соотв условию(аналог select ?)
arr.find_all { |e| arr.count(e) > 1 }

# Метод find выбирает одно самое первое совпадение и останавливает итерацию
people.find { |element| element[1] == 1 } #=> [30, 1]

# Метод find_index/index(Ищет индекс элемента удовлетворяющего условию)
[false, false, false, true, false].index { |element| element == true } #=> 3

# Метод any?(Есть ли хотя бы один элемент удовлетворяющий условию)
[1, 2, 3, 4, 5].any? { |element| element == 3 } #=> true

# Метод all?(Все элементы должны удовлетворять критерию)
[20, 34, 65, 23, 18, 44, 32].all? { |element| element >= 18 } #=> true

# Метод max_by(максимальный из соответсвующих условию)
[1, 5678, 43].max_by { |num| num.to_s.size } #=> 5678

# Сортировка массива по 2м параметрам(параметр Numeric можно поставить перед ним знак минус, будет сортировать от наибольшего)
[[5,3],[5,4],[5,10],[3,1]].sort_by! {|a,b| [a, -b]} #=> [[3, 1], [5, 10], [5, 4], [5, 3]]

# sum - сумма элементов измененных при помощи условия
[1,2,3].sum{|e| e**2} #=> 14



puts '                                          Метод inject/reduce'

# inject/reduce  - возвращает объект, сформированный из операндов с помощью метода, заданного символом.
[1, 2, 3, 4].reduce(:+)     #=> 10 (1 + 2 + 3 + 4)
[100, 300, 2].reduce(:-)    #=> -202 (100 - 300 - 2)
[1, 2, 3, 4].reduce(:*)     #=> 24 (1 * 2 * 3 * 4)

# Уникальный элемент массива
[1, 2, 1, 3, 2].reduce(:^)              #=> 3
[1, 2, 1, 3, 2].inject(0){|c, n| c ^ n} #=> 3

# Примеры с первым операндом (который является self.first) различных типов:
[1, 2, 3, 4].inject(2, :+)               #=> 12                         # Integer.
[1, 2, 3, 4].inject(2.0, :+)             #=> 12.0                       # Float.
[1, 2, 3, 4].inject(Complex(2, 2), :+)   #=> (12+2i)                    # Complex.

# С блоком для задания дополнительных условий операции
[1, 2, 3, 4].inject{|sum, n| sum + n*n }    #=> 30 (1*1 + 2*2 + 3*3 + 4*4)
[1, 2, 3, 4].inject(2){|sum, n| sum + n*n } #=> 32 (2 + 1*1 + 2*2 + 3*3 + 4*4)

# Строковые значения
%w[a b c d].inject(:+)            #=> "abcd"
%w[bar baz].inject('foo', :+)     #=> "foobarbaz"

# С методом в качестве типа орперации
%w[a b c].inject(['x'], :push)      #=> ["x", "a", "b", "c"]


puts
puts '                                         Двумерные массивы(2D array)'

# Элементами 2д массива являются массивы.

list_names = [["Mike", 56], ["Walt", 53]]

list_names[0] #=> ["Mike", 56]
list_names[0][1] #=> 56  # сначала нужно обратиться к строке (row), а потом к столбцу (column)
list_names[1][1] = 54 #=> [["Mike", 56], ["Walt", 54]]  # переназначение
list_names[1][2] = 67316 #=> [["Mike", 56], ["Walt", 54, 67316]]  # назначение нового элемента
list_names[0] << 62222 #=> [["Mike", 56, 62222], ["Walt", 54, 67316]]  # добавление нового элемента

# Наиболее часто встречающиеся наименования строк и столбцов:
# row - строка, column - столбец. Обращение к массиву: arr[row][column]
# y - строка, x - столбец. Обращение к массиву: arr[y][x]
# j - строка, i - столбец. Обращение к массиву: arr[j][i]


# запись элементов в пайпах блока 2мерного массива
[[1],[2],[3]].map{|(n)| n} # [1, 2, 3]
[[1, 10], [2, 20], [3, 30]].map{|(n, m)| m} #=> [10, 20, 30]


puts
puts '                         Инициализация 2мерного массива(контринтуитивный момент)'

arr = Array.new(10, []) # Так инициализировать не надо
arr #=> [[], [], [], [], [], [], [], [], [], []]
arr[4].push('some') # ожидание => [[], [], [], [], ["some"], [], [], [], [], []]
arr #=> [["some"], ["some"], ["some"], ["some"], ["some"], ["some"], ["some"], ["some"], ["some"], ["some"]]
# При инициализации массива мы передаем ссылку (reference) на один объект([]). Т.к. мы передаем параметр([]) один раз, то и объект в массиве всегда “размножается по ссылке”. Т.е. на самом деле при такой инициализации массива, все ячейки содержат ссылки на один и тот же объект. Чтобы этого не происходило, нужно чтобы ссылки на объекты были разные. При этом, конечно, и сами объекты будут разные - они будут располагаться в разных областях памяти, и если мы что-то изменим, то это не изменит состояние (state) других объектов.

# В случае с числами все еще проще:
arr = Array.new(10, 123) # В классе Integer нет опасных методов, поэтому, даже если у вас есть доступ к объекту, вы не сможете его изменить (но сможете заменить).
# Если вы напишите
arr[4] = 555 # то вы замените ссылку в массиве на новый объект, который будет представлять число “124”. Ссылки на один и тот же объект “123” в других частях массива сохранятся. Т.е. мы и получим то, что ожидаем:
arr #=> [123, 123, 123, 123, 555, 123, 123, 123, 123, 123]

# ПРАВИЛЬНЫЙ СИНТАКСИС для объявления двумерного массива 10 на 10 в руби (массив будет заполнен nil - объектом, представляющим пустое значение):
arr = Array.new(10) { Array.new(10) } # Метод “new” (на самом деле это метод “initialize”) принимает один параметр и один блок. Первый параметр (“10”) - фиксированный, это количество элементов массива. А второй параметр(“{ Array.new(10) }”) - блок, который надо исполнить для каждого элемента. Результат выполнения этого блока и будет новым элементом. Блок будет запускаться 10 раз (в нашем случае)

# ПРАВИЛЬНО. конструкция(arr1) при инициализации вызывает блок. В результате вызова блока каждый раз создается новое значение “something” в новой области памяти.
arr1 = Array.new(3) { 'something' }
arr1 #=> ["something", "something", "something"]
arr1[0].upcase!
arr1 #=> ["SOMETHING", "something", "something"] Изменилось только первое значение, тк ссылка везде разная.

# НЕПРАВИЛЬНО. (arr2) берется “something”, который мы передали через параметр. Он создается в области памяти перед тем, как параметр будет передан в метод new, и используется для всех ячеек массива, всегда один и тот же.
arr2 = Array.new(3, 'something')
arr2 #=> ["something", "something", "something"]
arr2[0].upcase!
arr2 #=> ["SOMETHING", "SOMETHING", "SOMETHING"] поменялся массив целиком, потому что ссылка на элемент во всех ячейках массива одинаковая

# Если бы мы перед “upcase!” переинициализировали какой-либо элемент, то этот элемент не был бы затронут:
arr2 = Array.new(3, 'something')
arr2[2] = 'something'
arr2[0].upcase!
arr2 #=> ["SOMETHING", "SOMETHING", "something"]
# элемент с индексом 2 не был затронут операцией “upcase!”, т.к. это совершенно другой объект, хотя при выводе на экран нам кажется что все одинаково

# Если нужно заполнить массив значением, отличным от nil, передаем его во второй конструктор:
# Создать массив в 4 строки и 10 столбцов и заполнить его значением “0”:
arr = Array.new(4) { Array.new(10, 0) }
# Создать массив в 2 строки и 3 столбца и заполнить каждую строку одинаковым объектом “something”:
arr = Array.new(2) { Array.new(3, 'something') }
# Создать массив 5 на 4 и заполните весь массив абсолютно случайными значениями от 0 до 9.
arr = Array.new(5) { Array.new(4) { rand(10) } }


puts
# 2D Methods

[[:a0, :a1], [:b0, :b1], [:c0, :c1]].transpose #=> [[:a0, :b0, :c0], [:a1, :b1, :c1]] # Делает строки столбцами и столбцы строками("поворачивает" 2д массив). Или создает 2в массив подмассивы которого содержат элементы с итыми игдексами изначальных подмассивов.

# Авттообрезка при помощи select(&:all?) если массивы разной длинны
[1, 2, 3].zip([1, 2]).select(&:all?) #=> [[1, 1], [2, 2]]

# Поиск(счет) массивов как элементов
sp.count(["pirate"])

# 2 параметра для 2х элементов подмассивов
[['ABC', 65], ['HGR', 74]].count{ |str, num| str.include?(num.chr) } #=> 1

# Отбор и сортировка элементов 2д массива по элементам подмассивов(uniq==uniq_by)
[["d",1], ["d",2], ["d",3], ["E",1], ["C",5]].uniq{|a| a[0]} #=> [["d", 1], ["E", 1], ["C", 5]]
[["d",1], ["d",2], ["d",3], ["E",1], ["C",5]].uniq(&:first) #=> [["d", 1], ["E", 1], ["C", 5]]

[["d",1], ["d",2], ["d",3], ["E",1], ["C",5]].sort_by(&:last)
#=> [["E", 1], ["d", 1], ["d", 2], ["d", 3], ["C", 5]]

# Сортировка с указанием подмассива в параметрах в скбках
arr = [[0, [2, -2, 3]], [5, [4, 2, 6]], [1, [2, -2, 3]], [4, [5, 4, 5]], [2, [1, -3, 2]], [3, [4, 1, 4]]]
arr.sort_by{|i,(a,b,c)| [-a,-b,-c]}
#=> [[4, [5, 4, 5]], [5, [4, 2, 6]], [3, [4, 1, 4]], [1, [2, -2, 3]], [0, [2, -2, 3]], [2, [1, -3, 2]]]

# параметр agrs
a[0].product(*a[1..-1]).uniq.size

# product для 2д массива
groups = [ %w[hello goodbye], %w[world everyone], %w[here there] ]
combinations = groups.first.product(*groups.drop(1))

#
[[1, 1], [2, 2], [1, 6] [7, 8]].take_while { |a, b| a == b } #=> [[1, 1], [2, 2], nil]


puts
# реверсирование 2х главных диагоналей матрицы
def diagonal_reverse_unit(matrix)
  0.upto(matrix.size/2-1) do |i|
    matrix[i][i], matrix[matrix.size-1-i][matrix.size-1-i] = matrix[matrix.size-1-i][matrix.size-1-i], matrix[i][i]
  end
  matrix
end
def reverse_on_diagonals(matrix)
  diagonal_reverse_unit(diagonal_reverse_unit(matrix).reverse).reverse
end

puts
# Диагонали 2д массива
arr = [
  [1, 2, 3, 4],
  [3, 4, 5, 6],
  [5, 6, 7, 8],
  [2, 3, 4, 5]
]
# Доп элементы к каждой строке
pattern = (0..arr.size-1).map{|i| [nil]*i} #=> [[], [nil], [nil, nil], [nil, nil, nil]]
# Добавляем справа и слева для смещения элементов
res = pattern.reverse.zip(arr).zip(pattern).map(&:flatten)
#=> [[nil, nil, nil, 1, 2, 3, 4], [nil, nil, 3, 4, 5, 6, nil], [nil, 5, 6, 7, 8, nil, nil], [2, 3, 4, 5, nil, nil, nil]]
res.transpose.map(&:compact)
#=> [[2], [5, 3], [3, 6, 4], [1, 4, 7, 5], [2, 5, 8], [3, 6], [4]]

# Все диагонали(с обоих углов)
def diags(matrix)
  [matrix, matrix.reverse].map do |m|
    pat = (0..m.size-1).map{|i| [nil]*i}
    res = pat.reverse.zip(m).zip(pat).map(&:flatten)
    res.transpose.map(&:compact)
  end
end
diags(arr)
#=> [[[2], [5, 3], [3, 6, 4], [1, 4, 7, 5], [2, 5, 8], [3, 6], [4]],
#   [[1], [3, 2], [5, 4, 3], [2, 6, 5, 4], [3, 7, 6], [4, 8], [5]]]


# Перебор элементов по диагонали от правого нижнего(отсюда можно вывести поворот массива по диагонали)
def diagonal(arr)
  arr.transpose.map(&:reverse).reverse.map.with_index{|a,i| a.map.with_index{|e,j| [e, i, j]}}.flatten(1)
  .sort_by{|a| [a[1]+a[2], a[1]]}.map{|a| a[0]}
end
p diagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]])# [9, 6, 8, 3, 5, 7, 2, 4, 1]
#[[9, "0-0"], [6, "0-1"], [8, "1-0"], [3, "0-2"], [5, "1-1"], [7, "2-0"], [2, "1-2"], [4, "2-1"], [1, "2-2"]]


puts
# подсчет всех клеток 2д массива которые находятся в линии пересекающей точку посчета(не включая ее саму)
a*b*(a+b-2) # lines
a,b = [a,b].sort
2*a*(a-1)*(3*b-a-1)/3 # diagonals


puts
puts '                                            многомерные массивы(тензоры)'

# Если 2D массив это “массив массивов”, то 3D массив это “массив массивов массивов”. Иногда такие массивы называют “тензор”.

# массив 2 на 3 на 3: два блока, в каждом блоке 3 строки, в каждой строке 3 столбца.
arr = [
  [ %w(a b c), %w(d e f), %w(g h i) ],
  [ %w(aa bb cc), %w(dd ee ff), %w(gg hh ii) ]
]
arr[0][1][2] #=> 'f'


# Посчитать число вложенных подмассивов
a.to_s.count("[")


# способ записи параметров для многомерных массивов
points_list1 = [[1,2,-4], [-3, 2, 4], [7, 8, -4], [2, 3, 5], [-2, -1, 1]]
p_in_s.combination(3).to_a.each do |(x1,y1,z1),(x2,y2,z2),(x3,y3,z3)|
end


puts
puts '                                                 Matrix'

# https://ruby-doc.org/stdlib-3.0.0/libdoc/matrix/rdoc/Matrix.html
# перевод массива в матрицу
require 'matrix'
matrix1 = Matrix[[1,2,3],[4,5,6],[7,8,9]] #1
nested_array = [[1,2,3],[4,5,6],[7,8,9]] #2
matrix2 = Matrix[nested_array] #=> Matrix[[[1,2,3],[4,5,6],[7,8,9]]]
matrix3 = Matrix[*nested_array] #=> Matrix[[1,2,3],[4,5,6],[7,8,9]]

# Определитель(determinant)
Matrix[[7,6], [3,9]].determinant #=> 45
Matrix[[2,5,3], [1,-2,-1], [1, 3, 4]].det  #=> 20

# Решение матрицы
m = Matrix[[1, 0, 0], [4, -5, 1], [0, 0, 1]] #=> Matrix[[1, 0, 0], [4, -5, 1], [0, 0, 1]]
b = Vector[0, 0, 729] #=> Vector[0, 0, 729]
a = m.lup.solve(b).to_a #=> [(0/1), (729/5), (729/1)]  ( rescue 0  для вырожденных дописать)

# Диагональ
Matrix[ [1,2], [3,4] ].each(:diagonal).to_a #=>[1,4]
:all #(по умолчанию) возвращает все элементы
:diagonal# дает только элементы по диагонали
:off_diagonal# возвращает все элементы, кроме диагональных
:lower# дает только элементы на диагонали или ниже
:strict_lower# выдает только элементы ниже диагонали
:upper# возвращает только элементы на диагонали или выше
:strict_upper# выдает только элементы выше диагонали


require 'matrix'
p Matrix.identity(5).to_a #=> [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]]

# Сложение 2д массивов где складываются попарно все [i][j] элементы обоих массивов, образуя матрицу того же размера
require 'matrix'
(Matrix[*a] + Matrix[*b]).to_a
(Matrix.rows(a) + Matrix.rows(b)).to_a #альтер вариант

# Нахождение координат(индексов) элемента 2д массива
require 'matrix'
arr = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 'e', 0], [0, 0, 0, 0] ]
p Matrix[*arr].index('e') #=> [2, 2]

# Square Matrix Multiplication
# A         B          C
# |1 2|  x  |3 2|  =  | 5 4|
# |3 2|     |1 1|     |11 8|
def matrix_mult(a, b)
  (Matrix[*a] * Matrix[*b]).to_a
end
















#
