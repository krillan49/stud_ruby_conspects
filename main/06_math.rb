puts '                                     Математические действия/операторы'

# Большинство математических операторов на самом деле являются вызовами методов. Например, a + b интерпретируется как a.+(b), где метод + в объекте, на который ссылается переменная a, вызывается с b в качестве аргумента.
1.+(2) #=> 3
# Тут числа 1 и 2 называются операндами, а + оператором


puts
puts '                                   Арифметические операторы(+ - * / % **)'

# Порядок действий, включая скобки, считает по правилам математики.
(2 + 3) * 5 - 6 * 2 #=> 13

# Сложение вычитание умножение:
5 + 10  #=> 15
10 - 15 #=> -5
5 * 10  #=> 50

# Деление(целые числа на ноль делить нельзя, выдаст ошибку):
10 / 5    #=> 2
# Для делителя и делимого класса Intejer деление будет целочисленным
270 / 100 #=> 2
# Перевод переменных во float(to_f), когда предполагается, что данные или результаты будут дробными
x.to_f / y      #=> 0.5
270.0 / 100     #=> 2.7

# Возведение в степень:
2 ** 3 #=> 8
10**-1 #=> (1/10)  Rational

# Деление с остатком(возвращен будет остаток от деления):
10 % 5 #=> 0 (нет остатка)
17 % 12 #=> 5
1 % 5 #=> 1

# Проверка на целочисленность/извлечение дробной части числа
2.1 % 1 #=> 0.10000000000000009
2.0 % 1 #=> 0.0

# Деление нацело отрицательных чисел. Тк деление нацело == деление+округление вниз, то отриц число округляется в большую сторону по своему модулю:
(-2.5).floor  #=> -3
# Соответвенно получаем
5 / -2        #=> -3
-5 / 2        #=> -3

# Нахождение остатка от деления на отрицательное число. Тк остаток от деления равен делимое минус результат целочисленного деления умноженного на делитель то получаем:
19 / -5          #=> -4    # результат целочисленного деления(рцд)
19 - (-4) * (-5) #=> -1    # тк делимое==(рцд)*делитель+остаток  соотв  остаток==делимое-(рцд)*делитель
19 % -5          #=> -1    # соответсвенно получаем


puts
puts '                                          Операторы сравнения'

# Выражение с операторами сравнения возвращают true или false

a, b = 10, 20

a > b  #=> false    #`>`  - больше
a < b  #=> true     #`<`  - меньше
a == b #=> false    #`==` - равно
a != b #=> true     #`!=` - не равно
a >= b #=> false    #`>=` - больше или равно
a <= b #=> true     #`<=` - меньше или равно

#`<=>` - (только Руби) космический корабль (spaceship operator). Возвращает: 1 если первое больше; 0 если равно и -1 если меньше
a <=> b #=> -1

# .eql? - Истинно, если получатель и аргумент имеют одинаковый тип и одинаковые значения.
1.eql?(1.0) #=> false

#`===` и `!==` - операторы точно равно и точно не равно в Руби не применяется.


puts
puts '                                    Сокращенные операторы присваивания'

# Для каждого оператора (+ - * / % ** & | ^ << >> && ||) существует соответствующая форма сокращенного оператора присваивания/

# Если действие происходит над одной переменной, например:
t = t + 20  # то эту запись можно сократить до
t += 20
# t = t + 1 - это увеличение числа на единицу без изменения переменной
# По аналогии t -= 20  t *= 20  t /= 20  t **= 20  t %= 20


puts
puts '                                               rand'

# Оператор rand выдает псевдослучайное число. По умолчанию это float  между 0 и 1
rand() #=> 0.2546047900803543

# Оператор rand выдает случайное число в диапазоне от 0 до заданного числа минус 1(0...n)
rand(100) # вернет случайное число от 0 по 99

# Может принимать диапазоны и возвращать случайное число от и до
rand(4..10)      # вернет случайное число от 4 до 10
4 + rand(7)      # тоже самое
rand(0.03..0.09) # работает и на float

# Альтернатива Kernel::rand()
lucky_number = (Kernel::rand() * 100 + 1).floor


puts
puts '                                          Математические классы'

# Rational - класс для ппостых дробей
p Rational(1, 3)    #=> (1/3)
# Перевод в Rational из Float и обратно
1.5.to_r            #=> (3/2)
Rational(1, 4).to_f #=> 0.25
# Перевод в Rational из String
['2/3', '1/4', '5/6'].map(&:to_r)              #=> [(2/3), (1/4), (5/6)]
['-7/3', '-1/3', '-2/3'].map(&:to_r).sum       #=> (-10/3)
['1/4', '5/4', '-1/2', '-1/1'].map(&:to_r).sum #=> (0/1)
# При возведении в отрицательную степень, по умолчанию возвращает Rational
10**(-1)       #=> (1/10)
10**(-1) + 1   #=> (11/10)
# Особенности перевода
Rational(1.6)   #=> (3602879701896397/2251799813685248)
1.6.to_r        #=> (3602879701896397/2251799813685248)
Rational('1.6') #=> (8/5)
'1.6'.to_r      #=> (8/5)


puts
# Комплексные числа
Complex(2, 0)           #=> (2 + 0i)
Complex(2, 0).real      #=> 2
Complex(2, 0).imaginary #=> 0


puts
# можно складывать, вычитать, умножать и делить разные типы чисел
2 + 2.0            #=> 4.0
2 + Rational(2, 1) #=> (4/1)
2 + Complex(2, 0)  #=> (4+0i)


puts
# BigDecimal (подходит для огромных чисел с плавающей запятой, тк обычный float пишет infinity)
require 'bigdecimal'
BigDecimal("1.2")                #=> 0.12e1
(BigDecimal("1.2")**10000).class #=> BigDecimal
# Для перевода нужно дополнительно подключить, тогда require 'bigdecimal'
require 'bigdecimal/util'
42.to_d #=> 0.42e2


puts
# Константа бесконечности
Float::INFINITY     #=> Infinity
3 < Float::INFINITY #=> true
# Можно создать свою собственную константу:
PositiveInfinity = +1.0 / 0.0                         #=> Infinity   # кастомная константа бесконечности положительных чисел
NegativeInfinity = -1.0 / 0.0                         #=> -Infinity  # кастомная константа бесконечности отрицательных чисел
CompleteInfinity = NegativeInfinity..PositiveInfinity #=> -Infinity..Infinity


puts
puts '                               Math - модуль для математических операций'

Math::E  #=> 2.718281828459045   # константа E
Math::PI #=> 3.141592653589793   # константа PI

Math.log(10)    #=> 2.302585092994046  # натуральный логарифм
Math.log10(1)   #=> 0.0
Math.log(8, 2)  #=> 3.0
Math::log(8, 2) #=> 3.0

Math.sqrt(144)             #=> 12.0   # квадратный корень
Math.cbrt(64)              #=> 4.0    # куб корень
Math.exp(Math.log(64)/3.0) #=> 4.0    # куб корень
64**(1/3.0)                #=> 3.9999999999999996   # альт куб корень
Math.exp(Math.log(16)/4.0) #=> 2.0    # корень 4й
16**(1/4.0)                #=> 2.0    # альт корень 4й

Math.cbrt(64).round**3 #=> 64  проверка на куб корень


puts
puts '                                             methods'

-14.84.abs           #=> 14.84  # Модуль числа

# Информационные
55.positive?           #=> true
55.negative?           #=> false

12.between?(10, 22)    #=> true  # Лежит ли число между числами(включительно)
'B'.between?('A', 'D') #=> true  # берет букву по ее коду?

# Округление стандартное
-14.84.round                #=> -14     # округление до целого
-14.84.round(1)             #=> -14.8   # округление до энного порядка
(10.9999999999999).round(5) #=> 11.0
25.round(-1)                #=> 30  #округление до более высокого порядка

# Округлкние вверх
0.2.ceil      #=> 1
0.229.ceil(2)
2001.ceil(-2) #=> 2100

# Округлкние вниз
0.7.to_i                 #=> 0
0.7.floor                #=> 0
0.229.floor(2)
(-2.5).floor             #=> -3   # Отрицательные числа округляются в обратную по модулю стиорону
1.6576597605.truncate(2) #=> 1.65  # Округление без изменений(обрезка до эн знаков после запятой)

# наибольший общий делитель
50.gcd(60) #=> 10
[25, 35, 10, 15, 20].reduce(:gcd) #=> 5

# наименьшее общее кратное
10.lcm(15) #=> 30
[5, 3, 10, 2, 20].reduce(1){|acc, n| acc.lcm(n)} #=> 60
[5, 3, 10, 2, 20].reduce(1, :lcm) #=> 60
[5, 3, 10, 2, 20].reduce(:lcm)    #=> 60

# следующее и предыдущее число после заданного делящиеся на заданные числа
d = x.lcm(y)
(n - 1) / d * d # пред
(n / d + 1) * d # след


puts
puts '                                            Форматирование'

# ?? Потом мб вынести в отдельную тему

# Обязательно 2 знака после запятой(недостающие дополняются нулями):
'%.2f' % 1                 #=> "1.00"
"%02d%s" % ['1', ':00:01'] #=> "01:00:01"
"%02d%02d" % [5, 9]        #=> "0509"
'%02X' % 15                #=> "0F"   # Перевод в 16ричное и добавление до 2х знаков


puts
puts '                                                Prime'

# Для использования методов Prime необходимо подключить этот модуль
require 'prime'

# Проверить простое число или нет
5.prime?        #=> true
Prime.prime?(6) #=> false

# Первые n простых чисел
Prime.take(10)  #=> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
Prime.first(10) #=> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# Массив всех простых чисел от 2 до n
Prime.entries(11)   #=> [2, 3, 5, 7, 11]
Prime.each(11).to_a #=> [2, 3, 5, 7, 11]

# Массив всех простых чисел от m до n
m, n = 7, 33
# Находит быстрее чем (m..n).select(&:prime?)
Prime.entries(n) - Prime.entries(m-1) #=> [7, 11, 13, 17, 19, 23, 29, 31]

# вернуть массив всех простых чисел до значения удовлетворяющего условию
Prime.take_while{|p| p < 30} #=> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# Поиск простого числа по условию
Prime.find{|p| p > n}

# разложение на простые множители. Каждый вложенный массив содержит простое число и показатель степени, с которым оно входит в произведение
126.prime_division #=> [[2,1], [3,2], [7,1]]  # To есть 2**1 * 3**2 * 7**1

# восстанавливает исходное число из его сомножителей. Это именно метод класса, тк выступает в роли «конструктора» целого числа.
Integer.from_prime_division([[2,1],[3,1],[7,1]]) #=> 42

# Формула колличества всех делителей числа на основе числа простых делителей (n = p1**a1 * p2**a2 *...* pk**ak):
# t(n) = (a1+1) * (a2+1) * ... * (ak+1). Далее пример для 126 (n=2**1 * 3**2 * 7**1): t(126)=(1+1)*(2+1)*(1+1)=12
126.prime_division.map{|a| a[1] + 1}.inject(:*) #=> 12

# Сумма всех делителей числа(включая 1 и само число)
504.prime_division.map{|a| (a[0]**(a[1] + 1) - 1) / (a[0] - 1)}.inject(:*) # 1560

# Все делители числа кроме 1 и самого себя
n = 765487649768760760767
arr = n.prime_division.map{|a| (1..a[1]).map{|i| a[0]**i}}
dels = (1..arr.size).map{|k| arr.combination(k).to_a}.flatten(1).map do |comb|
  comb.size == 1 ? comb.flatten : comb[0].product(*comb[1..-1]).map{|a| a.inject(:*)}
end.flatten.select{|e| e < n}
#=> результат за 2.741 seconds.


# Метод сетки эратосфена для генерации простых числел ( https://www.baeldung.com/cs/prime-number-algorithms )
def find_primes_eratosthenes(n)
  arr = Array.new(n, true)
  s = Math.sqrt(n)
  (2..s).each do |i|
    if arr[i]
      j = i**2
      while j <= n
        arr[j] = false
        j += i
      end
    end
  end
  res = []
  arr.each.with_index{|e, i| res.push(i) if e}
  res
end
p find_primes_eratosthenes(2000000)


puts
puts '                                             Системы исчисления'

# Перевод десятичного числа в другую систему исчисления
25.to_s(2)   #=>"11001"
25.digits(2) #=> [1, 0, 0, 1, 1]   # дополнительно реверсирует

# Чтобы рассматривать String как двоичное число, восьмеричное или шестнадцатеричное и перевести его в десятичное Integer, нужно передать аргумент base= с соответсвующим числом исчисления в метод to_i:
"11".to_i            #=> 11   # по умолчанию как десятичное
"11".to_i(base=2)    #=> 3    # переводит из двоичной в десятичную(Integer)
"11".to_i(base=16)   #=> 17
'aa'.to_i(16)        #=> 170  # base= писать необязательно
"aB".to_i(16)        #=> 171  # регистр любой
# если используем to_i с основанием, которое не предусматривает таких символов, тогда вернется 0
"aB".to_i        #=> 0
"9".to_i(8)      #=> 0
# если не все символы могут быть сконвертированы в число to_i сконвертирует все 'digits' от начала до того места, где уже не будет понятно, что делать. Оставшаяся часть строки будет отброшена. Даже если там есть еще понимаемые значения.
"2x3".to_i       #=> 2
"2 3".to_i       #=> 2
'6jnkjnkj'.to_i  #=> 6
'afzzz'.to_i(16) #=> 175


puts
# Перевод Float на примере 16ричной системы: Перевести число 0,2A9 из шестнадцатеричной системы в десятичную
# 0.2A916 = 0 * 16**0 + 2 * 16**-1 + A * 16**-2 + 9 * 16**-3 = 0 * 1 + 2 * 0.0625 + 10 * 0.00390625 + 9 * 0.000244140625 = 0 + 0.125 + 0.0390625 + 0.002197265625 = 0.16625976562510
n.chars.map.with_index(1){|e, i| e.to_i(16).to_f / 16**i}.sum


puts
# Перевод из 10й системы исчисления в другую столбиком
# https://ege-study.ru/ege-informatika/sistemy-schisleniya-perevod-iz-odnoj-sistemy-v-druguyu/
# делим число на базу(в которую нужно перевести), остаток от деления будет последней цифрой нового числа, а результат от деления снова делим на базу, пока оно не станет равно ноль(меньшее разделится на большее)
def translator_from10_to_any(n, base)
  res = []
  until n == 0
    res.unshift(n % base)
    n /= base
  end
  res
end
# Пример конвертера использующего translator_from10_to_any
def convert(num_for_convert, notation_from, notation_to)
  return notation_to[0] if num_for_convert == '0'
  arr = num_for_convert.chars.map{|e| notation_from.index(e)} # разбиваем на цифры и переводим цифры в десятичные по индексам строки нашей системы исчисления
  base1 = notation_from.size # мерность системы исчисления 1
  num = arr.reverse.map.with_index{|n, i| n * base1**i}.sum # переводим n-сятки n-сотни n-тысячи в десятичные числа и складываем в итоговое десятичное число
  base2 = notation_to.size # мерность системы исчисления 2
  res = translator_from10_to_any(num, base2) # получаем n-сятки n-сотни n-тысячи нужной нам системы
  res.map{|i| notation_to[i]}.join # переводим цифры из десятичных в необходимые нам по индексам
end
allow = 'abcdefghijklmnopqrstuvwxyz' #=> набор символов представляющий цифры системы исчисления
hex = '0123456789abcdef'  #=> набор символов представляющий цифры системы исчисления
p convert("hello", allow, hex) #=> '320048'  # "hello" allow -> hex '320048'


puts
# Негапозиционная система исчисления это система исчисления по отрицательному основанию
# Негабинарная(negabinary) система исчисления(по основанию -2 аналогично бинарной по основанию 2)
#(bin) 6 = 1*(2)**2 + 1*(2)**1 + 0*(2)**0 = 110
#(neg) 6 = 1*(-2)**4 + 1*(-2)**3 + 0*(-2)**2 + 1*(-2)**1 + 0*(-2)**0 = 11010
#(neg) -6 = 1*(-2)**3 + 1*(-2)**2 + 1*(-2)**1 + 0*(-2)**0 = 1110
# В негабинарной системе положительные числа имеют нечетное число битов, а отрицательные четное

# https://www.youtube.com/watch?v=lasShmoSU1M

def negabinary_to_int(s, n_base=-2) # перевод из негапозиционной в десятичную(по умолчанию из негабинарной)
  s.chars.reverse.map.with_index{|n, i| n.to_i * n_base**i}.sum  # [0, -2, 0, -8, 16]( for 6 )
end
negabinary_to_int('11010') #=>  6
negabinary_to_int('1110')  #=> -6

def int_to_negabinary(i, n_base=-2) # перевод из десятичного числа в негапозиционную систему исчисления
  res = []
  until i == 0
    r = delenie_s_polozit_ostatkom(i, n_base)
    i = r[0]
    res << r[1]
  end
  res.reverse.join
end
int_to_negabinary(6)  #=> '11010'
int_to_negabinary(-6) #=> '1110'

# тк для перевода в негабинарную систему нам нужны всегда положительные остатки, то считаем их так.
# https://www.youtube.com/watch?v=lasShmoSU1M
def delenie_s_polozit_ostatkom(x, n_base=-2)
  if x.positive?
    cha = x / n_base.abs * (-1)
    ost = x % n_base.abs
  else
    cha = (x.to_f / n_base).ceil
    ost = x - n_base * cha
  end
  [cha, ost]
end


puts
# Запись отрицательных чисел в 2ичной системе без минуса для разной битовости методом "Дополнение до двух"
# https://en.wikipedia.org/wiki/Two's_complement#Converting_to_two's_complement_representation
def to_binary32(n)
  res = (n >= 0 ? n.to_s(2) : (2**32 + n).to_s(2))
  #res.size<32 ? '0'*(32-res.size)+res : res     (добавляем нули до 32х по желанию)
end
p (2**32-6).to_s(2) # 32bits -6 == "11111111111111111111111111111010"
p (2**8-6).to_s(2)  # 8bits -6 == "11111010"
p (2**3-6).to_s(2)  # 3bits -6 == "10"

# Обратное преобразование
def to_twos_complement(binary, bits)
  binary[-bits] == '1' ? (2**bits - binary.to_i(2)) * -1 : binary.to_i(2)
end
p to_twos_complement("11111111", 8) #=> -1
p to_twos_complement("11111110", 8) #=> -2


puts
puts '                                     Побитовые операторы(OR XOR & <<)'

# OR - побитовый оператор. В Руби обозначается "|"
# https://en.wikipedia.org/wiki/Bitwise_operation#OR
# OR - между битами в равной позиции выбирает бит 1 если он есть в одном из чисел, 0 только если у обоих в этой позиции 0
p 4 | 1 #=> 5


# XOR - исключа́ющее «или». В Руби обозначается "^"
# результат выполнения операции только тогда, когда один из аргументов истинен, а другой — ложен
p true ^ false  #=> true
p false ^ true  #=> true
p false ^ false #=> false
p true ^ true   #=> false
# Каждый ^ оценивается по одному справа налево
true ^ true ^ true ^ true ^ true #=> true
# Integer преобразуются побитово(сравнивает биты на одинаковых позициях)
p 0 ^ 1 #=> 1
p 1 ^ 0 #=> 1
p 1 ^ 1 #=> 0
p 0 ^ 0 #=> 0
p 2 ^ 2 #=> 0
p 2 ^ 3 #=> 1
p 65 ^ 123 #=> 58    оценивается каждый бит попарно

# Разница битов чисел
(a ^ b).to_s(2).count('1')

# Метод inject для OR/XOR
[false, true, true, true].inject(:^) #=> true
[false, true, true, true].inject(:|) #=> true


# & - оператор
p true & true  #=> true
p false & true  #=> false
p true & false  #=> false
p false & false #=> false
p 1 & 1 #=> 1
p 1 & 0 #=> 0
p 0 & 1 #=> 0
p 0 & 0 #=> 0
p 9 & 11 #=> 9 #=> '1001'&'1011' #=> 1001

# Сумма битов 1 в одинаковых позициях
(a & b).to_s(2).count("1")
(a & b).digits(2).sum


# << - оператор (добавляет n нулевых битов справа что равнозначно произведению числа и энной степени 2йки)
p 3 << 5     #=> 96   #=>  (2**5)*3
p 3.to_s(2)  #=> "11"
p 96.to_s(2) #=> "1100000"


# проверяет что единичные(1) биты не находятся в одной и той же позиции
4.nobits?(2) #=> true   '100' '10'
4.nobits?(5) #=> false  '100' '101'


# Перевод из big-endian(BE) в little-endian(LE) (меняем порядок байтов, где bits требуемая битность числа(кратная 8))
m = n.to_s(2)
m = '0' * (bits - m.size) + m
m.chars.each_slice(8).map(&:join).reverse.join.to_i(2)


puts
puts '                                             eval'

# Решение простых математических выражений представленных строкой
def calc(expression) # вар 1
  RubyVM::InstructionSequence.compile("1.0*" + expression).eval
end
def calc(expression) # вар 1
  eval("1.0*" + expression)
end
p calc('2 / (2 + 3) * 4.33 - -6')#7.732
p calc('2 /2+3 * 4.75- -6') # 21.25
p calc("(1 - 2) + -(-(-(-4)))") # 3.0
p calc('12* 123') # 1476.0















#
