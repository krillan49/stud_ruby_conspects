puts '                                      Математические действия/операторы'

# 1e10 == 1*10**10

# Большинство операторов на самом деле являются вызовами методов. Например, a + b интерпретируется как a.+(b), где метод + в объекте, на который ссылается переменная a , вызывается с b в качестве аргумента.


puts
# Арифметические операторы(+ - * / % **):
puts (2 + 3) * 5 - 6 * 2 # порядок действий идет как в математике. Скобки тоже как в математике

x, y, z = 5, 10, 11

# Сложение вычитание умножение:
puts x + y #=> 15
puts x - y #=> -5
puts x * y #=> 50

# Деление(целые числа на ноль делить нельзя, выдаст ошибку):
puts y / x #=> 2
# Перевод переменных во float(to_f), когда предполагается, что данные или результаты будут дробными
puts x.to_f / y.to_f #=> 0.5
# Для делителя и делимого класса Intejer деление будет целочисленным
270 / 100 #=> 2
270.0 / 100 #=> 2.7

# Возведение в степень:
2 ** 3 #=> 8

# деление с остатком(возвращен будет остаток от деления):
10 % 5 #=> 0 (нет остатка)
17 % 12 #=> 5
1 % 5 #=> 1

# Проверка на целочисленность/извлечение дробной части числа
2.1 % 1 #=> 0.10000000000000009
2.0 % 1 #=> 0.0

# деление нацело отрицательных чисел(тк деление нацело == деление+округление вниз, то отриц число округляется в большую сторону по своему модулю):
(-2.5).floor #=> -3
# Соответвенно получаем
5/-2 #=> -3
-5/2 #=> -3

# Нахождение остатка от деления на отрицательное число. Тк остаток от деления равен делимое минус результат целочисленного деления умноженного на делитель то получаем:
19/-5 #=> -4  результат целочисленного деления(рцд)
19-(-4)*(-5) #=> -1    тк  делимое==(рцд)*делитель+остаток  соотв  остаток==делимое-(рцд)*делитель
# соответсвенно получаем
19%-5 #=> -1


puts
# Операторы сравнения(возвращают true или false):
a, b = 10, 20
#`>` - больше
p a > b #=> false
#`<` - меньше
p a < b #=> true
#`==` - равно
p a == b #=> false
#`!=` - не равно
p a != b #=> true
#`>=` - больше или равно
p a >= b #=> false
#`<=` - меньше или равно
p a <= b #=> true
#`<=>` - (только руби) космический корабль (spaceship operator). Возвращает 1 если первое больше 0 если равно и -1 если меньше
p a <=> b #=> -1
#`===` - (только javascript) точно равно
#`!==` - (только javascript) точно не равно  При обычном сравнении в JavaScript вы можете сравнивать “слонов и мух” (число в виде строки и просто число) и вы получите положительный результат
# .eql? - Истинно, если получатель и аргумент имеют одинаковый тип и одинаковые значения.
p 1.eql?(1.0) #=> false


puts
# Для каждого оператора (+ - * / % ** & | ^ << >> && ||) существует соответствующая форма сокращенного оператора присваивания (+= -= и т. д.).
# Если действие происходит над одной переменной, например:
t = t + 20  #То запись можно сократить до
t += 20
# t = t + 1 - это увеличение числа на единицу без изменения переменной
# По аналогии t -= 20  t *= 20  t /= 20  t **= 20  t %= 20


puts
puts '                                            Математические классы'

# Простые дроби(класс Rational) и работа с ними(to_r)
Rational(1, 3) #=> (1/3)
1.5.to_r #=> (3/2)
['2/3', '1/4', '5/6'].map(&:to_r) #=> [(2/3), (1/4), (5/6)]
['-7/3', '-1/3', '-2/3'].map(&:to_r).sum #=> (-10/3)
['1/4', '5/4', '-1/2', '-1/1'].map(&:to_r).sum #=> (0/1)
10**(-1)    #=> (1/10)
10**(-1)+1  #=> (11/10)
10**(-1).to_f  #=> 0.1

# Особенности перевода
Rational(1.6) #=> (3602879701896397/2251799813685248)
1.6.to_r #=> (3602879701896397/2251799813685248)
Rational('1.6') #=> (8/5)
'1.6'.to_r #=> (8/5)


puts
# Комплексные числа
Complex(2, 0)  # => (2 + 0i)
Complex(2, 0).real #=> 2
Complex(2, 0).imaginary #=> 0


puts
# можно складывать, вычитать, умножать и делить разные типы чисел
2 + 2.0            # => 4.0
2 + Rational(2, 1) # => (4/1)
2 + Complex(2, 0)  # => (4+0i)


puts
# BigDecimal (подходит для огромных чисел с плавающей запятой, тк обычный float пишет infinity)
require 'bigdecimal'
p (BigDecimal("1.2")**10000).class #=> BigDecimal

# для перевода нужно дополнительно подключить, тогда require 'bigdecimal' уже не нужен?
require 'bigdecimal/util'
p 42.to_d #=> 0.42e2


puts
# Константа бесконечности
Float::INFINITY #=> Infinity
3 < Float::INFINITY #=> true
# Можно создать свою собственную константу:
PositiveInfinity = +1.0/0.0 #=> Infinity   # кастомная константа бесконечности положительных чисел
NegativeInfinity = -1.0/0.0 #=> -Infinity  # кастомная константа бесконечности отрицательных чисел
CompleteInfinity = NegativeInfinity..PositiveInfinity #=> -Infinity..Infinity


puts
# Модуль Math для математических операций
Math::E # константа е
Math::PI # константа пи

Math.sqrt(144) #=> 12 квадратный корень
Math.exp(Math.log(x)/3.0) # куб корень
y**(1/3.0) # альт куб корень
Math.exp(Math.log(x)/4.0) # корень 4й
y**(1/4.0) # альт корень 4й

Math.cbrt(64).round**3 #=> 64  проверка на куб корень

Math.log(10) # натуральный логарифм
Math.log10(1)  #=> 0.0
Math.log(8, 2) #=> 3.0
Math::log(8, 2) #=> 3.0


puts
puts '                                                 methods'

# достаточно одну из переменных поставить во флоат,  int + float = float
p 1 + 1.0 #=> 2.0

-14.84.abs() #=> 14.84  #Модуль числа
55.positive? #=> Returns true if self is greater than 0, false otherwise.
55.negative? #=> false
12.between?(10, 22) #=> true  # Лежит ли число между числами(включительно)
-14.84.abs().round() #=> 14 Можно задавать суффиксы сразу один за одним

# Округление
-14.84.round() #=> -14  #округление до целого
-14.84.round(1) #=> -14.8  #округление до энного порядка
(10.9999999999999).round(5) #=> 11.0
5.round(-1) #=> 10  #округление до более высокого порядка

# Округлкние вверх
0.2.ceil #=> 1
2001.ceil(-2) #=> 2100

# Округлкние вниз
0.7.to_i #=> 0
0.7.floor #=> 0
(-2.5).floor #=> -3   # Отрицательные числа округляются в обратную по модулю стиорону
1.6576597605.truncate(2) #=> 1.65  # Округление без изменений(обрезка до эн знаков после запятой)

# Обязательно 2 знака после запятой(недостающие дополняются нулями):
"#{'%.2f' % 1}" #=> "1.00"
"%02d%s" % ['1', ':00:01'] #=> "01:00:01"
"%02d%02d" % [5, 9] #=> "0509"
'%02X' % 15 #=> "0F"   # Перевод в 16ричное и добавление до 2х знаков

# наименьшее общее кратное
10.lcm(15) # => 30
[5, 3, 10, 2, 20].reduce(1) { |acc, n| acc.lcm(n) } # => 60
[5, 3, 10, 2, 20].reduce(1, :lcm) #=> 60
[5, 3, 10, 2, 20].reduce(:lcm) #=> 60

# следующее и предыдущее число после заданного делящиеся на заданные числа
d = x.lcm(y)
(n - 1) / d * d # пред
(n / d + 1) * d # след

# наибольший общий делитель
50.gcd(60) #=> 10
[25, 35, 10, 15, 20].reduce(:gcd) #=> 5


puts
puts '                                                     Prime'

require 'prime' # Для использования методов Prime необходимо подключить этот модуль

# Проверить простое число или нет
5.prime? #=> true
Prime.prime?(6) #=> false

# Первые n простых чисел
Prime.take(10) #=> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
Prime.first(10) # => [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# Массив всех простых чисел от 2 до n
Prime.entries(10) #=> [2, 3, 5, 7]
Prime.each(10).to_a #=> [2, 3, 5, 7]
# Массив всех простых чисел от m до n
Prime.entries(n)-Prime.entries(m-1) #=> быстрее чем (m..n).select(&:prime?)

# вернуть массив всех простых чисел до определенного значения
Prime.take_while{|p| p < 30} #+> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# Поиск простого числа по условию(ищет минимальное простое начиная от 0)
Prime.find{|p| p > n}

# разложение на простые множители. каждый вложенный массив содержит простое число и показатель степени, с которым оно входит в произведение
126.prime_division #=> [[2,1], [3,2], [7,1]]  # To есть 2**1 * 3**2 * 7**1

# Формула колличества всех делителей числа на основе числа простых делителей (n=p1**a1 * p2**a2 *...* pk**ak):
# t(n)=(a1+1)*(a2+1)*...*(ak+1). Далее пример для 126 (n=2**1 * 3**2 * 7**1): t(126)=(1+1)*(2+1)*(1+1)=12
126.prime_division.map{|a| a[1] + 1}.inject(:*) #=> 12

# сумма делителей(всех) числа(включая 1 и само число)
504.prime_division.map{|a| (a[0]**(a[1]+1)-1)/(a[0]-1)}.inject(:*) # 1560

# Все делители числа кроме 1 и самого себя
n = 765487649768760760767
arr = n.prime_division.map{|a| (1..a[1]).map{|i| a[0]**i}}
dels = (1..arr.size).map{|k| arr.combination(k).to_a}.flatten(1).map do |comb|
  comb.size == 1 ? comb.flatten : comb[0].product(*comb[1..-1]).map{|a| a.inject(:*)}
end.flatten.select{|e| e < n}
#=> результат за 2.741 seconds.

# восстанавливает исходное число из его сомножителей. Это именно метод класса, тк выступает в роли «конструктора» целого числа.
Integer.from_prime_division([[2,1],[3,1],[7,1]]) #=> 42


puts
puts '                                             Системы исчисления'

# Перевод десятичного числа в другую систему исчисления
25.to_s(2) #=>"11001"
25.digits(2) #=> [1, 0, 0, 1, 1]

# Чтобы рассматривать String как двоичное число, восьмеричное или шестнадцатеричное, нужно просто передать аргумент base= с подходящим числом в метод to_i:
"11".to_i            #=> 11   # по умолчанию как десятичное
"11".to_i(base=2)    #=> 3    # переводит из двоичной в десятичную(Integer)
"11".to_i(base=16)   #=> 17
'aa'.to_i(16)        #=> 170  # base= писать необязательно
"aB".to_i(16)        #=> 171  # регистр любой
# если мы используем to_i без указания основания или с основанием, которое не предусматривает таких символов, тогда вернется 0
"aB".to_i        #=> 0
"9".to_i(8)      #=> 0
# если не все символы могут быть сконвертированы в число to_i сконвертирует все 'digits' от начала до того места, где уже не будет понятно, что делать. Оставшаяся часть строки будет отброшена. Даже если там есть еще понимаемые значения.
"2x3".to_i       #=> 2
"2 3".to_i       #=> 2
'6jnkjnkj'.to_i  #=> 6
'afzzz'.to_i(16) #=> 175


puts
# ?? перевод дробей на примере 16ричной системы: Перевести число 0,2A9 из шестнадцатеричной системы в десятичную
# 0.2A916=0 ∙ 16**0 + 2 ∙ 16**-1 + A ∙ 16**-2 + 9 ∙ 16**-3 = 0 ∙ 1 + 2 ∙ 0.0625 + 10 ∙ 0.00390625 + 9 ∙ 0.000244140625 = 0 + 0.125 + 0.0390625 + 0.002197265625 = 0.16625976562510
n.chars.map.with_index(1){|e, i| e.to_i(16).to_f / 16**i}.sum


puts
# перевод из 10й системы исчисления в другую столбиком https://ege-study.ru/ege-informatika/sistemy-schisleniya-perevod-iz-odnoj-sistemy-v-druguyu/
# делим число на базу(в которую нужно перевести), остаток от деления будет последней цифрой нового числа, а результат от деления снова делим на базу, пока оно не станет равно ноль(меньшее разделится на большее)
def translator_from10_to_any(n, base)
  res = []
  until n == 0
    res.unshift(n % base)
    n /= base
  end
  res
end
# Пример конвертера использующего translator_from10_to_any
def convert(num_for_convert, notation_from, notation_to)
  return notation_to[0] if num_for_convert == '0'
  arr = num_for_convert.chars.map{|e| notation_from.index(e)} # разбиваем на цифры и переводим цифры в десятичные по индексам строки нашей системы исчисления
  base1 = notation_from.size # мерность системы исчисления 1
  num = arr.reverse.map.with_index{|n, i| n * base1**i}.sum # переводим n-сятки n-сотни n-тысячи в десятичные числа и складываем в итоговое десятичное число
  base2 = notation_to.size # мерность системы исчисления 2
  res = translator_from10_to_any(num, base2) # получаем n-сятки n-сотни n-тысячи нужной нам системы
  res.map{|i| notation_to[i]}.join # переводим цифры из десятичных в необходимые нам по индексам
end
allow = 'abcdefghijklmnopqrstuvwxyz' #=> набор символов представляющий цифры системы исчисления
hex = '0123456789abcdef'  #=> набор символов представляющий цифры системы исчисления
p convert("hello", allow, hex) #=> '320048'  # "hello" allow -> hex '320048'


puts
# Негабинарная(negabinary) система исчисления(по основанию -2 аналогично бинарной по основанию 2)
#(bin) 6= 1*(2)**2 + 1*(2)**1 + 0*(2)**0 =110
#(neg) 6= 1*(-2)**4 + 1*(-2)**3 + 0*(-2)**2 + 1*(-2)**1 + 0*(-2)**0 =11010
#(neg) -6= 1*(-2)**3 + 1*(-2)**2 + 1*(-2)**1 + 0*(-2)**0 =1110
# В негабинарной системе положит числа имеют нечетное число битов, а отрицательные четное

# https://www.youtube.com/watch?v=lasShmoSU1M

def negabinary_to_int(s, n_base=-2) # перевод из негабинарной в десятичную(для другой негабазы вместо -2 используем другое число)
  s.chars.reverse.map.with_index{|n,i| n.to_i*n_base**i}.sum  # [0, -2, 0, -8, 16]( for 6 )
end
negabinary_to_int('11010')# 6
negabinary_to_int('1110')#  -6

def int_to_negabinary(i, n_base=-2) # перевод из десятичного числа в негапозиционную систему исчисления(негабинарня частный случ)
  res=[]
  until i==0
    r=delenie_s_polozit_ostatkom(i, n_base)
    i=r[0]
    res << r[1]
  end
  res.reverse.join
end
int_to_negabinary(6)# '11010'
int_to_negabinary(-6)# '1110'

# тк для перевода в негабинарную систему нам нужны всегда положительные остати, то считаем их так.
def delenie_s_polozit_ostatkom(x,n_base=-2) # https://www.youtube.com/watch?v=lasShmoSU1M
  if x.positive?
    cha=x/n_base.abs*(-1)
    ost=x%n_base.abs
  else
    cha=(x.to_f/n_base).ceil
    ost=x-n_base*cha
  end
  [cha,ost]
end


puts
# https://en.wikipedia.org/wiki/Two's_complement#Converting_to_two's_complement_representation Запись отрицательных чисел в 2ичной системе без минуса для разной битовости методом "Дополнение до двух"
def to_binary32(n)
  res=(n>=0 ? n.to_s(2) : (2**32+n).to_s(2))
  #res.size<32 ? '0'*(32-res.size)+res : res     (добавляем нули до 32х по желанию)
end
p (2**32-6).to_s(2) # 32bits -6 == "11111111111111111111111111111010"
p (2**8-6).to_s(2) # 8bits -6 == "11111010"
p (2**3-6).to_s(2) # 3bits -6 == "10"

# Обратное преобразование
def to_twos_complement(binary, bits)
  binary[-bits]=='1' ? (2**bits-binary.to_i(2))*-1 : binary.to_i(2)
end
p to_twos_complement("11111111",8)# -1
p to_twos_complement("11111110",8)# -2


puts
puts '                                         Побитовые операторы(OR/XOR &)'

# Побитовый оператор OR  в Руби обозначается |  https://en.wikipedia.org/wiki/Bitwise_operation#OR
# между битами в равной позиции выбирает бит 1 если он есть в одном из чисел, 0 только если у обоих в этой позиции 0
p 4 | 1 #=> 5


# Исключа́ющее «или»(^ — это логический оператор XOR в Ruby) - в случае двух переменных(выражений) результат выполнения операции истинен тогда и только тогда, когда один из аргументов истинен, а другой — ложен
p true ^ false #=> true
p false ^ true #=> true
p false ^ false #=> false
p true ^ true #=> false
true ^ true ^ true ^ true ^ true #=> true # Каждый ^ оценивается по одному справа налево(true^true==false^true==true...)

# Integer преобразуются побитово(сравнивает биты на одинаковых позициях)
p 0 ^ 1 #=> 1
p 1 ^ 0 #=> 1
p 1 ^ 1 #=> 0
p 0 ^ 0 #=> 0
p 2 ^ 2 #=> 0
p 2 ^ 3 #=> 1
p 65 ^ 123 #=> 58    оценивается каждый бит попарно

# Метод inject для OR/XOR
[false, true, true, true].inject(:^)
[false, true, true, true].inject(:|)


puts
# Оператор &
p true & true #=> true
p false & true #=> false
p true & false #=> false
p false & false #=> false

p 1 & 1 #=> 1
p 1 & 0 #=> 0
p 0 & 1 #=> 0
p 0 & 0 #=> 0

p 9 & 11 #=> 9 #=> '1001'&'1011' #=> 1001


puts
# Разница битов чисел
(a ^ b).to_s(2).count('1')
# Сумма битов 1 в одинаковых позициях
(a & b).to_s(2).count("1")
(a & b).digits(2).sum


puts
# Оператор << n (добавляет n нулевых битов справа что равнозначно произведению числа и энной степени 2йки)
p 3 << 5 #=> 96   #=>  (2**5)*3
p 3.to_s(2) #=> "11"
p 96.to_s(2) #=> "1100000"


# проверяет что единичные(1) биты не находятся в одной и той же позиции
4.nobits?(2) #=> true   '100' '10'
4.nobits?(5) #=> false  '100' '101'


# Перевод из big-endian(BE) в little-endian(LE) (меняем порядок байтов, где bits требуемая битность числа(кратная 8))
m = n.to_s(2)
m = '0'*(bits-m.size)+m
m.chars.each_slice(8).map(&:join).reverse.join.to_i(2)


puts
puts '                                     Математика разное(формулы и готовые решения)'

# Рекурсивное сложение всех цифр в числе до однозначного
("1879-03-14".chars.sum(&:to_i) - 1) % 9 + 1


# 1 (mod N)   или  x ≡ 1 (mod N) может быть представлен как x % N === 1
def inverseMod(a,m)
  #a*x%m==1
  return nil if a.gcd(m)!=1
  return m if m==1
  m0, x, x0 = m, 1, 0
  while a>1
    x-=(a/m)*x0
    a, m = m, a%m
    x, x0 = x0, x
  end
  x<0 ? x+=m0 : x
end


puts
# Решение простых математических выражений представленных строкой
def calc(expression) # вар 1 (через нодежс ??)
  `echo 'console.log(#{expression})' | node`.to_f
end
def calc(expression) # вар 2
  RubyVM::InstructionSequence.compile("1.0*" + expression).eval
end
def calc(expression) # вар 3
  eval("1.0*" + expression)
end
p calc('2 / (2 + 3) * 4.33 - -6')#7.732
p calc('2 /2+3 * 4.75- -6') # 21.25
p calc("(1 - 2) + -(-(-(-4)))") # 3.0
p calc('-123') # -123
p calc('123') # 123
p calc('12* 123') # 1476


puts
# https://www.evkova.org/kombinatorika

# сочетания == комбинации, перестановки == пермутации

# число перестановок без повтора = n!
# число перестановок без повтора с неподвижными точками = n!/e
# число беспорядков https://ru.wikipedia.org/wiki/Беспорядок_(перестановка) Особым видом перестановки является та, в которой все ее элементы находятся в другом положении, чем исходное.
(2..n).map{|k| (-1)**k*(1..n).inject(:*)/(1..k).inject(:*)}.sum
(2..n).map{|k| k<n ? (-1)**k*(k+1..n).inject(:*) : k==n ? (-1)**k : 0 }.sum # быстрее

# Биномиальный коэффициент(сочетания/комбинации)(Binomial coefficient) — коэффициент перед членом разложения бинома Ньютона. Читается «биномиальный коэффициент из n по k или «число сочетаний из n по k» (C n-внизу k-вверху):  Cmn=n!/(m!(n-m)!)
# Равноценно arr.combination(k).to_a.size где  arr==(1..n).to_a
(1..n).inject(:*)/((1..k).inject(:*)*(1..n-k).inject(:*))

# Делится ли чисто сочетаний(тоесть количество подмножеств по k чисел из множества n чисел) на число num
def counter(m,num) # считаем число 2ек в каждом факториале формулы числа комбинаций
  sum2=0
  num0=num
  until m/num==0
    sum2+=m/num
    num*=num0
  end
  sum2
end
def subsets_parity(n,k,num) # (1..n).inject(:*)/((1..k).inject(:*)*(1..n-k).inject(:*))
  res=counter(n,num)-counter(k,num)-counter(n-k,num)
  res>0 ? 'Y' : 'N'
end
p subsets_parity(227337362, 189263427, 2) # 'Y'

# aCb := a * (a-1) * (a-2) * ... * (a-b+1) / b!  # для случаев когда только значение "a" целое, а значение "b" любое

# формула разложения (степенного 2члена) бинома Ньютона( (a+b)**n = sum(k=0..n){Ckn*a**(n-k)*b**k}).
(1..n-1).map{|k| [bin_coef(k, n), a*(n-k), b**k]} # Без 1го и последнего члена


# формула уникальных пермутаций из n групп одинаковых элементов по k штук в каждом == n**k
[["3", "3", "3"], ["7", "7", "7"], ["8", "8", "8"], ["1", "1", "1"]] #=> n==4 k==3 C==4**3

# Количество размещений([0, ... n-1].permutation(k).to_a.size) без повторений из n элементов по k определяется следующей формулой:
(1..n).inject(:*)/(1..n-k).inject(:*)

# формула уникальных пермутаций(перестановок символов) с повторяющимися элементами
# p=n! / (r1!*r2!*..*rn!) - где r число повторов элемента
el=2342
(1..el.to_s.size).inject(:*)/el.to_s.chars.uniq.map{|n| el.to_s.chars.count(n)}.map{|n| (1..n).inject(:*)}.inject(:*) #=>12(быстро)
(1..arr.size).inject(:*)/arr.uniq.map{|n| arr.count(n)}.map{|n| (1..n).inject(:*)}.inject(:*) # для массива

# Сумма чисел(самих чисел, полученных перестановками) всех перестановок цифр в числе
# https://translated.turbopages.org/proxy_u/en-ru.ru.0b77b025-637b8453-6f81ba1d-74722d776562/https/www.geeksforgeeks.org/sum-numbers-can-formed-permutations-n-digits/
k=n.digits.sum*(1..n.to_s.size-1).inject(:*)
(0..n.to_s.size-1).map{|e| 10**e*k}.sum


# http://bigor.bmstu.ru/?cnt/?doc=PO_CAD/5.1.mod/?cou=PO_CAD/base.cou (количество разбиений числа)

# Количество всех разбиений числа n на слагаемые(уникальные тк 1+1+2==2+1+1==1+2+1) => P(n,n) по формуле Эйлера
# https://neerc.ifmo.ru/wiki/index.php?title=Нахождение_количества_разбиений_числа_на_слагаемые
$ugol=[]
(1..100).map{|q| # генерация всех пятиугольных(?) чисел для скобок по формуле эйлера
  $ugol << (-1)**(q+1)*(-(3*q**2-q)/2)
  $ugol << (-1)**(q+1)*(-(3*q**2+q)/2)
}
$res=[1] # используем предыдущие кол разбиений для подсчета p(5)=p(4)+p(3)−p(0)
def exp_sum(n)
  m=$res.size-1
  until $res.size>=n+1
    m+=1
    res=0
    $ugol.each do |k|
      break if m<k.abs
      k.negative? ? res+=$res[m-k.abs] : res-=$res[m-k.abs]
    end
    $res << res
  end
  $res[n]
end

# генерация массивов разбиений числа (ср скорость ?)(https://www.codewars.com/kata/55cf3b567fc0e02b0b00000b/solutions/ruby)
$part={1=>[[1]], 2=>[[2],[1,1]], 3=>[[3],[2,1],[1,1,1]]}
def part(n)
  m=$part.keys.max
  until m>=n
    m+=1
    res=[[m]]
    (1..m-1).each do |k| # добавляем к каждому наибольшему числу меньшему чем N все варианты разбиений его разницы с N
      partm=$part[k].select{|a| a[0]<=m-k} # только те в которых все элементы меньше этого числа
      res+=[m-k].product(partm).map{|a| a.flatten}
    end
    $part[m]=res
    $prod[m]=res.map{|a| a.inject(:*)}.uniq.sort
  end
  $part[n].size # site тк сам вывод результата оч долгий тк Для n = 50 количество частей равно 204226, для 80 — 15 796 476
end


# Формула числа уникальных подмножеств в массиве начиная с пустого. [1, 2, 2] => {}, {1}, {2}, {1, 2}, {2, 2}, {1, 2, 2}.(6)
arr.uniq.map{|n| arr.count(n)+1}.inject(:*)
# Вариант с уникальными без повтора элементов. [1, 2, 2] => {}, {1}, {2}, {1, 2} (3)
arr.uniq.map{|n| arr.uniq.count(n)+1}.inject(:*)
2**arr.uniq.size # альт
# найти сами эти последовательности можно при помощи метода combination тк он сохраняет порядок(5 kyu Longest Common Subsequence)

# Формула всех непоследовательных подмножеств(все члены непоследовательны) чисел от 1 до n = сумме чисел фибоначи по число n


# генерация строки треугольника паскаля #nCr = (nCr(-1) * (n - r + 1))/r, где 1 ≤ r ≤ N   и  тС0 == 1
# строка треугольника паскаля это колличество подмножеств(1е значение число нулевых подмножеств, 2е- число подмножеств из одного элемента, 3е - число подмножеств из 2х элементов...)
# так же это коэфициенты многочлена получаемого из (a+b)**n
def paskal_line(n)
  res = [1]
  1.upto(n-1) do |x|
    res << res[-1]*(n-res.size)/res.size #nCr = (nCr(-1) * (n - r + 1))/r, где 1 ≤ r ≤ N
  end
  res
end
# сумма элементов диагонали треугольника Паскаля до элемента энной строки(нумерация от 0)
# 1 * (p+1)/1 * (p+2)/2 * (p+3)/3 * ... * (p+n)/n   формула энного элемента диагонали
def diagonal(n, p) # p номер диагонали, n номер строки
  m=n-p
  e,k=1,1
  res=[1]
  m.times do
    e=e*(p+1)/k
    res << e
    p+=1
    k+=1
  end
  res.sum
end
# короткий вариант
(1..n+1).last(p+1).reduce(:*) / (1..p+1).reduce(:*)


puts
# Сумма чисел от 1 до N, формула n*(n+1)/2

# колличество чисел от 1 до n делящееся на числа от a до z
n/(a..z).to_a.reduce(:lcm) # для простых чисел, вместо lcm просто их произведение

# Cумма чисел кратных m и n до числа x(включительно(если нет то x-1))
(1..x/n).sum*n + (1..x/m).sum*m - (1..x/(n*m)).sum*(n*m)

# Сумма n чисел делящихся на 3
3*(n/3).floor*(n/3+1).floor/2


# 1 3 6 10 15 21 ...
# Формула энного пятиугольного числа n*(3*n-1)/2
# Формула суммы первых к треугольных чисел  S = (n*(n+1)*(n+2))/6


puts
# Колличество прямоугольников(втч пересекающихся) в прямоугольнике (x**2+x)*(y**2+y)/4
# (x+1)*(y+1)*z + (x+1)*y*(z+1) + x*(y+1)*(z+1)  Число ребер в блоке включая внутренние

# число квадратов в сетке nxn
(1..n).map{|e| e**2}.sum # медленно
(n*(n+1)*(2*n+1))/6  # быстро
# число квадратов в сетке mxn
(0..[m,n].min).sum{|k| (n-k)*(m-k)}
y*(y + 1)*(3*x - y + 1)/6
# число прямоугольников в сетке mxn
m*(m+1)*n*(n+1)/4

# Формула путей вправо-вниз для квадратной сетки n*n  =>  (2*n)!/(n!)**2
(1..2*n).inject(:*)/(1..n).inject(:*)**2
# Формула путей вправо-вниз для прямоугольной сетки m*n
(1..m+n).inject(:*)/((1..m).inject(:*)*(1..n).inject(:*))
# Если есть оштбки с nil
mn=(1..m+n).inject(:*) || 1
mm=(1..m).inject(:*) || 1
nn=(1..n).inject(:*) || 1
mn/(mm*nn)


# сумма всех блоков пирамиды с высотой h  где начальные стороны w l а каждый след блок w2=w1+1 l2=l1+1
#(w..w+h-1).to_a.zip((l..l+h-1).to_a).map{|a,b| a*b}.sum
#h*w*l+(1..h-1).sum*w+(1..h-1).sum*l+(1..h-1).map{|k| k**2}.sum
h*w*l+(1..h-1).sum*w+(1..h-1).sum*l+(h-1)*(2*h-1)*h/6 # самое быстрое


# сколько клеток пересекает диагоняль в клетчатом прямоугольнике
h+w+h.gcd(w)-2 # вместе с касаниями по углам клеток(без 2 крайних точек)
h+w-h.gcd(w) # без касаний по углам клеток


puts
# На сумму последовательных положительных чисел можно разложить любое число кроме степеней 2йки

# Минимальное число послед чисел [n/2+1,n/2] if n.odd? а для четных просто делим на след число частей (на 3 на 4 итд) делаем эти числа последовательными и проверяем сумму( друг решения https://www.codewars.com/kata/59321f29a010d5aa80000066/solutions/ruby)

# максимальное число послед чисел: суммируем цифры с 1 до тех пор пока сумма не превысит n (для 25 это 1+2+3+4+5+6+7=28) если эта сумма больше заданного выбрасываем слагаемые слева, иначе добавляем следующее слагаемое справа, все это пока не получим n

# найти отсутствующее число в массиве последовательных чисел при помощи арифм прогрессии (s=(a1+an)*n/2)
(a[0]+a[-1])*(a.size+1)/2-a.sum


# разложить число на максимальную сумму квадратов если это возможно: находим корень из числа = k (1..k) суммируем квадраты первых чисел пока сумма не станет больше заданного числа тогда отнимаем из начала, если становится больше снова прибавляем числа дальше и так пока не будет равно числу.

# разложить число на все суммы 2х квадратов что возможно:
def all_squared_pairs(num)
  (0..((num/2)**0.5).floor).each.with_object([]) do |n,res| # (1..((num...
    r=(num-n**2)**0.5
    res << [r,n].sort if r%1==0  # return [r,n].map(&:to_i).sort if r%1==0
  end
end

# сумма последовательных квадратов чисел от 1 до n  ->  Sn=n(n+1)(2n+1)/6


puts
# Число цифр в факториале числа n
(Math.log10(2 * Math::PI * n) / 2 + n * Math.log10(n / Math::E)).ceil

# https://habr.com/ru/post/444112/    Подсчет конечных нулей факториала числа в любой системе счисления
require 'prime'
def factorial_tail_zeroes(base, n) # число нулей == коллич base на которые можно поделить факториал
  base.prime_division.map{|k,p| # колич base == минимальному из количеств множителей base
    x=Math.log(n, k).round(7).floor # считаем коллич простых множителей base в множителях факториала
    res=0
    until x==0 # считаем общее коллич простых множителей(например в 25 две 5)
      res+=n/k**x
      x-=1
    end
    res/p # делим на степень(число) у простого множителя base, тк их минимальное чило для получения факториала именно такое
  }.min
end
p factorial_tail_zeroes(16, 16)# 3, "16! has 3 zeroes"

# последняя ненулевая цифра факториала https://www.justquant.com/numbertheory/how-to-find-last-non-zero-digit-in-a-factorial/
# последняя цифра степени https://www.justquant.com/numbertheory/units-digit-of-a-number-raised-to-power/
# пример 2х этих   https://www.codewars.com/kata/5f79b90c5acfd3003364a337  6 kyu  Last non-zero digit of factorial


puts
#Нахождение последней цифры числа фебоначи с индексом i, начиная от 1 1 2...
q=5**0.5
(((1+q)/2)**(i%60)/q).round%10


# Сортировка чисел(разного порядка) чтобы собрать(сложив как строки) из них наибольшее число
array.map(&:to_s).sort{|a,b| b+a <=> a+b}.join.to_i


# формула ряда треугольника флоида по числу
Math.sqrt(n * 2).round
((1+Math.sqrt(1+8*(n-1)))/2).floor


# задачи про открывание и открывание n шкавчиков(сначала каждый потом через 1 потом через 2 итд) - в конце останутся элементы с индексами квадратов чисел от 1 до k**2<=n
(1..Math.sqrt(n).floor).size
Math.sqrt(n).floor # равнозначно тому что выше


# Входят или нет числа в бесконечную последовательность из которой удалили кажое 2е чисто, потом каждое 3е из оствшихся, потом каждое 4е из оставшихся итд до бесконечности (1,3,7,13...)
def survivor(n)
  k=2
  until k>n
    return false if n%k==0
    n-=n/k
    k+=1
  end
  true
end


# сумма индексов в d-мерном массиве где в каждой мерности по n элементов
n**d*d*(n - 1)/2


# все нечетные числа и все четные числа, кратные 4, могут быть выражены как разность двух совершенных квадратов.
# n/4+(n.odd? ? n/2+1 : n/2)


puts
puts '                                              Оператор rand'

# Оператор rand выдает случайное число
# По умолчанию это float  между 0 и 1
rand() #=> 0.2546047900803543

# доля
rand < 0.22 ? 6 : 7

# Оператор rand выдает случайное число в диапазоне от 0 до заданного числа минус 1(0...n)
puts rand(100) # Выдаст случайное число от 0 по 99

x = rand 5
puts x

puts rand(4..10) # Выведет случайное число от 4 до 10
puts 4 + rand(7) # тоже самое
puts rand(0.03..0.09) # работает и на float


# Альтернатива
lucky_number = (Kernel::rand() * 100 + 1).floor


puts
puts '                                    RUBY 2D Геометрия(классы Triangle, Vector и Point)'

# Расстояние между 2мя точками. ab=Math.sqrt((bx-ax)**2+(by-ay)**2+(bz-az)**2)

# if (x1-x3)*(y2-y3)-(x2-x3)*(y1-y3)=0 then('Точки лежат на одной прямой')

# площадь треугольника по 3м точкам:
# плоскость s=0.5*((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)).abs
# 3d https://s0.slide-share.ru/s_slide/4a8d2dcaa2f609dc7c78dfff36f7a247/6b2f60d8-3a5f-4a7b-8fd1-0894f3cedb1a.jpeg
[[[1,2,-4],[-3,2,4],[7,8,-4]], [[-3,-2,-6],[-1,-4,0],[2,1,-1]]].map do |(x1,y1,z1),(x2,y2,z2),(x3,y3,z3)|
  a=[x2-x1,y2-y1,z2-z1]#ab
  b=[x3-x1,y3-y1,z3-z1]#ac
  i=a[1]*b[2]-b[1]*a[2]
  j=b[0]*a[2]-a[0]*b[2]
  k=a[0]*b[1]-b[0]*a[1]
  s=0.5*(i**2+j**2+k**2)**0.5
end
# тоже при помощи матриц( единицы добавляем если координаты зет нету )(только для положительных резов ??)
require 'matrix'
list.each do |(x1,y1),(x2,y2),(x3,y3)|
  s=0.5*Matrix[[x1,y1,1],[x2,y2,1],[x3,y3,1]].det
end

# https://habr.com/ru/post/144571/  нахождение точки в пространстве
# (B[0]-A[0])*(C[1]-B[1])-(B[1]-A[1])*(C[0]-B[0]) с какой стороны от вектора AB находится точка C (положительное возвращаемое значение соответствует левой стороне, отрицательное — правой).

# Соотношение сторон в треугольнике всегда подчиняется следующему правилу: длина любой стороны треугольника не может быть больше суммы длин двух других сторон

# находится ли точка в треугольнике?  - считаются произведения (1, 2, 3 - вершины треугольника, 0 - точка):
a=(x1-x)*(y2-y1)-(x2-x1)*(y1-y)
b=(x2-x)*(y3-y2)-(x3-x2)*(y2-y)
c=(x3-x)*(y1-y3)-(x1-x3)*(y3-y)
# Если они(a b c) одинакового знака, то точка внутри треугольника, если что-то из этого - ноль, то точка лежит на стороне, иначе точка вне треугольника.

# декартовы координаты из угла(тут в радианах) и радиуса (угол относительно оси икс, нач коорд 0-0 если из друг точки просто прибавить их к икс и игрик)
def coordinates(angle, r)
  [r*Math.cos(angle/180.0*Math::PI), r*Math.sin(angle/180.0*Math::PI)]
end
# https://www.codewars.com/kata/5b40b666dfb4291ad9000049/train/ruby  (пример применения)

# Кол-во целочисленных(по координатам) точек в круге с центром в начале координат(Проблема круга Гаусса)
(-r..r).map{|i| ((r**2-i**2)**0.5).floor*2+1}.sum
(0...r).map{|i| ((r**2-i**2)**0.5).floor}.sum*4 + 1

# Проверить лежат ли точки на одной прямой(для целочисленных координат)
points.combination(3).map{|(x1,y1),(x2,y2),(x3,y3)| (x3*(y2-y1)-y3*(x2-x1)==x1*y2-x2*y1)}.all?

# https://www.ruby2d.com/learn/shapes/
# gem install ruby2d
require 'ruby2d'
# Класс Point имеет методы(переменные класса) .x .y .z выводящие соотв координаты
# Класс Triangle имеет методы(переменные класса) .a .b .c  выводящие точки(Point) углов
Triangle.new(Point.new(10, 10), Point.new(40, 10), Point.new(10, 50))
# Класс Vector имеет методы(переменные класса) .x .y .z выводящие


puts
# Построение выпуклой оболочки(самые внешние точки множества точек) обходом Грэхэма O (N log N)
# Алгоритм является асимптотически оптимальным (доказано, что не существует алгоритма с лучшей асимптотикой), хотя в некоторых задачах он неприемлем (в случае параллельной обработки или при online-обработке)

def clockwise?(x1, y1, x2, y2, x3, y3) # https://e-maxx.ru/algo/oriented_area
  s2=(x2-x1)*(y3-y1)-(y2-y1)*(x3-x1) # вычисляем удвоенную знаковую площадь треугольника
  s2<0 #  образует ли указанная тройка точек поворот по часовой стрелке
end

def point_reject(sn, pA, pB, n)
  # Чтобы получить, скажем, верхнюю оболочку, нужно отсортировать все точки по абсциссе, затем пройтись по всем точкам, рассматривая на каждом шаге кроме самой точки две предыдущие точки, вошедшие в оболочку. Если текущая тройка точек образует не правый поворот (что легко проверить с помощью Ориентированной площади), то ближайшего соседа нужно удалить из оболочки. В конце концов, останутся только точки, входящие в выпуклую оболочку.
  if n=='up' # верхнее подмножество
    sn=sn.sort_by{|x,y| [x,y]} # сортируем по абсциссе
    res=[pA, pB].sort_by{|x,y| [-x,-y]} # стартовые точки сортируем наоборот
  else # нижнее подмножество сортируем наоборот
    sn=sn.sort_by{|x,y| [-x,-y]}
    res=[pA, pB].sort_by{|x,y| [x,y]}
  end

  # алгоритм заключается в сортировке всех точек по абсциссе и двух (в худшем случае) обходах всех точек
  res=res+sn
  (res.size*3).times do # делаем несколько кругов
    clockwise?(res[0][0], res[0][1], res[1][0], res[1][1], res[2][0], res[2][1]) ? res.rotate! : res.delete_at(1)
  end
  res
end

def hull_method(points)
  points=points.uniq.sort
  # 1. Найдём самую левую и самую правую точки A и B (если таких точек несколько, то возьмём самую нижнюю среди левых, и самую верхнюю среди правых). Понятно, что и A, и B обязательно попадут в выпуклую оболочку
  pA=points.min_by{|x,y| [x,y]} # https://e-maxx.ru/algo/convex_hull_graham
  pB=points.max_by{|x,y| [x,y]}
  # 2. Далее, проведём через них прямую AB, разделив множество всех точек на верхнее и нижнее подмножества S1 и S2 (точки, лежащие на прямой, можно отнести к любому множеству - они всё равно не войдут в оболочку). Точки A и B отнесём к обоим множествам
  a, b, c = pB[1]-pA[1], pA[0]-pB[0], pA[1]*pB[0]-pA[0]*pB[1] # коэфы уравнения прямой ax + by + c = 0
  ups, downs, = [], [] # массивы для точкек верхней и нижней полуплоскости относительно прямой
  points.each do |x,y|
    sp=a*x+b*y+c # в зависимости от знака(ax+by+c>0 или <0) получаем полуплоскость относительно данной прямой
    downs << [x,y] if sp>0 #  ax+by+c>0  -  в нижней
    ups << [x,y] if sp<0 #  ax+by+c<0  -  в верхней
  end
  # 3. Теперь построим для S1 верхнюю оболочку, а для S2 - нижнюю оболочку, и объединим их, получив ответ.
  (point_reject(ups, pA, pB, 'up')+point_reject(downs, pA, pB, 'down')).uniq
end

hull_method([[4,4],[11,6],[1,19],[0,6],[4,16],[18,12],[1,4],[1,5],[16,20],[14,16], [0, 20], [0, 13]]).sort
# [[0, 6], [0, 20], [1, 4], [4, 4], [11, 6], [16, 20], [18, 12]]
