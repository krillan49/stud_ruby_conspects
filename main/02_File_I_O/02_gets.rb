puts '                             File I/O - Получение данных от пользователя'

# gets - get string(вводимые данные по умолчанию относятся к классу String). Оператор функции gets считывает строку из стандартного потока(принимает из стандартного устройства) ввода STDIN и помещает ее в массив указанный аргументом s.
print "Введите свое имя: "
name = gets()     # Передача значения gets переданного пользователем в переменную
puts name

# Можно использовать gets и без предачи значения в переменную, например для подтверждения исполнения дальнейшего кода(тк gets до нажатия паузит дальнейшее исполнение программы до нажатия )
print "Нажмите Enter для продолжения"
gets() # тут программа останавливается и ожидает ввода Enter


# gets + Enter #=> "\n" (Если ввести просто Enter без символов то возвращает символ перевода строки)

# Тк gets получает не только символы введенные с клавиатуры, но и информацию о нажатии Enter, соответственно в переменную присваивается не только введеный текст но и спецсимвол "\n". Для того, чтоб переход на новую строку не сохранялся можно воспользоваться строковыми методами chomp или strip
name = gets.chomp # chomp удалит только 1 последний спецсимвол
name = gets.strip # strip удалит все пробельные элементы в начале и конце строки

# gets.to_i + Enter #=> 0 (Если ввести в числовой ввод просто Enter без символов то возвращает цифру 0)
'jhgjhg'.to_i #=> 0

# to_i, to_f преобразуют строковый ввод в число, соответсвено при их использовании strip/chomp уже не нуэны
a = gets.to_i
b = gets.to_f
p a + b

# Можно производить операции прямо в сторке с оператором gets
line = gets.to_i - 1
line2 = gets * 2


# gets в итераторах
3.times.map{gets.strip} # вернет массив из 3х вводов



puts '                                             STDIN.gets'

# http://ruby.qkspace.com/ruby-chem-gets-otlichaetsya-ot-stdin-gets

# При вызове просто gets - будет вызван метод Kernel#gets, а этот метод в руби устроен довольно интересно. Если при запуске программы был передан аргумент (который позже можно получить в программе из массива ARGV), то он воспримет его как путь к файлу и попытается этот файл прочитать, а у пользователя в консоли ничего не просит.

# > ruby main.rb Привет
# Traceback (most recent call last):
#	2: from main.rb:1:in `<main>'
#	1: from main.rb:1:in `gets'
# main.rb:1:in `gets': No such file or directory @ rb_sysopen - Привет (Errno::ENOENT)

# Чтобы этого избежать, можно обратиться к методу gets объекта STDIN.


# STDIN — сокращение от STandarD INput — в данном случае консоль. Если вызвать метод STDIN.gets, то Руби вызовет этот метод у объекта стандартного ввода и будет совершенно точно читать именно из консоли, не отвлекаясь на ARGV.

input = STDIN.gets.chomp

# Правило буравчика: если ваша программа использует ARGV, вместо gets необходимо использовать STDIN.gets, если не использует — можно оставить gets, но если везде замените на STDIN.gets хуже не будет.



puts '                                         Стандартный вывод. ARGV'

# $stdout - глобальная переменная Руби указывающая на терминал, например когда по умолчанию мы пишем чтото в puts то это stdout

$stdout.print('some')

$stdout << "Top 50 words:\n"
top_words.each { $stdout << "#{_1.first} #{_1.last}\n"  }

$stdout << "\nLetters count:\n"
("A".."Z").each { $stdout << "#{_1} #{chars_count[_1]}\n"}


# ARGV - массив с параметрами ввода в строке вызова Руби-скрипта. По умолчанию параметры принимаются в виде строк

res = 0
ARGV.each do |par|
  res += par.to_i
end
p res
# > ruby test.rb 5 10 12
#=>

# Тоже самое ??
# > test3.rb -v 1 789





puts '                                           Гем io/console'

# Этот гем встроен в руби по умолчанию

require 'io/console' # подключение гема

# noecho - метод который позволяет не отображать символы в терминале во время ввода(например для введения пароля)
password = STDIN.noecho(&:gets).chomp













#
