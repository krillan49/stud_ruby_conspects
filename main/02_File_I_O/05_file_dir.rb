puts '                               File I/O: Работа с файлами и каталогами'

# (! нужно подключить какую-то библиотеку ??)
# Pathname - встроенный класс, который позволяет удобно работать с папками и фаилами в Руби как на никс системах так и на винде
full_path = Pathname.new(f) # передаем полный путь к фаилу

# (! fileutils - модуль для создания фаилов и директорий - потом какнить проверить)


# File - класc отвеч за раб с фаилами.
# Dir - класс отвеч за работу с директориями

# ВАЖНО: обрабатываются в путях только такие / слэши



puts '                                     Права доступа к фаилу в Linux'

# chmod - команда *никс систем для смены прав доступа к фаилу.

File.chmod 765 # команда Руби меняющая права доступа для фаилов

# $ chmod 765 file1.rb
# где значение 765 это новые параметры доступа к фаилу file1.rb

# Цифры параметра/прав доступа(например 765):
# 1я цифра - права доступа для owner(владелец фаила)
# 2я цифра - права доступа для group(группа)
# 3я цифра - права доступа для всех остальных
# Значения каждой из 3х цифр может быть от 0 до 7

# Каждая цифра в параметрах доступа означет 3хзначное двоичное число:
# 000 = 0, 001 = 1, 010 = 2, 011 = 3, 100 = 4, 101 = 5, 110 = 6, 111 = 7.
# где цифры 2ичного числа обозначают "rwx" (1я цифра - "r", 2я - "w", 3я - "x"), те r - четверки, w - двойки, x - единицы
# r - (read) возможность прочитать/открыть фаил
# w - (write) возможность записать/изменить в фаил
# x - (exequte) возможность запустить/исполнить фаил
# Каждое из этих свойств может быть включено или отключено - всего комбинаций 8(2**3)
# 1 в соотв положении значит включен режим, 0 - выключен.

# Соответсвенно 765 == (111 110 101) == (rwx rw- r-x) Тоесть владелец имеет полный доступ, группа не может исполнять, а остальные записать



puts '                                 > и >> (Сохранение в фаил в консоли)'

# Работает и в Дос и в Юникс. Это фича операционки а не Руби.

# >    - оператор перенаправления ввода. Перезаписывает фаил если он уже существует
# >>   - оператор перенаправления ввода. Не замещает фаил, а просто дописывает в конец уже существующего фаила.

# Если есть некий вывод в консоль и нужно сохранить его в фаил например:
a = gets.strip
puts "Your word is #{a}"
# Тогда в консоли нужно ввести: ruby имя_фаила_из_которого_берем_содержимое.rb > имя_фаила_куда_пишем.txt (или например .html)
# PS E:\doc\ruby_exemples> ruby example4m.rb > fale.html
# В итоге создается фаил содержащий результат вывода в консоли фаила example4m.rb



puts '                                  File. Режимы открытия/создания фаила'

# r	  (read) Открытие файла лишь для чтения. Курсор помещается в начало файла перед первым символом.
# r+  Открытие файла для чтения и записи. Курсор помещается в начало файла перед первым символом.

# w   (write) Открытие файла лишь для записи. Файл будет полностью перезаписан новой информацией. Если файла нет, то он будет создан.
# w+	Открытие файла для записи и чтения. Файл будет полностью перезаписан новой информацией. Если файла нет, то он будет создан.

# a   (append - добавить) Только запись в файл. Курсор будет поставлен в конце файла, если файл существует, в противном случае создается новый файл для записи. Данные записываются в конец фаила, после последнего символа либо с новой строки, если текстовый фаил сохранен с новой пустой строкой
# a+	Запись и чтение из файла. Курсор будет поставлен в конце файла, если файл существует, в противном случае создается новый файл для записи.

# b	  Режим двоичного файла (может использоваться с любой из перечисленных команд).
# t	  Режим текстового файла (может использоваться с любой из перечисленных команд, кроме «b»).



puts '                                 File.new (Создание фаила и методы чтения)'

# File.new - метод для открытия/создания фаила (объект File), не может принимать блок. Подходит для чтения, записи или того и другого одновременно, в зависимости от строки режима.

# Присваиваем объект фаила в переменную:
file = File.new("./text/simple.txt", "r") #=> #<File:./text/simple.txt>

# read - метод выдаст все содержимое фаила в формате строки
str = file.read #=> "вася вася возвращаемся\nпетя пертя помещается\nколя коля коля\n"

# Второе применение чтения фаила выдает пустую строку, тк он уже прочитан
file.read #=> ""

# Тк при помощи read мы получаем строку, то можем проделывать все строковые операции
str.include?("вася") #=> true

# readline - метод, читает фаил построчно, возвращает строку фаила в формате строки, если 1я строка уже прочитана, то прочитает следующую. Вернет ошибку если фаил уже до того полностью прочитан(построчно или при помощи read)
file.readline #=> "вася вася возвращаемся\n"
file.readline #=> "петя пертя помещается\n"
file.readline #=> "коля коля коля\n"
file.readline #=> end of file reached (EOFError)

# readchar - метод читает посимвольно, тоесть сначала 1й символ, 2й readchar прочитает 2й символ итд. После readline читает первый символ следующей строки.
file.readchar #=> "в"

# readlines - метод возвращает массив(соответсвенно можем применять к результату методы массивов или циклы), элементы которого это строки фаила. Так же как и предыдущие читает только недочитанную часть фаила, те с той строки или символа на котором отсановилось чтение. Не вызывает ошибку для уже прочитанного фаила
arr = file.readlines #=> ["вася вася возвращаемся\n", "петя пертя помещается\n", "коля коля коля\n"]

# sysread (метод системного чтения) - для чтения файла с возможностью указать колличество читаемых символов, указатель фаила останется на следующем символе. Можно открыть файл в любом из режимов. В случае 2хбайтовых символов число символов в выходной строке будет меньше, тк параметр это байты а не символы ??
file.sysread(7) #=> "Somethi"         # выведет первые 7 символов файла. Указатель теперь будет размещен на 8-м символе
file.read       #=> "ng\nSomethingSomething\nSomething"

# close - метод чтобы закрыть этот файл.
file.close



puts '                                    File.open (Создание/чтение фаила)'

# File.open - метод для открытия/создания фаила, может принимать блок, 1й параметр указывает на путь и имя фаила, а второй - режим в котором мы хотим войти.

# 1. Чтение фаила без блока, с присвоением объекта фаила в переменную
input = File.open("./text/simple.txt", "r")
# можно аналогично использовать все методы что и выше в File.new
input.close

# 2. Чтение фаила с блоком, закрывать при помощи close уже не нужно
File.open("./simple.txt", "r") do |file| # в переменную присвоится указанный фаил.
  # можно аналогично использовать все методы что и выше в File.new
  file           #=> #<File:./text/simple.txt>
  file.readchar  #=> "в"
  file.readline  #=> "ася вася возвращаемся\n"
  file.readlines #=> ["петя пертя помещается\n", "коля коля коля\n"]
  file.read      #=> ""
end



puts '                                      write, syswrite (Запись в фаил)'

# 1. Запись в фаил без блока:
output = File.open("./text/simple.txt", "w") # в режиме w

# p output.read #=> not opened for reading (IOError) # тк режим w не поддерживает чтение

# write - метод, записывает в фаил строку
output.write "Something"   # оператор write записывает в фаил строку "Something"
output.write "\nSomething" # можно пользоваться \n, чтоб записывалось с новой строки

# syswrite - метод системной записи
output.syswrite("ABCDEF") # выдает ошибку если исполняется перед этим метод write, но если метод write после syswrite то все работает нормально

output.close


# 2. Запись в фаил с блоком:
File.open("./simple.txt", "a+") do |file|
  p file.read #=> "Something\nSomething"
  file.write "ooo"
  file.write "\nKroker"
  p file.read #=> ""       # тк фаил уже перемотан в конец после записи, так былоб и без предыдущего чтения
end # Если повторить запуск, то запишется еще раз, после последнего символа. После запусков и записи фаил автоматически сохраняется


# 3. Запись в фаил помощи одного метода класса write. Создаст новый фаил, если такого нет
filename = "SOME_#{Time.now.strftime('%Y-%m-%d_%H-%M-%S')}.txt" # имя(относительный путь) для фаила уникальное при помощи даты
File.write(
  filename,              # имя(относительный путь) фаила
  "Текст для записи\n",  # собственно текст для записи
  mode: 'a'              # опция для типа записи (тут открыть файл только для записи и дописывать в конец фаила)
)



puts '                             Альтернативный способ чтения и записи(file.gets)'

# 1. Чтение фаила строка за строкой
input = File.open "./text/simple.txt", "r"
# file.gets читает строку из файлового объекта file, делаяя ее прочитанной
p input.gets #=> "Something\n"
while (line = input.gets) # тоесть по условию цикла, при каждой итерации читаем строку из фаила и передем ее в переменную, до тех пор пока фаил содержит непрочитанные строки
  p line #=> "SomethingSomething\n"  => "Something"
end
input.close


# Другие примеры в Lessons18.rb


# Пример: подсчет суммы числел в фаиле вида "200, cats\n100, dogs\n"
input = File.open "list.txt", "r"
n = 1
sum = 0
while (line = input.gets)
	puts "#{n} #{line}"
	sum += line.split(',')[1].to_i
	n += 1
end
puts "\nTotal sum = #{sum}"
input.close


# Пример 2: выборка из фаила и запись в другой фаил
input = File.open("passwords.txt", "r")
arr = []
while (line = input.gets)
  arr << line if line.chomp.size == 6
end
input.close

output = File.open("pass_output.txt", "w")
arr.each do |str|
  output.write(str)
end
output.close



puts '                                            File методы'

# Работа со строкой пути фаила
file = "./text/simple2.txt"
File.basename(file)                  #=> "simple2.txt"
File.basename(file,".txt")           #=> "simple2"       # 2й аргумент удаляет расширение
File.extname(file)                   #=> ".txt"
File.dirname("/var/www/test.txt")    #=> /var/www        # Получение директории без имени файла

# Переиминовывает file1 в file2
File.rename 'file1.ext', 'file2.ext'

# удаления существующего файла tekst2.txt
File.delete("tekst2.txt")



puts '                                          Методы класса IO'

# Класс File является подклассом класса IO. Класс IO также имеет несколько методов, которые можно использовать для управления файлами.

# IO.readlines . Этот метод возвращает содержимое файла построчно в виде массива
arr = IO.readlines("./text/simple.txt")
arr[0] #=> "Работа с файлами это распространенная вещь в программировании. Нам постоянно ... "

# IO.each - метод читает фаил построчно выгружая из памяти уже прочитанные строки, что позволяет экономить память при работе с большими фамлами
File.new("./simple.txt").each do |line|
  p line #=> "ABCDEFSomething\n" => "SomethingSomething\n" => "Somethingooo\n" => "Kroker"
end

# IO.foreach. Этот метод также возвращает вывод построчно, но метод foreach связан с блоком и не возвращает массив.
IO.foreach("./text/simple.txt"){|line| p line} #=> "ABCDEFSomething\n", "ABCDEFSomething\n", ...



puts '                                        Методы информационные'

# File.exist? проверяет, существует ли файл, например перед открытием (новые версии Руби)
File.exist?('test3.rb') #=> true
File.exist?('test5.rb') #=> false

# File::exists? проверяет, существует ли файл перед его открытием (старые версии Руби)
File::exists?("file.rb")

# выясняет, действительно ли файл является файлом
File.file?("ruby_exemples/text/simple.txt") #=> true

# определяет, является ли данное имя файла каталогом
File::directory?("/usr/local/bin") #=> true
File::directory?("file.rb")        #=> false

# доступен ли файл для чтения, записи или исполняемого файла
File.readable?("test.txt")   #=> true
File.writable?("test.txt")   #=> true
File.executable?("test.txt") #=> false

# имеет ли файл нулевой размер или нет
File.zero?("test.txt")      #=> true
# возвращает размер файла(??)
File.size?("text.txt")      #=> 1002

# определяет тип файла, возвращая одно из следующих значений: file, directory, characterSpecial, blockSpecial, fifo, link, socket, or unknown.
File::ftype("test.txt")     #=> file

# определения времени создания, изменения или последнего доступа к файлу
File::ctime("test.txt") #=> Fri May 09 10:06:37 -0700 2008
File::mtime("text.txt") #=> Fri May 09 10:44:44 -0700 2008
File::atime("text.txt") #=> Fri May 09 10:45:01 -0700 2008



puts '                                                Разное'

# Решение ошибок разных версий Руби с методом File::exists?('test.rb') / File.exist?('test.rb')
def file_exists?()
  begin
    File::exists?('test.rb')
  rescue NoMethodError => e
    if e.message.include?("undefined method `exists?' for File:Class")
      File.exist?('test.rb')
    else
      raise NoMethodError, e.message
    end
  end
end



puts '                                              Dir Каталоги'

# Все файлы находятся в разных каталогах, каталоги обрабатываются классом Dir

# pwd - метод вернет текущую директорию. Процесс, все его действия в файловой системе происходят относительно какого-то места, оно и называется текущим каталогом после запуска обычно оно равно местоположению программы
Dir.pwd #=> E:/doc

# chdir - метод изменения текущей директории директорию(можно указать и относительный и полный путь), если такой директори не существует выдаст ошибку
Dir.chdir "E:/doc"
p Dir.pwd #=> "E:/doc"
# Пример с неполным путем: будет изменение на текущий относительный + новый
Dir.chdir("Projects")
p Dir.pwd #=> "E:/doc/Projects"

# entries - метод вернет все фаилы и директории в виде массива строк
Dir.entries "E:/doc" #=> [".", "..", "cs_conspects", "Docker", "Frontend_stud", "js_conspects", "linux_conspects", "Projects", "ruby_exemples", "sinatra-bootstrap-clean", "sql_conspects", "всякие фаилы", "всякие_тесты", "комп", "текст"]
Dir.entries "E:/" #=> ["$RECYCLE.BIN", "8oxGZWzhLIY.jpg", "doc", "doc разное", "games", "iso images", "msdownld.tmp", "pic", "programs", "shulman.mp4", "System Volume Information", "видео", "гитхаб.png", "загрузки", "книжки", "музыка", "Фон.jpg", "хлам", "чат.png"]
# (Особенность: "E:"(без слэша) выдает из текущей директории)
Dir.entries "E:" #=> [".", "..", ".git", ".gitignore", "1ruby_scool_dz", "1zadachniky", "main", "Methods", "pet_progects", "pet_sobes", "Rails", "simple.txt", "Sinatra", "test.rb", "test2.rb", "test3.rb", "test4.rb", "web"]

# children - метод вернет все фаилы и директории за исключением "." и ".."
Dir.children("E:") #=> ["pic", "ruby_exemples", "Гайд шатдаун DOXAхРоскомсвобода 27.02.2022.pdf", "ГВД", "з.txt", "мма", "паспорт", "покер", "текст", "учеба"]

# mkdir - метод создает новую директорию по указанному пути
Dir.mkdir("new_dir")

# delete - метод удаляет директорию по указанному пути, директория должна быть пустой
Dir.delete("new_dir")

# empty? - метод проверяет пустая ли директория
Dir.empty?("new_dir")

# foreach - итерация по папке с получением имен файлов и директорий в заданной папке. Во вложенных директориях файлы показаны не будут (не рекурсивно).
Dir.foreach("test_dir") do |entry|
  puts entry
end



puts '                                Dir.glob(Зекурсивный поиск по директориям)'

# Тоже самое что выше в foreach, но умеет работать рекурсивно и фильтровать выборку.
contents = Dir.glob("**/*")
# ** - все директории любой вложенности (рекурсия)
# *  - условия выборки(* - все, *.txt - только .txt)
contents.each do |entry|
  puts entry
end

# Поиск фаила(пути к фаилу) по полному имени с расширением
Dir.glob('E:/**/Heather Locklear.jpeg')   #=> ["E:/doc/pic/pictures/неон/Heather Locklear.jpeg"]
Dir.glob('E:/**/*/Heather Locklear.jpeg') #=> ["E:/doc/pic/pictures/неон/Heather Locklear.jpeg"]

# Поиск по части имени
Dir.glob('E:/**/*Locklear*') #=> ["E:/doc/pic/pictures/неон/Heather Locklear.jpeg"]

# Поиск фаилов по расширению
Dir.glob('E:/**/*.jpg') #=> ["E:/$RECYCLE.BIN/S-1-5-21-1390554581-1841657848-2307281156-1001/$IRVMUGP.JPG", "E:/doc/pic/foto/фотки/2002-2011/2002 общага 49я/x_45bc2ccf.jpg", "E:/doc/pic/foto/фотки/2002-2011/2002 общага 49я/x_52b287d7.jpg", "E:/doc/pic/foto/фотки/2002-2011/2002 общага 49я/x_8e5a3fe1.jpg", ... и так далее все фаилы на диске с таким расширением



puts '                                   Создание временных файлов и каталогов'

# Временные файлы — это файлы, которые могут создаваться на короткое время во время выполнения программы, но не являются постоянным хранилищем информации.


Dir.tmpdir #предоставляет путь к временному каталогу в текущей системе, хотя по умолчанию этот метод недоступен. Чтобы сделать Dir.tmpdir доступным, необходимо использовать require 'tmpdir'.
# Можно использовать Dir.tmpdir с File.join для создания независимого от платформы временного файла:
require 'tmpdir'
tempfilename = File.join(Dir.tmpdir, "tingtong")
tempfile = File.new(tempfilename, "w")
tempfile.puts "This is a temporary file"
tempfile.close
File.delete(tempfilename)
# Этот код создает временный файл, записывает в него данные и удаляет его.


# Стандартная библиотека Tempfile может создавать временные файлы:
require 'tempfile'
f = Tempfile.new('tingtong')
f.puts "Hello"
puts f.path
f.close













#
