puts '                                  Объектно-ориентированное программирование(ООП)'

# Доп информация по теме:
# https://vk.com/@physics_math-skryvaite-sekrety-inkapsuliruite-detali-realizacii  "Скрывайте секреты. Инкапсулируйте детали реализации"

# ООП (объектно-ориентированное программирование) - парадигма программирования. Помогает дробить программу на отдельные части(классы, ), которые более удобны и понятны для разработчика

# Методы, Классы, Модули - это абстракция, которая существует только для программиста, чтоб облегчить ему жизнь.

# Основная задача ООП — избавиться от дублирования кода, упростить систему, сделать ее более поддерживаемой, и сократить финансовые расходы на разработку.
# Основные методы ООП - инкапсуляция данных, абстракция данных, полиморфизм и наследование.

# Ключ к эффективному созданию объектно-ориентированных программ заключается в том, чтобы не усложнять архитектуру, а упрощать

# В Ruby все что написано с большой буквы - это константа. Передать из файла в файл при помощи require можно только константы. Поэтому классы с маленькой буквы хоть и возможны (при помощи метапрограммирования), но бессмыслены с практической точки зрения

# Класс - это определенная зона ответсвенности как скоуп и в идеале каждый класс должен делать чтото одно, один тип действий

# Все классы наследую у классов Object и BasicObject



puts '                                              Классы и объекты'

# Класс - это тип данных(Например встроенные клаасы в Ruby: Integer, String, Array итд). Этот тип данных может быть наш собственный, все параметры и характеристики которого мы задаем сами при помощи переменных и методов. Когда мы создаем объекты(экземпляры класса/class instance), принадлежащие классу(нашему типу данных), то они будут обладать всеми характеристиками и параметрами, которые были заданы классом. Впоследсвии удобно добавлять характеристики уже существующим объектам, просто добавляя их в класс, а не в каждый объект отдельно.

# классы содержат данные, имеют методы, которые взаимодействуют с этими данными и используются для того, чтобы создавать объекты на основе этих классов

# Класс это по простому шаблон/чертеж/иструкция для создания объекта.
# Объект так же называется - экземпляр(instance) класса. Отдельные объекты занимают отдельные ячейки памяти и никак не связаны, кроме принадлежности к клессу.
# для некоторых - это коренной класс Руби Object

# Методы и функции, а также поля и переменные это одно и тоже. В классах функции называются методами, а переменные называются полями, но работают они одинаково.

class MyAnimal # Классы называют существительными в единственном числе, каждое слово с большой буквы без разделения пробелами.
  def run # В класс можно помещать методы(любое коллич), которые будут работать при вызове от любых объектов класса
    name = 'Muska'
    puts "#{name} run!!!"
  end
end # Классы необходимо закрывать

# Объекты/образцы/экземпляры класса создаются вне класса при помощи метода new и их можно присвоить в переменные:
dog = MyAnimal.new # Новый объект класса задается в переменную dog.
# При этом переменная dog не «содержит» сам объект, это просто ссылка на объект, на область памяти где на самом деле этот объект хранится. Мы можем иметь любое количество переменных, указывающих на один и тот же объект, захотим и присвоим другой переменной kroker9000 значение из переменной dog: kroker9000 = dog

# Вызов метода экземпряра класса для этого объекта класса. Тоесть метод на который отвечает объект. Тоесть у самого экземпляра есть этот метод, а не у класса(?)
dog.run #=> "Muska run!!!"

# Объектов можно создать сколько угодно
cat = MyAnimal.new # new - это выделение памяти. Теперь этот созданный объект имеет все переменные заданные классом
cat.run #=> "Muska run!!!"

# Альтернативный способ создания объекта с одновременным вызовом метода без присваивания объекта в переменную
MyAnimal.new.run #=> Muska run!!!

# Проверим класс объектов
dog.class #=> Animal
# Возвращает индентификатор объекта
dog #=> #<Animal:0x000001fa1ac61928>  (класс и ссылки на ячейки памяти в которых располагается объект, где 0x обозначает 16ричное число)

# Проверим наличие метода в классе
p MyAnimal.instance_methods #=> массив со всеми методами доступными объектам класса(например __id__)
p MyAnimal.methods  #=> массив со всеми методами доступными классу(как созданными так и встроенными)
p MyAnimal.instance_methods.include?(:run)  # => true


puts
# Можно обращаться к методу класса в теле класса как обычному методу, например в другом методе класса
class Animal
  def run
    puts "I am runing"
  end

  def eat
    print 'I am eating '
    run # вызываем метод класса run в теле метода eat, теперь метод при вызове от объекта вызовет и метод run
  end
end
cat = Animal.new
cat.run #=> "cat is runing"
cat.eat #=> "I am eating I am runing"  # Метод eat исполнил и метод run


puts
# Обычная переменная заданная внутри метода будет существовать только внутри него, чтобы задать переменную доступную для всего класса, нужно сделать ее переменной экземпляра/instance variable класса (глобальной переменной внутри класса). “@” (читается как “at”). Переменная экземпляра класса будет "глобальной" только внутри тела этого класса
class Xuinya
  def z
    @zz = 44 # Инициализация переменных методом для объекта происходит только в момент вызова метода объектом
    puts "zz #{@zz} zz"
  end

  def x
    puts "xx #{@zz} xx"
  end
end

xuy = Xuinya.new
pen = Xuinya.new
xuy.x #=> "xx  xx"    #Переменная @zz не отображается, тк не инициализировалась, потому что метод z еще не вызывался для данного объекта
xuy.z #=> "zz 44 zz"  #Тут переменная инициализируктся, тк вызван метод в теле которого она задана
xuy.x #=> "xx 44 xx"  #Теперь она доступна и для других методов этого объекта
pen.x #=> "xx  xx"    #Но для другого объекта переменнаую снова нужно инициализировать

xuy.instance_variables #=> [:@zz]   # список переменных экземпляра доступных объекту
xuy.instance_variable_get(:@zz) #=> 44   # получить переменную экземпляра
# так же в методах класса (Name.new.methods) можно посмотреть и другие методы


puts
puts '                                         Три способа вызвать метод в Руби'

# На примере метода object_id объекта класса Object
object = Object.new
p object.object_id                #=> 60
p object.send(:object_id)         #=> 60
p object.method(:object_id).call  #=> 60


puts
puts '                                           Конструктор(initialize)'

# Конструктор - это специальный метод внутри класса, выполняются каждый раз, когда мы создаем новый объект, те программа конструктора при запуске автоматически(не нужено к нему обращаться от объекта) сработает для каждого обьекта, когда мы вызываем метод new от класса. Нужен для того, чтобы определить начальное состояние объекта(например для инициализаций переменных необходимых для работы класса).
# Конструктор задается только методом с именем initialize - которое зарезервировано и означает, что этот метод - конструктор.
class Gopota
  def initialize
    puts "hello" # Конструктор сработает автоматически для каждого созданного объекта те при 2х объектах как у нас, hello выведет для каждого из них.
  end
end
vasyan = Gopota.new #=> "hello" # .new вызывает метод конструктора(initialize)
dimon = Gopota.new #=> "hello"


puts
# Конструктор с переменной: удобнее всего переменную экземпляра класса задать в конструкторе, а не в одном из методов класса тк в конструкторе она будет инициализированна автоматически в момент создания объекта методом new
class Book
	def initialize
		@notebook = {} # Инициализируем переменные, теперь они доступны для всех методов класса в момент создания объектов
    @last_person = ''
	end

	def add_person(options) # Передача options в метод при вызове метода от объекта класса.
		puts 'Its name alredy exist' if @notebook[options[:name]]
		@notebook[options[:name]] = options[:age]
    @last_person = options[:name]
	end

  def show_hh # необходим метод для обращения к переменной(если нет атрибутов)
    @notebook
  end
  def show_last_person
    @last_person
  end
end

b = Book.new
b.add_person name: 'Mike', age: 55 # Передаем options в метод
# Чтобы обратиться к переменной заданной в классе, нужно сделать это через метод(предварительно его создав)
b.show_hh #=> {"Mike"=>55}
b.show_hh['Mike'] #=> 55  # можно обращаться к методам возвращаемых объектов
puts "Last person is #{b.show_last_person}" #=> Last person is Mike


puts
# Передача параметров в конструктор:
class Bbro
  def initialize(helmet, shild, weapon, loot) # Mожно передавать параметры в конструктор, так же как и в методы, данные должны передаваться из созданного объекта тк конструктор срабатывает автоматически для каждого объекта
    puts "Helmet(#{helmet} armor), shild(#{shild}% block), weapon is #{weapon}, loot is #{loot}"
  end
end
hedge_knite = Bbro.new(150, 50, 'Noble sword', 'gold') # Передаем данные для полученных конструктором переменных в скобках
#=> "Helmet(150 armor), shild(50% block), weapon is Noble sword, loot is gold"


puts
# Установка в переменные экземпляра данных, переданных объектами в консруктор
# Переменные образца класса являются атрибутами, тк сохраняют свое состояние для образца класса
class Car
  def initialize(sp, tur_sp, mod, col) # Так же как и в обыч методах называть переменные можно как угодно
    @speed = sp  # Устанавливаем значения параметров конструктора значениями в переменные класса. Теперь мы можем использовать эти значения в других методах класса.
    @model = mod
    @color = col
    @trak_speed = sp + tur_sp
  end

  def fastcar? # Проверим больше ли значение переменной @trak_speed чем 270 для выбранных объектов.
    @trak_speed > 270
  end

  def to_info # метод для наглядного вывода характеристик объектов класса
    "Car: #{@model}(#{@color}) #{@speed} km\\h"
  end
end

bmw = Car.new(230, 60, "X5", "Black") # Передаем данные в параметры конструктора.
audi = Car.new(190, 70, "A100", "White")
# Данные атрибутов сохраняются отдельно в областях памяти приписанных этим объектам, тоесть это данные объектов

bmw.fastcar? #=> true  # Вывод для метода fastcar?, его в отличие от конструктора нужно вызвать.
"Audi is fast car? #{audi.fastcar?}" #=> "Audi is fast car? false"
audi.to_info #=> Car: A100(White) 190 km\h

audi #=> #<Car:0x00000259fb965558>
audi.inspect #=> #<Car:0x0000028c6f4ed150 @speed=190, @model=\"A100\", @color=\"White\">



puts
puts '                                          Состояние объекта (state)'

# Основное отличие объектно-ориентированного языка от необъектно-ориентированного в том, что в объектно-ориентированном языке есть такое понятие как состояние объекта.
# Состояние объекта - это совокупность значений всех характеристик объектва в данный момент.
class Car
  def initialize # Конструкор задает состояние объекта по умолчанию(значение переменных класса)
    @state = :closed
  end

  def open # Метод меняющий состояние объектов(меняет значение переменной класса для объекта)
    @state = :open
  end

  def how_are_you # Метод сообщающий о состоянии объектов
    puts "My state is #{@state}"
  end
end
car1 = Car.new
car1.how_are_you #=> My state is closed

car2 = Car.new
car2.open # Меняем состояние объекта car2 при помощи метода меняющего значение переменной класса для этого объекта
car2.how_are_you #=> My state is open


puts
puts '                                 Setter methods(методы установки) и инкапсуляция'

# Способы присвоения новых значений переменных при помощи методов, name_method= и конструктора.
# Виртуальные переменные класса и скрытая функциональность.
# Инкапсуляция (encapsulation) - относится к объединению данных с методами, которые работают с этими данными, или к ограничению прямого доступа к некоторым компонентам объекта. Инкапсуляция используется для сокрытия значений или состояния объекта структурированных данных внутри класса, предотвращая прямой доступ к ним клиентов таким образом, чтобы это могло раскрыть скрытые детали реализации или нарушить инвариантность состояния, поддерживаемую методами.
class Song
  def initialize(duration)
    @duration = duration
  end
  # accessor/getter methods (методы доступа)
  def duration
    @duration
  end
  # setter methods (методы установки)
  def new_duration(new_duration) # 1й способ привоения новых значений, стандартный
    @duration = new_duration
  end
  def duration=(new_duration) # 2й споcоб, через метод имя которого оканчивается на =
    @duration = new_duration
  end

  #Методы доступа к атрибутам не обязательно должны быть просто оболочками вокруг переменных экземпляра объекта. Например, вы можете получить доступ к продолжительности в минутах и долях минуты, а не в секундах, как мы это делали.
  def duration_in_minutes
    @duration/60.0   # не меняя или добавляя новую переменную вводим новую функциональность(создание виртуальной переменной экземпляра). Для пользователя продолжительность в минутах кажется таким же атрибутом, как и любой другой. Однако внутри нет соответствующей переменной экземпляра.
  end
  def duration_in_minutes=(value)
    @duration = (value * 60).to_i
  end
end
aSong = Song.new(260)
aSong.duration #=> 260
aSong.new_duration 240 # 1й способ
aSong.duration #=> 240
aSong.duration = 257  # 2й споcоб. Присвоение aSong.duration = 257 вызывает метод duration= в объекте aSong, передавая ему 257 в качестве аргумента. Фактически, определение имени метода, заканчивающегося знаком равенства, делает это имя подходящим для отображения в левой части присваивания.
aSong.duration #=> 257

aSong.duration_in_minutes #=> 4.283333333333333
aSong.duration_in_minutes = 4.2
aSong.duration #=> 252

#Скрывая разницу между переменными экземпляра и вычисляемыми значениями, вы защищаете остальной мир от реализации вашего класса. Вы можете свободно изменять то, как все работает в будущем, не влияя на миллионы строк кода, которые используют ваш класс.


puts
puts '                             Методы объекта .respond_to?() .instance_variables'

# .respond_to?('name')/.respond_to?('name=') - метод проверки наличия указанного метода в клаасе. Возвращает true, если obj отвечает на данный метод. Закрытые и защищенные методы включаются в поиск только в том случае, если необязательный второй параметр имеет значение true.(respond_to?(p1, p2 = v2) public) Когда параметр имени метода задается в виде строки, строка преобразуется в символ.
# .instance_variables - метод выводит массив всех доступных объекту переменных экземпляра в виде символов

class Aaaa
  def initialize(par)
    @per = par
    @arr = []
  end
  def massive
    @arr
  end
  def change=(e)
    @arr << e
  end
end
aaa = Aaaa.new(1)

aaa.respond_to?('massive') #=> true
aaa.respond_to?('vvv') #=> false
aaa.respond_to?('change=') #=> true
aaa.respond_to?('change') #=> false
aaa.respond_to?('massive', 'change=') #=> true
aaa.instance_variables #=> [:@per, :@arr]


puts
puts '                         Атрибуты: attr_reader, attr_writer и attr_accessor. Свойства класса'

# Свойства класса - переменные класса заданные атрибутами. Свойства класса позволяют обращаться к переменным класса от объектов(читать и менять состояние объектов) без необходимости задавать отдельные методы.
# Есть 3 ключевых слова для добавления переменных(свойств класса) - attr_reader, attr_writer и attr_accessor.
# Когда мы обявляем attr_ конструкцию, то автоматически создаются метод(ы) для каждой переменной(name= для writer; name для reader; name= и name для accessor)
# attr_reader - (R) переменные задаются только для режима чтения(Содержит в себе только accessor methods)
# attr_accessor - (RW) переменные задаются и для режима чтения и для режима записи/изменения значения переменных(полный доступ)(Содержит в себе и accessor и setter methods)
# attr_writer - (W) переменные задаются только для записи (Содержит в себе только setter methods)
# Можно добавлять новые переменные(свойства класса) и уже после создания объектов
class Cart
  attr_accessor :speed, :model  # переменные задаются через символ, между ними запятые(в конце запятую не надо).
  attr_accessor :color # либо можно задавать с новой строки с нового кодового слова
  attr_reader :wheels
  attr_writer :auto_pilot_program
  # attr_accessor и attr_writer инициализируют переменные(тк за ними скрыты сеттеры)
end

bmw = Cart.new()
bmw.speed = 230  # присваиваем(или изменяем) значения параметрам, заданным классом(способ через атрибуты без исп конструктора и/или методов тк метод= и метод обращения существуют "внутри" attr_ конструкции).
bmw.model = "X5" # тк model заданно при помощи attr_accessor то можно ее переназначать.
bmw.color = "Black"
bmw.wheels = 3  #=> (NoMethodError) attr_reader(только для чтения)
bmw.auto_pilot_program = 'iz govna i palok' # attr_writer - можно переназначать.

bmw.speed #=> 230 # Вывод значения характеристики(параметра) объекта через обращение к атрибуту(вместо написаия отдельного метода для вывода)
bmw.model #=> "X5"  # attr_accessor - можно выводить
bmw.color #=> "Black"
bmw.wheels #=> nil  # attr_reader - можно выводить
bmw.auto_pilot_program #=> (NoMethodError) # attr_writer - нельзя выводить

"BMW #{bmw.model}(#{bmw.color}) - max speed is #{bmw.speed}" #=> "BMW X5(Black) - max speed is 230"


puts
puts '                               Что под капотом у атрибутов. Кастомный accessor'

# attr_reader, attr_writer и attr_accessor - это операторы соотв методов класса(какого ?), которые встроены, принимающие значения переменых аргументами и создающие одноименные сеттеры и геттеры
# Соотв помещая такой оператор вызова с параметрами, мы исполняем его, вызывая метод и создавая сеттеры и геттеры
class SuperFoo
  attr_accessor :data

  def initialize
    @data = {}
  end

  def SuperFoo.data_accessor(*args)
    args.each do |meth|
      define_method(meth.to_s){ @data[meth] } # в блоке тело метода, он сработает при обращении к методу
      define_method(meth.to_s + '='){|v| @data[meth] = v } # имя значение переменной будем хранить в хэше
      # В итоге мы определим геттер и сеттер для переменных которые зададим параметрами в качстомный акссессор
    end
  end
end

class SubFoo < SuperFoo
  data_accessor :fizz, :pi # тут мы вызываем метод SuperFoo.data_accessor(*args) и создаем сеттеры и геттеры для переменных, имена и значения которых будем хранить в @data
end

sub_foo = SubFoo.new

sub_foo.fizz = "FIZZ"
p sub_foo.fizz #=> "FIZZ"
sub_foo.pi = 3.14
p sub_foo.pi #=> 3.14

p sub_foo.data #=> {:fizz => "FIZZ", :pi => 3.14}
p sub_foo.instance_variables #=> [:@data]


puts
puts '                                    alias_method(псевдонимы методов в классе)'

# При помощи кодового слова alias_method можно сделать вызов одного метода разными атрибутами, названием метода и новым произвольным атрибутом.
class AtbashCipher
  def one(str)
    str[0]
  end

  alias_method :other, :one
end

a = AtbashCipher.new
p a.one('asf') #=> "a"
p a.other('asf') #=> "a"


puts
puts '                                        Конструкторы + атрибуты + состояние'

# Вывод значения переменной класса с применением атрибутов не требует создания доп метода, тк можно обращаться к атрибуту по имени так же как к методу
class Song
  attr_accessor :name, :arr # Объект с суффиксом имени атрибута обращается сюда затем атрибут обращается к актуальному значению переменной класса(состояние).

  def initialize name
    @name = name
    @arr = [1, 2]
  end
end
aSong = Song.new("Bicylops")
aSong.name #=> "Bicylops"  # Атрибуты при вызове от объекта обращаются к глобальным переменным класса, инициализированными тем же именем.

# Задать другое значение переменной экземпляра при помощи атрибутов:
aSong.name = 'Kroker' # Переопеределяем значение переменной для данного объекта
aSong.name #=> "Kroker"

aSong.arr = [0, 10] # Переопеределяем значение переменной для данного объекта
aSong.arr #=> [0, 10]
aSong.arr[1] #=> 10  # обращаемся к атрибуту возвращающему массив как к массиву чтоб вывести элемент


puts
# Альтернативный метод инициальзации переменной экземпляра при помощи атрибутов(без них пришлось бы создавать сеттеры и геттеры тк self.name = name это вызов метода экзэмпляра name= в котором должна быть инициальзирована переменная, а @name = name это собственно инициализация переменной экземпляра )
class Recipe
  attr_accessor :name

  def initialize(name)
    self.name = name
  end
end
r = Recipe.new('mix')
p r.name #=> "mix"


puts
# Изменение состояния объекта(значений переменных класса для объектов) при помощи методов класса, в зависимости от вызова этих методов через атрибуты
class Airplane
	attr_reader :model, :altitude  #(altitude - высота)
  attr_accessor :speed

	def initialize(model)
		@model = model
		@altitude = 0
		@speed = 0
	end

	def fly
		@speed = 800
		@altitude = 10000
	end

	def land
		@speed = 0
		@altitude = 0
	end

  def moving?
		@speed > 0
	end
end

plane1 = Airplane.new('Boing-777') # Самолет1 создан
puts "Model #{plane1.model}, speed #{plane1.speed}, alt #{plane1.altitude}" #=> Model Boing-777, speed 0, alt 0
puts "Plane is moving? #{plane1.moving?}" #=> false

plane1.fly # Самолет1 летит
puts "Model #{plane1.model}, speed #{plane1.speed}, alt #{plane1.altitude}" #=> Model Boing-777, speed 800, alt 10000
puts "Plane is moving? #{plane1.moving?}" #=> true

plane1.land # Самолет1 сел
puts "Model #{plane1.model}, speed #{plane1.speed}, alt #{plane1.altitude}" #=> Model Boing-777, speed 0, alt 0
puts "Plane is moving? #{plane1.moving?}" #=> false


# Конвеерное создание объектов при помощи массивов и выведение методов класса с помощью циклов
models = ['Airbus-320', 'Boing-777', 'IL-86']
planes = [] # массив для хранения объектов(самолетов)

100.times do # Создаем 100 самолетов
	model = models[rand(0..2)]
	plane = Airplane.new(model)

	plane.fly if rand(2) == 1 # Запускаем рандомные самолеты
  plane.speed = 500 if plane.model == 'IL-86' && plane.altitude > 0 # Можно задавать другие параметры неким типам объектов

	planes << plane # Помещаем объекты в массив
end

planes.each do |plane| # Выводим данные о самолетах через массив объектов
	puts "Model #{plane.model}, speed #{plane.speed}, alt #{plane.altitude}. Plane is moving? #{plane.moving?}"
end


puts
puts '                                            Композиция объектов'

# Композиция объекта - один объект содержит другой объект или объекты одного класса содержат объекты другого класса. Композиция реализует отношение has-a, в отличие от отношения is-a подтипирования. Композиция объекта заключается в объединении объектов внутри составных объектов и в то же время обеспечении инкапсуляции каждого объекта с помощью их четко определенного интерфейса без видимости их внутренних элементов.
# Можно объекты одного класса поместить в массив/хэш заданный в переменной другого класса:
class Airport
	attr_reader :name, :airplanes

	def initialize name
		@name = name
		@airplanes = []
	end

	def add_plane plane  # Метод помещает объекты класса Plane в свойство(массив) объекта класса Airport
		@airplanes << plane
	end
end

class Plane
	attr_reader :model

	def initialize model
		@model = model
	end
end

airport1 = Airport.new('Domodedovo')

models = ['Airbus-320', 'Boing-777', 'IL-86']
3.times {
	plane = Plane.new(models[rand(3)])
	airport1.add_plane(plane) # Добавляем объекты класса Plane в массив заданный атрибутом класса Airport
}

puts airport1.name #=> "Domodedovo"
airport1.airplanes.each_with_index do |plane, i| # Возвращаем объекты класса Plane через метод обращающийся к атрибуту, переменной и массиву класса Airport
	puts "Plane #{i + 1}: #{plane.model}"
end

















#
