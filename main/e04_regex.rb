puts '                                       Регулярные выражения'

# Регулярные выражения - Regular expression (regex)

# Для их использования нужен текстовый редактор с поддержкой find & replace (Все современные поддерживают)
# Ctrl + F   - в меню есть настройка для рег выражений
# Тоесть можно заменять текст в фаилах прямо в редакторе при помощи рег выражений

# https://rubular.com/   -    Ruby-based regular expression editor(для тестирования регулярок)

'abcdefghijklmnopqrstuvwxyz'
'BCDFGHJKLMNPQRSTVWXYZ'
'bcdfghjklmnpqrstvwxyz'

# https://docs.ruby-lang.org/en/master/Regexp.html

# Регулярное выражение — это специальная последовательность символов, которая помогает сопоставлять или находить другие строки или наборы строк, используя специальный синтаксис, хранящийся в шаблоне. Те regex описывают шаблоны и структуры текста
# Литерал регулярного выражения — это шаблон между косыми чертами или произвольными разделителями, перед которыми стоит %r
/pattern/

# Regex нужен для:
# 1. Проверки на совпадение
# 2. Замены

# Ruby позволяет вам начинать регулярные выражения с символа %r, за которым следует разделитель по вашему выбору. Это полезно, когда описываемый вами шаблон содержит много символов косой черты, которые вы не хотите экранировать:
%r|/| # соответствует одному символу косой черты, экранирование не требуется
%r!/usr/local! # общее регулярное выражение с разделителями
%r[</(.*)>]i # Символы Flag также разрешены с помощью этого синтаксиса

# примеры
reg = %r!<(/...|...)>!   # %r!<[^>]*>!   - лучший вариант
"<div>test</div>".gsub(reg, "")#=> "test"

score = "24-79(72); 16-101(53); 86(58)-27; 31-90(74); 0-115(115); 67-40; 61-21"
score.gsub(%r!\((\d+|\d+,\d+)\)!, '') #=> "24-79; 16-101; 86-27; 31-90; 0-115; 67-40; 61-21"


puts
puts '                                      Модификаторы регулярных выражений'

# Литералы регулярных выражений могут включать необязательный модификатор для управления различными аспектами сопоставления. Модификатор указывается после второго символа косой черты, как показано ранее, и может быть представлен одним из этих символов:
/pattern/im # может быть указано несколько опций сразу
# i       - Игнорирует регистр при сопоставлении текста.
# o       - Выполняет интерполяцию #{} только один раз, при первом вычислении литерала регулярного выражения.
# x       - Игнорирует пробелы и разрешает комментарии в регулярных выражениях
# m       - Соответствует нескольким строкам, распознавая новые строки как обычные символы.
# u,e,s,n - Интерпретирует регулярное выражение как Unicode (UTF-8), EUC, SJIS или ASCII. Если ни один из этих модификаторов не указан, предполагается, что регулярное выражение использует исходную кодировку.



puts
puts '                                      Шаблоны регулярных выражений'

# За исключением управляющих символов (+ ? . * ^ $ ( ) [ ] { } | \), все символы соответствуют самим себе.
# Можно экранировать управляющий символ, поставив перед ним обратную косую черту "\".

#         (!Понятные)
/^/ # Соответсвует началу строки(в многострочном тексте - каждой(любой) строки)
  'hello goodbye goodbye hello'.gsub(/^hello/, 'xuy') #=> "xuy goodbye goodbye hello"
  "dog.jpg\ncat.jpg".gsub(/^/, 'http://rs.us/img/') #=> "http://rs.us/img/dog.jpg\nhttp://rs.us/img/cat.jpg"
/$/ # Соответствует концу строки(в многострочном тексте - каждой строки)
  "world, goodbye\ngoodbye, world".gsub(/bye$/, 'END') #=> "world, goodEND\ngoodbye, world"
  "http://ex.com/events/
  http://ex.com/places/".gsub(/$/, 'index.html') #=> "http://ex.com/events/index.html\nhttp://ex.com/places/index.html"
/./ # Соответсвует любому одиночному символу кроме новой строки. Использование параметра m так же помогает ему соответсвовать новой строке
/[]/ # Соответсвует любому одиночному символу из указанных в скобках
/[^]/ # Соответсвует любому одиночному символу кроме указанных в квадратных в скобках после ^

# *далее re это некое предшествующее регулярное выражение:

/re*/ # Соответствует 0 или более вхождениюям предыдущего выражения
  "gkhgckhcghg<Anastasia> +48-421-674-8974 Via Quirinal Roma".scan(/<.*>/) #=> ["<Anastasia>"]
/re+/ # Соответствует 1 или более вхождениюям предшествующего выражения
  'Noo!!!!!! nooo! Nooooo! No nooooo no'.gsub(/([Nn])o+!*/, '\1o') #=> "No no No No no no"
/re?/ # Соотвествует 0 или 1 вхождению предыдущего выражения
/re{n}/ # Соответсвует точно n вхождениям предыдущего выражения(или символа если не сгруппировано)
/re{n,}/ # Соответсвует n или более вхождениям предыдущего выражения
/re{n, m}/ # Соответсвует не менее чем n и не более чем m вхождениям предыдущего выражения

/a|b/ # Соответсвует либо a либо b
/(re)/ # Группирует регулярные выражения и запоминает совпадающий текст
  "abcdbcde".gsub(/bcd/, 'A') #=> "aAAe"
  "abcdbcde".gsub(/(bcd)+/, 'A') #=> "aAe"

#         (!НЕпонятные)
/(?imx)/ # Временно включает опции i, m или x в регулярном выражении, если в скобках затрагивается только эта область
/(?-imx)/ # Временно отключает параметры i, m или x в регулярном выражении, если в скобках затрагивается только эта область
/(?: re)/ # Группирует регулярные выражения без запоминания совпадающего текста
/(?imx: re)/ # Временно включает опции i, m или x в скобках
/(?-imx: re)/ # Временно отключает параметры i, m или x в скобках
/(?#...)/ # Комментарий
/(?= re)/ # Задает положение при помощи шаблона. Не имеет диапазона
/(?! re)/ # Определяет позицию используя отрицание шаблона. Не имеет диапазона
/(?> re)/ # Соответсвует независимому шаблону без возврата

#         (!Понятные)
/\w/ # Соответсвует символам слова(похоже включает и цифры)
  'ab987c'.gsub(/\w/, '+') #=> "++++++"
/\W/ # Соответсвует несловесным символам(любой буквенный символ, кроме подчеркивания ??)
/\n/ # символ перевода строки;
/\t/ # символ табуляции;
/\v/ # символ вертикальной табуляции;
/\s/ # Соответсвует пробелам(whitespase), эквивалентно [\t\n\r\f] (\f - обычеый пробел ?)
  "brown\n\nfox\n   \njumps".gsub(/\n\s*\n/, '\n') #=> "brown\\nfox\\njumps"  # убираем пустую строку с любым колич пробелов в ней
/\S/ # Соответсвует непробельным символам
/\uXXX/ # символ Unicdoe
/\d/ # любая цифра, эквивалентно [0-9]
/\D/ # Соответсвует нецифрам
/\A/ # Соответсвует началу строки(в многострочном тексте началу 1й строки)
/\Z/ # Соответсвует концу строки. Если существует новая строка, она соответсвует непосредственно перед новой строкой
/\z/ # Соответсвует концу строки
/\G/ # Соответсвует точке где закончилось последнее совпадение
/\b/ # граница слов(не только пробел но и конец строки итд) вне квадратных скобок
  'cat catatonic cat catapult'.gsub(/cat\b/, '(!!!)') #=> "(!!!) catatonic (!!!) catapult"
  "hi world, it's hip".gsub(/\b/, '_') #=> "_hi_ _world_, _it_'_s_ _hip_"
  '50000000000'.gsub(/0{6}/, ' millions') #=> "5 millions0000"
  '50000000000'.gsub(/0{6}\b/, ' millions') #=> "50000 millions"
/\B/ # обозначает что символ должен быть не крайней буквой слова со стороны постановки \B, тоесть с этой стороны символ внутри слова, например \Babc соответсвует dabc или xabc
/\n/, /\t/, /\etc/ # Соответсвует символам новой строки, возврата каретки, табуляции итд
/\1/, /\9/ # Соответсвует энному сгруппированному подвыражению
/\1/ # Соответсвует энному сгруппированному подвыражению если оно уже совпало. В противном случае относится к восьмеричному представлению кода символа
'a+b c-d e'.gsub(/ ([a-zA-Z])/, '+\1') #=> "a+b+c-d+e"


puts
puts '                                        Примеры регулярных выражений'

# Буквенные(Literal) символы:
/hgkjhg/ #=> 'hgkjhg' подстрока целиком соответсвует условию оператора
/[hgkjhg]/ #=> каждый символ в скобках отдельно соответсвует условию оператора
# Квадратная скобка это каждый как в операторе tr

# Character Classes:
/[Rr]uby/ # Соответсвует "Ruby" или "ruby"
/rub[ye]/ # Соответсвует "ruby" или "rube"
/[aeiou]/ # Соответсвует одной из букв в квадратных скобках(гласные) в нижнем регистре
/[0-9]/ # Соответсвует любой цифре, тоже что и /[0123456789]/
/[a-z]/ # Соответсвует любой строчной букве ASCII(русскрй может поддерживаться не всеми редакторами)
/[A-Z]/ # Соответсвует любой заглавной букве ASCII
/[a-zA-Z0-9]/ # Соответсвует любому символу из этих диапазонов
/[^aeiou]/ # Соответсвует любому символу кроме строчных гласных
/[^0-9]/ # Соответсвует любому символу кроме цифр

# Special Character Classes:
/./ # Соответсвует любому символу кроме новой строки
/./m # В многострочном режиме так же соответсвует и новой строке
/\d/ # Соответсвует /[0-9]/
/\D/ # Соответсвует /[^0-9]/
/\s/ # Соответсвует /[\t\r\n\f]/
/\S/ # Соответсвует /[^\t\r\n\f]/
/\w/ # Соответсвует одному символу слова /[A-Za-z0-9_]/
/\W/ # Соответсвует одному символу не являющемуся словом /[^A-Za-z0-9_]/

# Случаи повторения:
/ruby?/ # Соответсвует "rub" или "ruby", символ y должен встречаться 0 или 1 раз
/ruby*/ # Соответсвует "rub" плюс 0 или более "y"
/ruby+/ # Соответсвует "rub" плюс 1 или более "y"
/\d{3}/ # Соответсвует ровно 3м цифрам
/\d{3,}/ # Соответствует 3м и более цифрам
  '000100000000'.gsub(/0{3,7}/, 'A') #=> "A1A0"
/\d{3,5}/ # Соответсвует 3, 4 или 5 цифрам

/<.*>/ # жадное повторение: соответсвует "<ruby>perl>" в "<ruby>perl>" (берет все символы до последнего символа(тут >))
/<.*?>/ # не жадное соответсвует "<ruby>" в "<ruby>perl>" (берет все символы до ближайшего символа(тут >))

# группировка со скобками:
/\D\d+/ # без группы (от + повторяется только \d)
/(\D\d)+/ # сгруппировано (от + повторяется пара \D\d)
/([Rr]uby(,)?)+/ # соответсвует например "Ruby, Ruby, ruby ruby" итд

# Back References(назад ссылки):
/([Rr])uby&\1ails/ # Соответсвует "Ruby&Rails" или "ruby&rails". \1 - соответсвует 1й группировке в выражении

# Альтернативы:
/ruby|rube/ # Соответсвует "ruby" или "rube"
/rub(y|le)/ # Соответсвует "ruby" или "ruble"
/ruby(!+|\?)/ # "ruby" за которым следует один или более знаков ! или один знак ?

# Якоря. Необходимо указать позицию совпадения
/^Ruby/ # Соответсвует "Ruby" в начале строки(перед нет символов) или внутренней линии(строки текста?)
/Ruby$/ # Соответсвует "Ruby" в конце строки(после нет символов) или линии(line)
/\ARuby/ # Соответсвует "Ruby" в начале строки
/Ruby\Z/ # Соответсвует "Ruby" в конце строки
/\bRuby\b/ # Соответсвует "Ruby" на границе слова(до и после пробелы)
/\brub\B/ # \B не является границей слова(те после не идет пробел)

/Ruby(?=!)/ # Соответсвует "Ruby" если за ним стоит восклицательный знак
/Ruby(?!!)/ # Соответсвует "Ruby" если за ним не стоит восклицательный знак

regex = /^(?=.*[A-Z])(?=.*[0-9])[A-Z0-9]{6,}$/ # Регулярное выражение утверждает, что где-то в строке есть алфавитный символ в верхнем регистре(?=.*[A-Z]), и утверждает, что где-то в строке есть цифра(?=.*[0-9]), а затем проверяет, является ли все буквенным символом или цифрой и что колличество символов больше или равно 6.

# Специальный синтаксис со скобками:
/R(?#comment)/ # Соответсвует "R" все остальное комментарий
/R(?!)uby/ # Нечувсивмитклен к регистру при сопоставлении "uby"
/R(?!:uby)/ # Тоже что и выше
/rub(?:y|le)/ # Только группа без создания обратной ссылки \1


puts
puts '                                               Regexp class'

# Экранирование управляющих элементов
Regexp.escape("-..,.44$&%$--,.,") #=> "\\-\\.\\.,\\.44\\$&%\\$\\-\\-,\\.,"


puts
puts '                                          sub и gsub (Поиск + замена)'

# Некоторые из наиболее важных методов String, использующих регулярные выражения, — это sub и gsub, а также их варианты sub! и gsub! Все эти методы выполняют операцию поиска и замены с использованием шаблона Regexp. sub и sub! заменяет первое вхождение шаблона а gsub & gsub! заменяет все вхождения.

"text\n0987, asd".gsub(/[0-9 ,\s]/, '') #=> "textasd"   # удаляем символы "0-9 ,\s"

"quick brown\n\nfox jumps".gsub(/\n\n/, '\n') #=> "quick brown\\nfox jumps"  # убираем пустую строку

phone = "2004-959-559 #This is Phone Number"
phone.sub!(/#.*$/, "") #=> 2004-959-559  # удаляем Ruby-style коментарии
phone.gsub!(/\D/, "") #=> 2004959559  # удаляем все кроме цифр

# Меняет любую гласную на (!!!)
'ytesuityFTGFDI'.gsub(/[aeiou]/i, '(!!!)') #=> "yt(!!!)s(!!!)(!!!)tyFTGFD(!!!)"

# Меняет на "x" элементы являющиеся отдельными словами(до и после пробелы) из списка
"It should have helped him,".gsub(/\b(him|her|he|it|she)\b/i, 'x') #=> "x should have helped x,"

# При замене на подвыражения обязательно одинарные скобки у 2го аргумента
p "The supplier's phone number is (555) 867-5309".gsub(/.*\((\d+)\).*/, '\1') #=> "555"
p "The supplier's phone number is (555) 867-5309".gsub(/.*\((\d+)\).*/, "\1") #=> "\u0001"
# Меняет подстроку Probably или probably на Prolly или prolly
'Abc Probably probably'.gsub(/([pP])robably/, "\\1rolly") #=> "Abc Prolly prolly"
"a+b c-d".gsub(/ ([a-zA-Z])/, '+\1') #=> "a+b+c-d"

# Скобки обособляют условия (\d+|\d\/\d) (tbsp|tsp) == цифра.цифра или число + ' ' + tbsp или tsp
'3/0 tsp aaa 2 tbsp 4 tspr'.gsub(/(\d+|\d\/\d) (tbsp|tsp)/, 'A') #=> "A aaa A Ar"

# Интерполяция
name = 'Vasya'
'strgVasyajhlhj'.gsub(/[^#{name}]/, '') #=> "sVasya"

# Применение методов только для символов соотв регулярному выражению
'aEiOudBdBd'.gsub(/[aeiou]/i, &:swapcase) #=> "AeIoUdBdBd"
"a+b-c/d*30".gsub(/\w+/, &:reverse) #=> "a+b-c/d*03"

# условие в gsub(замены разных символов на разные строки)
str.gsub!(/[ab]/, "a" => "aRbFR", "b" => "LFaLb")

# блок в gsub
str.gsub!(/[ab]/){|с| с == 'a' ? 'aRbFR' : 'LFaLb'}
text.gsub(/[A-Z]/){|c| (c.ord - 65 - (c >= 'J' ? 1 : 0)).divmod(5).map { |x| x + 1 }.join }

# Замена элементов на их модифицированные версии(в блок передаются и изменяются те подстроки что соотв условию, остальные части строки остаются неизменными)
def anchorize(t)
  t.gsub(/http:\/\/[^ ]{1,}/){|match| "<a href=\"#{match}\">#{match}</a>" }
end
p anchorize('hello http://world.com !') # hello <a href="http://world.com">http://world.com</a> !'


puts
puts '                                               =~'

# поиск индекса символа
'foo' =~ /f/ # => 0
'foo' =~ /o/ # => 1
'foo' =~ /a/ # => nil

# сосчитать кол символов в строке при помощи $(индекс конца строки == индекс последнего символа + 1 ??)
"!!!!!" =~ /$/ #=> 5

# Включает ли значение переменной(возвращает ли индекс или nil) слово alligator вне зависимости от регистра
animal = 'тAlligAtorgoh'
animal =~ /alligator/i ? true : false #=> true


puts
puts '                                               match?'


# Включены ли только строчные буквы цифры и подчеркивание длинна строки от 4 до 16
username.match?(/^[a-z\d_]{4,16}$/)
# Оканчивается ли слово на согласную и "y"
word.match?(/[^aeiou]y$/)
# Состоит ли только из одного буквенного символа
s.match?(/\A[a-z]\z/i)


puts
puts '                                               split'


# Разбивка по 2м разным символам
"{{name}} likes {{animal_type}}".split(/[{}]/) #=> ["", "", "name", "", " likes ", "", "animal_type"]
# Разбивка по буквам соответсвующим
"ultrarevolutionariees".split(/[^aeiou]/) #=> ["u", "", "", "a", "e", "o", "u", "io", "a", "iee"]


puts
puts '                                               Интерполяция'


# интерполяция переменной
str.split(/#{a}/)
# Интерполяция
"ultrarevolutionariees".scan(/#{'.'*2}/) #=> ["ul", "tr", "ar", "ev", "ol", "ut", "io", "na", "ri", "ee"]
# Интерполяция "сложная"
$div_by_4 = /^\d*(#{('00'..'96').step(4).to_a.join('|')})$/
# тоже без интерполяции
$div_by_4 = /([048]|(\d*([02468][048]|[13579][26])))$/


puts
puts '                                              scan'


# Считает количество переходов с 'ha' на 'Ha' и наоборот
'HaHahahahaHaHahaha'.scan(/(ha)+|(Ha)+/).size #=> 4
'HaHahahahaHaHahaha'.scan(/(ha)+|(Ha)+/) #=> [[nil, "Ha"], ["ha", nil], [nil, "Ha"], ["ha", nil]]
# Вырезаем слова начинающиеся с # и состоящие из символов \w
self.scan(/#\w+/)
# Вернуть все буквы стоящие после символов заданных переменной letter в строке
str.scan(/(?<=#{letter})[a-z]/i).join

# метод scan вырезает только части выражения в скобках если строка соотв всему выражению иначе возвращает пустой массив
logparser = /\A(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}) {1,}(ERROR|INFO|DEBUG) {1,}\[([a-z0-9]{1,}):{0,1}([a-z0-9]{1,}):{0,1}([a-z0-9]{1,}){0,1}\] {1,}([a-zA-Z' ]{1,})\z/
p "2003-07-08 16:49:45,896 ERROR [user1:mainfunction:subfunction] We have a problem".scan(logparser)
#=> [["2003-07-08 16:49:45,896", "ERROR", "user1", "mainfunction", "subfunction", "We have a problem"]]
# возвращает элемент nil в массив если данное подвыражение отсутсвует(если это отсутсвие соотв выражению({0,}))
p "2003-07-08 16:49:46,896 INFO [user1:mainfunction] We don't have a problem".scan(logparser)
#=> [["2003-07-08 16:49:46,896", "INFO", "user1", "mainfunction", nil, "We don't have a problem"]]

# поиск слов в строке
"milkshakepizzachickenfriescokeburgerpizzasandwichmilkshakepizza".scan(/milkshake/) #=> ["milkshake", "milkshake"]
"milkshakepizzachickenfriescokeburgerpizzasandwichmilkshakepizza".scan('milkshake') #=> ["milkshake", "milkshake"]


puts
puts '                                               ==='

# Переменная содержит какоето из этих слов(переменная всегда справа)
/hello|ciao|salut|hallo|hola|ahoj|czesc/i === greetings
p /hello|ciao|salut|hallo|hola|ahoj|czesc/i === 'AAAhallo' #=> true
# Содержится ли символ в икс
/[a-z]/ === x
# Соответсвие(каждая точка любой символ, число точек должно соотв числу пропущ символов)
/code...s/ === "codewars" #=> true
# строка должна содержать подстроку соотв выражению(тут поиск с подстрокой из оп символов опр размера)
s = 'abc'
/[#{s}]{#{s.size}}/ === 'Zabcc' #=> true
/[#{s}]{#{s.size}}/ === 'aacc' #=> true
/[#{s}]{#{s.size}}/ === 'aa' #=> false

# Принадлежит ли значение диапазону
('0'..'255') === '245' #=> true

# проверяет - строка состоит из эн одинаковых подстрок("abbaabbaabba" - true, "abbabbabba"-false)
/\A(\w+)\1+\z/ === s


puts
puts '                                               Разные примеры'

# Подсчет символов соотв
s.count('^a-zA-Z0-9')

# убирает все символы после символа #
url = 'https://www.codewars.com/#ukfkh67879900jnjn'
url[/[^#]+/] #=> "https://www.codewars.com/"

# Не содержится ли символы в строке
self !~ /\S/

# начинается ли с строка с одной или другой буквы
"pello".start_with?(/H|P/i) #=> true

# строка соответсвует '+1 MDZHB 80 516 GANOMATIT 21 23 86 25'(только это 2цифры 3цифры люб.аглавные 4раза по 2 цифры)
!!(message =~ /\+1 \AMDZHB \d{2} \d{3} [A-Z]+ \d{2} \d{2} \d{2} \d{2}\z/)

# Совокупность многих условий
[/[A-Z]/, /[a-z]/, /\d/, /.{8}/].all?{ |re| string =~ re }
