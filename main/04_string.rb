puts '                                             Строки(String)'

#"ABCDEFGHIJKLMNOPQRSTUVWXYZ"  "abcdefghijklmnopqrstuvwxyz"

# Строка — изменяемый массив байтов, представляющий символы в кодировке UTF-8. Реализуются классом String.

"abcΣΣΣ".encode("ASCII", "UTF-8", invalid: :replace, undef: :replace, replace: "") # "abc"

# Если строка ограничена апострофами, внутри неё распознаются только специальные последовательности «\\» и «\’», обозначающие соответственно, обратный слэш и апостроф.
puts 'Строка с табуляцией "\t" и символом переноса \'\n\'' #=> Строка с табуляцией "\t" и символом переноса '\n'

# Если строка ограничена двойными кавычками, то в ней распознаются также управляющие символы «\t» (знак табуляции), «\n» (перенос строки), «\010» (любой символ в восьмеричной кодировке) и другие.
puts "Строка с табуляцией \"\\t\" и символом переноса '\\n'" #=> Строка с табуляцией "\t" и символом переноса '\n'

# Ограничители %q[…] или %Q[…] (можно использовать круглые, квадратные, фигурные, угловые скобки и другие символы) позволяют записывать строки с использованием апострофов и кавычек без экранирования. Форма %q[…] также обеспечивает непосредственный вывод управляющих последовательностей:
puts %q[Строка с табуляцией "\t" и символом переноса '\n'] #=> Строка с табуляцией "\t" и символом переноса '\n'

# Для вывода многострочного текста имеется ещё одна форма представления строк:
puts <<EOF
В этом тексте
  всё, включая переводы строк,
         кавычки и отступы,
    будет выведено "как есть".
EOF
# Вместо «EOF» может использоваться любое слово или число, важно, чтобы финальный ограничитель был написан с начала строки и за ним непосредственно следовал перевод строки. В многострочных текстах работает вывод спецсимволов, как и в строках, ограниченных двойными кавычками.


puts
# Создание строки
myStr = String.new("THIS IS TEST")

# Упрощенное создание строки
words = "чето там про фигню"
words2 = "    иЛи пРо иХ оТсУдСтВиЕ\n" # \n - Перенос строки в выводе(puts)
words3 = "И ПРО ЦВЕТ \"ФИГНИ\"" # \" - Простановка знака кавычек внутри кавычек функциональных


puts
# Строковые операции
"aaa" + "bbb" #=> aaabbb
"aaa" == "aaa" #=> true
"aaa" == "bbb" #=> false
# Дублирование строк при помощи оператора *
"abc" * 3 #=> abcabcabc
'=' * 10 #=> ==========
# String*Integer Строку умножаем на число. Наоборот число на строку выйдет естественно херня, тк это не операция умножения, а это оператор * для типа данных String, для мультипликации строки.

# Объединение строки и переменной/числа, перевод их в тип данных строка через .to_s
res = 11 % 5
puts ("результат остатка от деления 11 на 5 равен: " + res.to_s)

# Изменение символа строки по индексу:
a = "abcdefg"
a[3] = 'R'    #=> "abcRefg"

# Выделение части строки дапазоном индексов символов строки:
text = "vasya"
text[0..1] #=> "va"

# Переменная это ссылка на объект строки
a = 'fghj'
b = a
b.capitalize!
b = a
p b #=> "Fghj"
p a #=> "Fghj"


# Строки в Руби мутируемы
# Особенности присвоения значений переменным:
a = "abcdefg" # => "abcdefg" - переменная a инициализирована новой строкой.
b = a         # => "abcdefg" - переменная b получает ссылку на ТУ ЖЕ строку.
a[3] = 'R'    # => "abcRefg" - строка, присвоенная a, изменяется.
b             # => "abcRefg" - при изменении a неявно изменилось и b, так как они ссылаются на ОДИН объект.


puts
puts '                                                  Методы'

p 'vaSYa'.upcase() #=> "VASYA"
p 'vaSYa'.downcase() #=> "vasya"
p 'aBaB'.swapcase #=> "AbAb"
p 'vaSYa'.capitalize #=> "Vasya"
# strip убирающий пробелы и спецсимволы(например \n) до 1го и после последнего символа, пробелы между слов не трогает:
p "   текст   с   пробелами   ".strip #=> "текст   с   пробелами"
p "\ngoga\r".strip #=> "goga"

p "Хуb рыGaeb".length()          #=> 10 (длинна)коллич символов в строке, учитывает и пробелы
p "Хуb рыGaeb".count("eb")       #=> 3 Считает число заданных символов(в данном случае 3(2 - b и 1 - e))
p "Хуb рыGaeb".include?("ыGa")   #=> true Оператор для поиска символов
p "Хуb рыGaeb".delete("ХG")      #=> "уb рыaeb" Оператор для удаления символов(не обязательно стоящих подряд)
p "Хуb рыGaeb".start_with?("Ху") #=> true Проверяет начинается ли строка с заданной подстроки
p "Хуb рыGaeb".empty?            #=> false Проверяет пустая строка или нет
p "Хуb рыGaeb".chop!             #=> "Хуb рыGae" Оператор для удаления последнего символа в строке
# Тк ! это знак присвоения, то строка после подобных преобразований такой и сохраняется
p "Хуb рыGaeb".slice! "рыG"      #=> "рыG" извлекает заданную часть строки(эта часть остается остальная строка убирается)
"hello\nworld\n".lines           #=> ["hello\n", "world\n"]
'stressed'.reverse               #=> "desserts"
'hello'.each_char { |x| puts x } #=> итерация для string
'hello'.chars #=> ["h", "e", "l", "l", "o"]  #Возвращает массив символов в str. Это сокращение для str.each_char.to_a.

# scan Вырезать из строки
'f0ff8ff'.scan('ff')        #=> ["ff", "ff"]
'stressed'.scan(/.../)      #=> ["str", "ess"] #разбивка по числу символов(число точек)
'stressed'.scan(/e.s/)      #=> ["ess"]  # Вырезать строки по части их символов
'stressed'.scan(/#{'e.s'}/) #=> ["ess"]  # для переменной

p 'stressed,,  ff'.squeeze        #=> "stresed, f"  убирает элементы повторяющиеся подряд
p 'stressed,,  ff'.squeeze("m-z") #=> "stresed,,  ff"  уберает только повторяющиеся символы из диапазона

'The   quick brown'.split(/ /)              #=> ["The", "", "", "quick", "brown"]
"0 9026315 -827&()".split(/[^0-9]/)         #=> ["0", "9026315", "", "827"]
# Сохранение пробела в конце
" Abf b C d E f G ".split(/ /,-1).join(' ') #=> " Abf b C d E f G "
" AbfCgg di Ejjj fii ".split(/\b/)          #=> [" ", "AbfCgg", " ", "di", " ", "Ejjj", " ", "fii", " "]
"AbfCgg di Ejjj fii".split(/ab|fi/i)        #=> ["", "fCgg di Ejjj ", "i"]
"asd fgh g\njku".split(/^\n| /)             #=> ["asd", "fgh", "g\njku"]

# Разбивка вокруг заданного элемента
'abcPgty'.partition('P') #=> ["abc", "P", "gty"]

# Побуквенная замена(по соотв индексам в аргументах)
"hello".tr('el', 'ip')              #=> "hippo"  Замена символо e на i и символа l на p
'abcde'.tr('ace', 'RTY')            #=> "RbTdY"
"hello".tr('a-k', '')               #=> llo
"hello".tr('aeiou', '*')            #=> "h*ll*"
"1 _heKKl+lo".tr('^a-z0-9_', '')    #=> "1_hello"
'abz'.tr('a-yz', 'b-za')            #=> "bca"
'AabBzZ'.tr('a-yzA-YZ', 'b-zaB-ZA') #=> "BbcCaA"
s.tr('A-Za-z', 'B-ZAb-za')          # rotate-1
a.tr("^#{b}", '')                   # Общие символы 2х строк

# Замена заданной подстроки на заданную подстроку
p "heelloel".gsub(/el/, '+-89') #=> "he+-89lo+-89"


# буквенный счет(например для номеров колонок в xl)
'aa'.succ # => "ab"
'az'.succ # => "ba"

'122.99.9.99.999'.next #=> "123.00.0.00.000"


eval("{:a=>1, :b=>2, :c=>3}") #=> {:a=>1, :b=>2, :c=>3}
eval("{:a=>1, :b=>2, :c=>3}").class #=> Hash
arr = eval("[1,[2,[3]]]") #=> [1, [2, [3]]]
arr.class #=> Array

# Возвращает целочисленный порядковый номер односимвольной строки.(англ буквы с 97)
p 'A'.ord #=> 65
p 'Z'.ord #=> 90
p 'a'.ord #=> 97
p 'z'.ord #=> 122
p '0'.ord #=> 48
p '9'.ord #=> 57
"abc".bytes #=> [97, 98, 99]
"hel".sum #=> 313  #('h.ord' + 'e'.ord + 'l'.ord)

p 97.chr #=> "a" вывести символ по его закодированному номеру


((c.ord - 97) - n%26 + 123).chr #  работает корректно для n<=25(либо для отнимания по 1 в цикле)

# Caesar Cipher decode1 with i
if /[A-Z]/===c
  k=((65-(c.ord-shift-i))/26.0).ceil
  c.ord-shift-i<65 ? (c.ord-shift-i+26*k).chr : (c.ord-shift-i).chr
elsif /[a-z]/===c
  k=((97-(c.ord-shift-i))/26.0).ceil
  c.ord-shift-i<97 ? (c.ord-shift-i+26*k).chr : (c.ord-shift-i).chr
end
# Caesar Cipher decode2
c.ord+shift>90 ? ((c.ord+shift-65)%26+65).chr : (c.ord+shift).chr if /[A-Z]/===c
c.ord+shift>122 ? ((c.ord+shift-97)%26+97).chr : (c.ord+shift).chr if /[a-z]/===c
# Caesar Cipher decode3
sd=('a'..'z').to_a.rotate(shift).join
su=('A'..'Z').to_a.rotate(shift).join
text.tr('a-z', "#{sd}").tr('A-Z', "#{su}")


# субпатерны строки
#https://www.codewars.com/kata/5a4a2973d8e14586c700000a/solutions/ruby
#https://www.codewars.com/kata/5a4a391ad8e145cdee0000c4/solutions/ruby
#https://www.codewars.com/kata/5a49f074b3bfa89b4c00002b/solutions/ruby

@nums = %w[zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen]

# Обязательно 2 знака нуля после запятой:
"#{'%.2f' % 1}" #=> "1.00"


puts
# сопоставление текста на общие элементы(поиск наиболее похожнго)
require "rubygems/text"
def find_most_similar(word)
  @words.sort_by{|w| levenshtein_distance(word, w)}.first
end



puts
puts '                                          Интерполяция строк'

# 1. Интерполяция переменных c символьными префиксами #символ_переменнойимя_переменной. Не имнтерполирует выражения
$global = 10
CONST = 9
@instanse = 8
local = 7
p "This is #$global #CONST #@instanse #local"  #=> "This is  #CONST  #local"
# Не работает с одинарными кавычками
p 'This is #$global #CONST #@instanse #local' #=> "This is \#$global #CONST \#@instanse #local"


puts
# 2. Интерполяция выражений #{...}. Можно встраивать в строку выражения, условия математические действия итд.
# Интерполяция строк производится при помощи управляющих символов #{...} внутри строки(кавычек). Так удобнее помещать в строку данные другого типа и соответсвенно меньше и понятнее код
area = 3.141592653
p "The area is #{area}." #=> "The area is 3.141592653."

# Инетрполяция строк и специальные символы не работает в одинарных кавычках(''), а работает только в двойных(""), например потому в одинарных кавычках можно писать двойные(и наоборот) без слэша и это не будет разбивать строку
text = 'Kroker'
p 'Hi "ok" #{text} bay' #=> "Hi \"ok\" \#{text} bay"
p "hi 'ok' #{text} bay" #=> "hi 'ok' Kroker bay"

# если в строке встречается конструкция #{ }, то всё, что находится внутри фигурных скобок, вычисляется интерпретатором, преобразуется в строковый формат и помещается в данное место создаваемой строки.
for i in (1..7).reverse_each do
  puts "Осталось #{i} секунд#{case i
                              when 2..4 then "ы"
                              when 1 then "а"
                              else ""
                              end }..."
end
# при использовании вставки всё, что находится внутри фигурных скобок, является обычным ruby-кодом, в частности, там не требуется экранирование кавычек.

#Примеры интерполяции
"#{arr[0][n] ? arr[0][n] : ' '} #{arr[1][n] ? arr[1][n] : ' '}\n" # 1
"#{str_1[i] || ' '} #{str_2[i] || ' '}" # 2
