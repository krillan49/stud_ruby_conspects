puts '                                           Monkey-patching'

# Monkey-patching - это практика изменения или расширения классов, библиотек или модулей во время выполнения программы. Это позволяет изменять поведение существующих классов или функций без изменения их исходного кода. Monkey-patching часто используется в тестировании или для внесения исправлений в сторонние библиотеки.

# Можно переоткрыть существующий класс(в том числе встроенный) и переопределять методы и что угодно в них



puts '                                      Изменение встроенного класса'

# Переопределяем метод strip класса String, весь остальной класс не изменится
class String
  def downcase
    self[0]
  end
end

str = 'abc  '
p str.downcase #=> "a"



puts '                                         Изменение своего класса'

# Дополнение кастомного класса
class Some
  def initialize(n)
    @n = n
  end
end

# Дополним этот класс добавив в него новые методы
class Some
  attr_reader :n

  def plus_1
    @n += 1
  end
end

some = Some.new(0)

p some.n    #=> 0
some.plus_1
p some.n    #=> 1



puts '                                             Refinements'

# Refinements - позволяет вносить изменения в существующие классы и модули, не затрагивая глобальную область видимости и другие части программы. Refinements не изменяют глобальное состояние Ruby. Это главное отличие от monkey-patching, когда изменения делаются непосредственно в классе и видны повсюду.

# Refinements применяются только к классу/модулю, который вы уточняете, и не наследуются его подклассами. Если подклассы тоже нуждаются в изменении, нужно применять refinement и к ним.

# Когда использовать Refinements:
# Когда нужно внести изменения в класс, но вы не хотите затрагивать остальную часть программы.
# Для написания библиотек, которые изменяют поведение существующих классов, не вызывая конфликтов с другими библиотеками.
# В модульных тестах для "заглушек" (mocks) для зависимостей в изолированной среде.
# Внесения временных изменений: Добавление функциональности только в определенном месте.

# Когда НЕ использовать Refinements:
# Когда изменения должны быть глобальными и применимы ко всей программе.  В этом случае лучше использовать monkey-patching
# Когда вы полностью контролируете класс, который хотите изменить. В этом случае лучше просто добавить метод непосредственно в класс.

# refine - определяет refinement (уточнение). Внутри блока `refine` вы определяете методы, которые хотите добавить или изменить в целевой класс или модуль. Тоесть расширяет существующий класс как при помощи макипатчинга, но не для всего проекта, а только в определенном сценарии, в определенной части проекта. Принимает константу расширяемого класса и блок, в котором нужно определить новый метод, что будет добавлен в этот класс.

# using - активирует refinement в текущем scope (области видимости), подключает функционал из refine в расширяемый класс в только в той облпсти где вызван using. Только код, находящийся после `using` в текущей области видимости, будет "видеть" внесенные изменения. Порядок `using` важен - если есть несколько refinements, нужно применять их в порядке, в котором вы хотите, чтобы они действовали


# Создаем модуль, который будет содержать наше refinement
module MyRefinement
  refine String do # refinement класса `String`
    def reverse_upcase
      self.reverse.upcase
    end
  end
end


# 1. Применим в глобальной области

# Без using класс String не изменился
# p "hello".reverse_upcase  #=> undefined method `reverse_upcase' for "hello":String (NoMethodError)

# Активируем refinement `MyRefinement` в текущей области видимости
using MyRefinement

# Теперь в этой области видимости String имеет метод reverse_upcase
p "hello".reverse_upcase  #=> OLLEH

# За пределами этой области видимости, String остается неизменным
def outside_method
  # using MyRefinement # Можно активировать и в этой области, чтобы сработало
  "world".reverse_upcase
end
# p outside_method #=> undefined method `reverse_upcase' for "world":String (NoMethodError)


# 2. Применим в методе и передадим объект измененного касса в блок. Refinements не распространяются автоматически внутрь методов, нужно использовать refinement в блоке, переданном методу, если это возможно:
def process_string(str, &block)
  # using MyRefinement   #=> main.using is permitted only at toplevel (RuntimeError)
  block.call(str)
end
p (process_string("hello") do |s|
  using MyRefinement # Активируем refinement только для области видимости блока
  s.reverse_upcase
end) #=> "OLLEH"
# В этом примере `StringRefinement` применяется только к блоку, переданному в `process_string`. Вне этого блока метод `reverse_upcase` по-прежнему не существует для `String`.


# 3. Подключим в класс (Хорошо подходит для того чтобы не изменять встроенные классы глобально)
class Config
  using MyRefinement

  def initialize(str)
    @str = str
  end

  def file_storage
    @str.reverse_upcase
  end
end
p Config.new('hello').file_storage #=> "OLLEH"


# 4. Можно использовать `using` внутри модулей. Это активирует refinement только в scope этого модуля (и классах, которые включают этот модуль после `using`).

















#
