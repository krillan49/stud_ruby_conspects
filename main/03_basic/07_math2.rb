puts '                               Математика разное(формулы и готовые решения)'

# Рекурсивное сложение всех цифр в числе до однозначного
("1879-03-14".chars.sum(&:to_i) - 1) % 9 + 1


# 1 (mod N)   или  x ≡ 1 (mod N) может быть представлен как x % N === 1
def inverseMod(a, m) # a * x % m == 1
  return nil if a.gcd(m) != 1
  return m if m == 1
  m0, x, x0 = m, 1, 0
  while a > 1
    x -= (a / m) * x0
    a, m = m, a%m
    x, x0 = x0, x
  end
  x < 0 ? x += m0 : x
end
p inverseMod(5, 7) #=> 3   5 * 3 % 7 == 1
p inverseMod(9, 7) #=> 4   9 * 4 % 7 == 1


# Сортировка чисел(разного порядка) чтобы собрать(сложив как строки) из них наибольшее число
array.map(&:to_s).sort{|a,b| b+a <=> a+b}.join.to_i


# формула ряда треугольника флоида по числу
Math.sqrt(n * 2).round
((1+Math.sqrt(1+8*(n-1)))/2).floor


# задачи про открывание и открывание n шкавчиков(сначала каждый потом через 1 потом через 2 итд) - в конце останутся элементы с индексами квадратов чисел от 1 до k**2<=n
Math.sqrt(n).floor


# Входят или нет числа в бесконечную последовательность из которой удалили кажое 2е чисто, потом каждое 3е из оствшихся, потом каждое 4е из оставшихся итд до бесконечности (1,3,7,13...)
def survivor(n)
  k = 2
  until k > n
    return false if n % k == 0
    n -= n / k
    k += 1
  end
  true
end


# сумма индексов в d-мерном массиве где в каждой мерности по n элементов
n**d * d * (n - 1) / 2


# все нечетные числа и все четные числа, кратные 4, могут быть выражены как разность двух совершенных квадратов.
# n/4+(n.odd? ? n/2+1 : n/2)



puts '                                          Комбинаторика'

# https://www.evkova.org/kombinatorika

# сочетания == комбинации, перестановки == пермутации

# Сумма чисел от 1 до N, формула n*(n+1)/2

# колличество чисел от 1 до n делящееся на числа от a до z
n / (a..z).to_a.reduce(:lcm) # для простых чисел, вместо lcm просто их произведение

# Cумма чисел кратных m и n до числа x(включительно(если нет то x-1))
(1..x / n).sum * n + (1..x / m).sum * m - (1..x / (n * m)).sum * n * m

# Сумма n чисел делящихся на 3
3 * (n / 3).floor * (n / 3 + 1).floo r/ 2


# 1 3 6 10 15 21 ...
# Формула энного пятиугольного числа n*(3*n-1)/2
# Формула суммы первых к треугольных чисел  S = (n*(n+1)*(n+2))/6


# 1. Перестановки == пермутации

# число перестановок без повтора == n!
(1..n).inject(:*)

# число перестановок без повтора с неподвижными точками == n! / e

# формула уникальных пермутаций из n групп одинаковых элементов по k штук в каждом == n**k
[["3", "3", "3"], ["7", "7", "7"], ["8", "8", "8"], ["1", "1", "1"]] #=> n == 4 k == 3 C == 4**3

# Количество размещений([0, ... n-1].permutation(k).size) без повторений из n элементов по k:
(1..n).inject(:*) / (1..n-k).inject(:*)

# число беспорядков https://ru.wikipedia.org/wiki/Беспорядок_(перестановка)
# Особым видом перестановки является та, в которой все ее элементы находятся в другом положении, чем исходное.
(2..n).map{|k| (-1)**k*(1..n).inject(:*) / (1..k).inject(:*)}.sum
(2..n).map{|k| k < n ? (-1)**k*(k+1..n).inject(:*) : k == n ? (-1)**k : 0 }.sum # быстрее

# Формула уникальных пермутаций(перестановок символов) с повторяющимися элементами
# p = n! / (r1! * r2! * .. * rn!) - где r число повторов элемента
el = 2342
(1..el.to_s.size).inject(:*) / el.to_s.chars.uniq.map{|n| el.to_s.chars.count(n)}.map{|n| (1..n).inject(:*)}.inject(:*) #=>12(быстро)
(1..arr.size).inject(:*) / arr.uniq.map{|n| arr.count(n)}.map{|n| (1..n).inject(:*)}.inject(:*) # для массива

# Сумма чисел(самих чисел, полученных перестановками) всех перестановок цифр в числе
# https://translated.turbopages.org/proxy_u/en-ru.ru.0b77b025-637b8453-6f81ba1d-74722d776562/https/www.geeksforgeeks.org/sum-numbers-can-formed-permutations-n-digits/
k = n.digits.sum * (1..n.to_s.size - 1).inject(:*)
(0..n.to_s.size - 1).map{|e| 10**e * k}.sum


# 2. Сочетания == комбинации  combination

# Биномиальный коэффициент/Binomial coefficient — коэффициент перед членом разложения бинома Ньютона. Читается «биномиальный коэффициент из n по k» или «число сочетаний из n по k» ( C n-внизу k-вверху ):  Cmn = n! / (m!(n-m)!)
def bin_coef(k, n)
  (1..n).inject(:*) / ( (1..k).inject(:*) * (1..n-k).inject(:*) ) # Равноценно (1..n).to_a.combination(k).size
end

# Сочетания с повторениями repeated_combination(n) - сочетания с m элементов, которые могут повториться n раз
(1..m+n-1).inject(:*) / ( (1..n).inject(:*) * (1..m-1).inject(:*) )

# aCb := a * (a-1) * (a-2) * ... * (a-b+1) / b!  # для случаев когда только значение "a" целое, а значение "b" любое

# Формула разложения (степенного 2-члена) бинома Ньютона( (a+b)**n = sum(k=0..n){Ckn*a**(n-k)*b**k} ).
def some(a, b, n) # Тут без 1го и последнего члена
  (1..n-1).map{|k| [bin_coef(k, n), a * (n - k), b**k]}
end
p some(2, 3, 5) #=> [[5, 8, 3], [10, 6, 9], [10, 4, 27], [5, 2, 81]]

# генерация строки треугольника Паскаля #nCr = (nCr(-1) * (n - r + 1))/r, где 1 ≤ r ≤ N   и  тС0 == 1
# строка треугольника Паскаля это колличество подмножеств(1е значение число нулевых подмножеств, 2е- число подмножеств из одного элемента, 3е - число подмножеств из 2х элементов...)
# так же это коэфициенты многочлена получаемого из (a+b)**n
def paskal_line(n)
  1.upto(n-1).with_object([1]) do |x, res|
    res << res[-1] * (n - res.size) / res.size #nCr = nCr(-1) * (n - r + 1) / r, где 1 ≤ r ≤ N
  end
end
p paskal_line(5) #=> [1, 4, 6, 4, 1]
# сумма элементов диагонали треугольника Паскаля до элемента энной строки(нумерация от 0)
# 1 * (p+1)/1 * (p+2)/2 * (p+3)/3 * ... * (p+n)/n   формула энного элемента диагонали
def diagonal(n, p) # p номер диагонали, n номер строки
  m, e, k, res = n-p, 1, 1, [1]
  m.times do
    e = e * (p + 1) / k
    res << e
    p += 1
    k += 1
  end
  res.sum
end
p diagonal(4, 2) #=> 10

# Делится ли чисто сочетаний(тоесть количество подмножеств по k чисел из множества n чисел) на число num
def counter(m, num) # считаем число 2ек в каждом факториале формулы числа комбинаций
  sum2, num0 = 0, num
  until m / num == 0
    sum2 += m / num
    num *= num0
  end
  sum2
end
def subsets_parity(n, k, num) # (1..n).inject(:*) / ( (1..k).inject(:*) * (1..n-k).inject(:*) )
  counter(n, num) - counter(k, num) - counter(n-k, num) > 0
end
p subsets_parity(227337362, 189263427, 2) # true


# Формула числа уникальных подмножеств в массиве начиная с пустого. [1, 2, 2] => {}, {1}, {2}, {1, 2}, {2, 2}, {1, 2, 2}.(6)
arr.uniq.map{|n| arr.count(n) + 1}.inject(:*)
# Вариант с уникальными подмножествами без повтора элементов. [1, 2, 2] => {}, {1}, {2}, {1, 2} (3)
arr.uniq.map{|n| arr.uniq.count(n) + 1}.inject(:*)
2**arr.uniq.size # альт
# найти сами эти последовательности можно при помощи метода combination тк он сохраняет порядок

# Формула всех непоследовательных подмножеств(все члены непоследовательны) чисел от 1 до n == сумме чисел фибоначи до числа n включительно


# http://bigor.bmstu.ru/?cnt/?doc=PO_CAD/5.1.mod/?cou=PO_CAD/base.cou (количество разбиений числа)

# Количество всех разбиений числа n на слагаемые(уникальные тк 1+1+2 == 2+1+1 == 1+2+1) => P(n,n) по формуле Эйлера
# https://neerc.ifmo.ru/wiki/index.php?title=Нахождение_количества_разбиений_числа_на_слагаемые
UGOL = (1..100).each.with_object([]){|q, a| a << (-1)**(q+1)*(-(3*q**2-q)/2) << (-1)**(q+1)*(-(3*q**2+q)/2) } # генерация всех пятиугольных(?) чисел для скобок по формуле эйлера
RES = [1] # используем предыдущие кол разбиений для подсчета p(5) = p(4) + p(3) − p(0)
def exp_sum(n)
  m = RES.size - 1
  until RES.size >= n + 1
    m += 1
    res = 0
    UGOL.each do |k|
      break if m < k.abs
      res += k.negative? ? RES[m-k.abs] : -RES[m-k.abs]
    end
    RES << res
  end
  RES[n]
end
p exp_sum(4) #=> 5

# генерация массивов разбиений числа (ср скорость ?)(https://www.codewars.com/kata/55cf3b567fc0e02b0b00000b/solutions/ruby)
PART, PROD = {1 => [[1]]}, {1 => [1]}
def part(n)
  m = PART.keys.max
  until m >= n
    m += 1
    res = [[m]]
    (1..m-1).each do |k| # добавляем к каждому наибольшему числу меньшему чем N все варианты разбиений его разницы с N
      partm = PART[k].select{|a| a[0] <= m - k} # только те в которых все элементы меньше этого числа
      res += [m - k].product(partm).map(&:flatten)
    end
    PART[m] = res
    PROD[m] = res.map{|a| a.inject(:*)}.uniq.sort
  end
  PART[n]
end
p part(4) #=> [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]
p part(5) #=> [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1], [1, 1, 1, 1, 1]]



puts '                                     Пути в сетке. Части фигур'

# Колличество прямоугольников(втч пересекающихся) в прямоугольнике (x**2+x)*(y**2+y)/4
# (x+1)*(y+1)*z + (x+1)*y*(z+1) + x*(y+1)*(z+1)  Число ребер в блоке включая внутренние

# число квадратов в сетке nxn
(n * (n+1) * (2*n+1)) / 6
# число квадратов в сетке mxn
y * (y + 1) * (3 * x - y + 1) / 6
# число прямоугольников в сетке mxn
m * (m+1) * n * (n+1) / 4

# Формула путей вправо-вниз для квадратной сетки n*n  =>  (2*n)!/(n!)**2
(1..2*n).inject(:*) / (1..n).inject(:*)**2
# Формула путей вправо-вниз для прямоугольной сетки m*n
(1..m+n).inject(:*) / ((1..m).inject(:*) * (1..n).inject(:*))
# Если есть оштбки с nil
mn = (1..m+n).inject(:*) || 1
mm = (1..m).inject(:*) || 1
nn = (1..n).inject(:*) || 1
mn / (mm * nn)

# сумма всех блоков пирамиды с высотой h где начальные стороны w l а каждый след блок w2=w1+1 l2=l1+1
h * w * l + (1..h-1).sum * w + (1..h-1).sum * l + (h-1) * (2*h-1) * h / 6

# сколько клеток пересекает диагоняль в клетчатом прямоугольнике
h + w + h.gcd(w) - 2 # вместе с касаниями по углам клеток(без 2 крайних точек)
h + w - h.gcd(w) # без касаний по углам клеток



puts '                                        Разложение числа'

# На сумму последовательных положительных чисел можно разложить любое число кроме степеней 2йки

# Минимальное число послед чисел [n/2+1,n/2] if n.odd? а для четных просто делим на след число частей (на 3 на 4 итд) делаем эти числа последовательными и проверяем сумму( друг решения https://www.codewars.com/kata/59321f29a010d5aa80000066/solutions/ruby)

# максимальное число послед чисел: суммируем цифры с 1 до тех пор пока сумма не превысит n (для 25 это 1+2+3+4+5+6+7=28) если эта сумма больше заданного выбрасываем слагаемые слева, иначе добавляем следующее слагаемое справа, все это пока не получим n

# найти отсутствующее число в массиве последовательных чисел при помощи арифм прогрессии (s=(a1+an)*n/2)
(a[0] + a[-1]) * (a.size + 1) / 2 - a.sum


# разложить число на максимальную сумму квадратов если это возможно: находим корень из числа = k (1..k) суммируем квадраты первых чисел пока сумма не станет больше заданного числа тогда отнимаем из начала, если становится больше снова прибавляем числа дальше и так пока не будет равно числу.

# разложить число на все суммы 2х квадратов что возможно:
def all_squared_pairs(num)
  (0..((num/2)**0.5).floor).each.with_object([]) do |n, res| # (1..((num...
    r = (num-n**2)**0.5
    res << [r,n].sort if r % 1 == 0  # return [r,n].map(&:to_i).sort if r%1==0
  end
end

# сумма последовательных квадратов чисел от 1 до n  ->  Sn=n(n+1)(2n+1)/6



puts '                                  Подсчет цифр в числе'

# Число цифр в факториале числа n
(Math.log10(2 * Math::PI * n) / 2 + n * Math.log10(n / Math::E)).ceil

#Нахождение последней цифры числа фебоначи с индексом i, начиная от 1 1 2...
q = 5**0.5
(((1 + q) / 2)**(i % 60) / q).round % 10

# Подсчет конечных нулей факториала числа в любой системе счисления
# https://habr.com/ru/post/444112/
require 'prime'
def factorial_tail_zeroes(base, n) # число нулей == коллич base на которые можно поделить факториал
  base.prime_division.map do |k, p| # колич base == минимальному из количеств множителей base
    x = Math.log(n, k).round(7).floor # считаем коллич простых множителей base в множителях факториала
    res = 0
    until x == 0 # считаем общее коллич простых множителей(например в 25 две 5)
      res += n / k**x
      x -= 1
    end
    res / p # делим на степень(число) у простого множителя base, тк их минимальное чило для получения факториала именно такое
  end.min
end
p factorial_tail_zeroes(16, 16) # 3, "16! has 3 zeroes"

# последняя ненулевая цифра факториала https://www.justquant.com/numbertheory/how-to-find-last-non-zero-digit-in-a-factorial/
# последняя цифра степени    https://www.justquant.com/numbertheory/units-digit-of-a-number-raised-to-power/
# пример 2х этих   https://www.codewars.com/kata/5f79b90c5acfd3003364a337  6 kyu  Last non-zero digit of factorial
















#
