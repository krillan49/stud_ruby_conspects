puts '                                            Переменные'

# В Руби переменная это ссылка на объект какого-то класса. Если перезапишешь переменную, то просто потрешь ссылку

# В Руби переменные принято записывать в Snake case, должны начинаться всегда с буквы, переменные могут содержать цифры и знак подчеркивания.

# Руби определяет переменную встречая ее в первый раз. Встречая переменную далее, он ее не переопределяет, а присваеивает новое значение



puts '                                        Присвоение переменных'

# = Это оператор присваивания

# Можно просто объявить переменную без значения, присвоив в нее значение nil
b = nil

x = 1
p x #=> 1
x = 'A'   # переприсвоение
p x #=> "A"

# запись любого кода возможно через точку с запятой и/или с новой строки
limit = 100; cols = ["red","yellow","blue"]

# Множественное присвоение при помощи оператора and
a = 1 and b = 2
p [a, b] #=> [1, 2]

# Множественное присвоение при помощи оператора and и if
a, b, c = 10, 50, 0
a = 1 and b = 2 if c == 0 #=> 1 2
p [a, b] #=> [1, 2]

# Вариант задания переменных сразу
a,b,c = 2,5,4 #=> 2 5 4 #=>[2,5,4]
print a, b, c, "\n"

# Присвоение цепочкой
a = b = c = d = '*'
p a #=> '*'
p c #=> '*'

# инициализация значений из массива
width, length, height = [2, 3, 4]
p width #=> 2
p length #=> 3
p height #=> 4

# Особенности присвоения в Руби
a = 1, b = 2
p a #=> [1, 2]
p b #=> 2

# Изменеие значений переменных друг на друга без использования 3й
x = 10; y = "ten"
x, y = y, x
p [x, y] #=> ["ten", 10]
# Альтернативный способ(только для чисел)
a = 5
b = 10
a = a + b # a = 15
b = a - b # b = 5
a = a - b # a = 10


# Особенности присвоения иутируемым значений переменным:
a = "abcdefg" # => "abcdefg" - переменная a инициализирована новой строкой.
b = a         # => "abcdefg" - переменная b получает ссылку на ТУ ЖЕ строку.
a[3] = 'R'    # => "abcRefg" - строка, присвоенная a, изменяется.
b             # => "abcRefg" - при изменении a неявно изменилось и b, так как они ссылаются на ОДИН объект.
# Не мутируемым:
x = 10        # => 10  - переменная x инициализирована числом 10.
y = x         # => 10  - переменная y получает ссылку на то же значение.
x += 5        # => 15  - операция += создаёт НОВОЕ целое значение 15, которое и записывается в x,
y             # => 10    поэтому изменение x не отражается на y



puts '                                             Сборщик мусора'

# Можно вызвать сборщик мусора вручную, например если подохреваем, что автоматически ему чистить оперативную память от объектов без ссылок "лень" тк в системе ее много свободной
GC.start



puts '                                   alias (псевдонимы глобальных переменных)'

# alias - ключевое слово дает псевдоним методам или глобальным переменным. Псевдонимы не могут быть определены в теле метода.

# Создание псевдонимов для пронумерованных глобальных переменных ($1, $2,...) запрещено. Переопределение встроенных глобальных переменных может вызвать серьезные проблемы.

# Синтаксис: alias global_variable_alias_name global_variable_name
$a = 10
alias $b $a # $b — это псевдоним для $a.
p $b        #=> 10



puts '                                              Псевдопеременные'

# Это специальные переменные, которые выглядят как локальные переменные, но ведут себя как константы. Этим переменным нельзя присвоить какое-либо значение.

self     # объект-приемник текущего метода.
true     # значение, представляющее true.
false    # значение, представляющее ложь.
nil      # значение, представляющее неопределенное.
__FILE__ # имя текущего исходного файла.
__LINE__ # номер текущей строки в исходном файле.



puts '                                           Оператор defined?'

# defined?  — это специальный оператор, который принимает форму вызова метода, чтобы узнать, определено ли переданное выражение и что это за выражение если оно определено. Он возвращает строку, описывающую тип выражения, если оно определено или nil, если выражение не определено.

# Удобно проверять, определена ли переменная, константа или метод

# Вернет тип переменной или константы если она определена либо nil
foo = 42
CONSTANT = "constant"
p defined? foo       #=> "local-variable"
p defined?(CONSTANT) #=> "constant"
p defined? $_        #=> "global-variable"
p defined? bar       #=> nil                        # variable не определена

# Вернет "method" если метод и переданные в него параметры определены иначе nil
def method; 1 end
p defined?(method)     #=> "method"
p defined? some()      #=> nil
p defined? puts        #=> "method"
p defined? puts(foo)   #=> "method"
p defined? puts(bar)   #=> nil       # тк переменная bar не определена

# ???
p defined?(1 + 1) #=> "method"

# Использование 3
p defined? super # True if a method exists that can be called with super user
#=> "super" (if it can be called)
#=> nil (if it cannot be)

# Использование 4
p defined? yield   # True if a code block has been passed
#=> "yield" (if there is a block passed)
#=> nil (if there is no block)



puts '                                              x op= y'

# x op= y  - где op это некая операция
x = 1; y = 'a'
x += 1 # тоже самое что и x = x + 1
p x #=> 2
y += 'b'
p y #=> "ab"



puts '                                             Оператор ||='

# ||= - (или равно) является условным оператором присваивания. Если значение слева определено и истинно - использует его, если не определено или ложно(false или nil) - использует(присваивает/устанавливает) значение справа.
# Если переменная неопределена то присвоение в переменную идет до проверки на ошибку. Удобно для установки значения по умолчанию
# a ||= b тоже самое что и a = a || b Те в переменную x присваивается результат операции x || y
# a ||= b  это примерно  a ? a : a = b  (a = a | |b  это примерно  a = a ? a : b)
# a ||= b почти сокращение от a || a = b  (и не эквивалентен a = a || b). Разница в том, что когда a не определено, a || a = b будет повышаться NameError, тогда как a ||= b устанавливается a в b. Это различие не имеет значения, если a и b являются локальными переменными, но имеет значение, если любой из них является методом получения/установки класса.

# Например(a изначально не определено):
a ||= nil # => nil   # не выводит ошибку хотя локальная переменная не определена(хотя так a || 1 будет ошибка).
a #=> nil
a ||= 0 # => 0       # тут уже в переменную присвоился 0
a #=> 0
a ||= 2 # => 0       # в переменную уже присвоенн 0

x = 1
x = 5 || x #=> 5

foo = false # => false
foo ||= true # => true
foo ||= false # => true


# инициализация переменной
per = nil || 2   #=> 2
per  #=> 2
per2 = per2 || 5 #=> 5
per2 #=> 5
per3 ||= 9       #=> 9
per3 #=> 9
















#
