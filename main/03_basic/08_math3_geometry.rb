puts '                              Гем ruby2d. Классы Triangle, Vector и Point'

# https://www.ruby2d.com/learn/shapes/

# > gem install ruby2d

require 'ruby2d'

# Класс Point имеет методы(переменные класса) .x .y .z выводящие соотв координаты
# Класс Triangle имеет методы(переменные класса) .a .b .c  выводящие точки(Point) углов
# Класс Vector имеет методы(переменные класса) .x .y .z выводящие

Triangle.new(Point.new(10, 10), Point.new(40, 10), Point.new(10, 50))


puts
puts '                                        Геометрия разное'

# Расстояние между 2мя точками a и b, если известны их координаты:
Math.sqrt((bx - ax)**2 + (by - ay)**2 + (bz-az)**2)

# Проверить лежат ли точки на одной прямой
'Точки лежат на одной прямой' if (x1-x3) * (y2-y3) - (x2-x3) * (y1-y3) == 0
# Проверить лежат ли точки на одной прямой(для целочисленных координат)
points.combination(3).map{|(x1,y1),(x2,y2),(x3,y3)| (x3 * (y2-y1) - y3 * (x2-x1) == x1 * y2 - x2 * y1)}.all?

# Найти площадь треугольника по 3м точкам:
# плоскость s = 0.5*((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)).abs
# 3d https://s0.slide-share.ru/s_slide/4a8d2dcaa2f609dc7c78dfff36f7a247/6b2f60d8-3a5f-4a7b-8fd1-0894f3cedb1a.jpeg
[[[1,2,-4],[-3,2,4],[7,8,-4]], [[-3,-2,-6],[-1,-4,0],[2,1,-1]]].map do |(x1,y1,z1),(x2,y2,z2),(x3,y3,z3)|
  a = [x2-x1, y2-y1, z2-z1] # ab
  b = [x3-x1, y3-y1, z3-z1] # ac
  i = a[1]*b[2] - b[1]*a[2]
  j = b[0]*a[2] - a[0]*b[2]
  k = a[0]*b[1] - b[0]*a[1]
  s = 0.5 * (i**2 + j**2 + k**2)**0.5
end
# тоже при помощи матриц( единицы добавляем если координаты зет нету )(только для положительных резов ??)
require 'matrix'
list.map do |(x1,y1),(x2,y2),(x3,y3)|
  s = 0.5 * Matrix[[x1,y1,1],[x2,y2,1],[x3,y3,1]].det
end

# Нахождение точки в пространстве
# https://habr.com/ru/post/144571/
# (B[0]-A[0])*(C[1]-B[1])-(B[1]-A[1])*(C[0]-B[0]) с какой стороны от вектора AB находится точка C (положительное возвращаемое значение соответствует левой стороне, отрицательное — правой).

# Соотношение сторон в треугольнике всегда подчиняется следующему правилу: длина любой стороны треугольника не может быть больше суммы длин двух других сторон

# находится ли точка в треугольнике?  - считаются произведения (1, 2, 3 - вершины треугольника, 0 - точка):
a = (x1-x) * (y2-y1) - (x2-x1) * (y1-y)
b = (x2-x) * (y3-y2) - (x3-x2) * (y2-y)
c = (x3-x) * (y1-y3) - (x1-x3) * (y3-y)
# Если они(a b c) одинакового знака, то точка внутри треугольника, если что-то из этого - ноль, то точка лежит на стороне, иначе точка вне треугольника.

# Кол-во целочисленных(по координатам) точек в круге с центром в начале координат(Проблема круга Гаусса)
(-r..r).map{|i| ((r**2-i**2)**0.5).floor * 2 + 1}.sum
(0...r).map{|i| ((r**2-i**2)**0.5).floor}.sum * 4 + 1

# декартовы координаты из угла(тут в радианах) и радиуса (угол относительно оси икс, нач коорд 0-0 если из друг точки просто прибавить их к икс и игрик)
def coordinates(angle, r)
  [r * Math.cos(angle/180.0*Math::PI), r * Math.sin(angle/180.0*Math::PI)]
end
# https://www.codewars.com/kata/5b40b666dfb4291ad9000049/train/ruby  (пример применения)



puts '                           Построение выпуклой оболочки(самые внешние точки)'

# Построение выпуклой оболочки(самые внешние точки множества точек) обходом Грэхэма O (N log N)
# Алгоритм является асимптотически оптимальным (доказано, что не существует алгоритма с лучшей асимптотикой), хотя в некоторых задачах он неприемлем (в случае параллельной обработки или при online-обработке)

def clockwise?(x1,y1, x2,y2, x3,y3) # https://e-maxx.ru/algo/oriented_area
  s2 = (x2-x1) * (y3-y1) - (y2-y1) * (x3-x1) # вычисляем удвоенную знаковую площадь треугольника
  s2 < 0 # образует ли указанная тройка точек поворот по часовой стрелке
end

def point_reject(sn, pA, pB, n)
  # Чтобы получить, например, верхнюю оболочку, нужно отсортировать все точки по абсциссе, затем пройтись по всем точкам, рассматривая на каждом шаге кроме самой точки две предыдущие точки, вошедшие в оболочку. Если текущая тройка точек образует не правый поворот (что легко проверить с помощью Ориентированной площади), то ближайшего соседа нужно удалить из оболочки. В конце концов, останутся только точки, входящие в выпуклую оболочку.
  if n == 'up' # верхнее подмножество
    sn = sn.sort_by{|x,y| [x,y]} # сортируем по абсциссе
    res = [pA, pB].sort_by{|x,y| [-x,-y]} # стартовые точки сортируем наоборот
  else # нижнее подмножество сортируем наоборот
    sn = sn.sort_by{|x,y| [-x,-y]}
    res = [pA, pB].sort_by{|x,y| [x,y]}
  end

  # алгоритм заключается в сортировке всех точек по абсциссе и двух (в худшем случае) обходах всех точек
  res = res + sn
  (res.size * 3).times do # делаем несколько кругов
    clockwise?(res[0][0], res[0][1], res[1][0], res[1][1], res[2][0], res[2][1]) ? res.rotate! : res.delete_at(1)
  end
  res
end

def hull_method(points)
  points = points.uniq.sort
  # 1. Найдём самую левую и самую правую точки A и B (если таких точек несколько, то возьмём самую нижнюю среди левых, и самую верхнюю среди правых). Понятно, что и A, и B обязательно попадут в выпуклую оболочку
  pA = points.min_by{|x,y| [x,y]} # https://e-maxx.ru/algo/convex_hull_graham
  pB = points.max_by{|x,y| [x,y]}
  # 2. Далее, проведём через них прямую AB, разделив множество всех точек на верхнее и нижнее подмножества S1 и S2 (точки, лежащие на прямой, можно отнести к любому множеству - они всё равно не войдут в оболочку). Точки A и B отнесём к обоим множествам
  a, b, c = pB[1]-pA[1], pA[0]-pB[0], pA[1]*pB[0]-pA[0]*pB[1] # коэфы уравнения прямой ax + by + c = 0
  ups, downs, = [], [] # массивы для точкек верхней и нижней полуплоскости относительно прямой
  points.each do |x, y|
    sp = a * x + b * y + c # в зависимости от знака(ax+by+c>0 или <0) получаем полуплоскость относительно данной прямой
    downs << [x, y] if sp > 0 #  ax+by+c>0  -  в нижней
    ups << [x, y] if sp < 0 #  ax+by+c<0  -  в верхней
  end
  # 3. Теперь построим для S1 верхнюю оболочку, а для S2 - нижнюю оболочку, и объединим их, получив ответ.
  (point_reject(ups, pA, pB, 'up') + point_reject(downs, pA, pB, 'down')).uniq
end

hull_method([[4,4],[11,6],[1,19],[0,6],[4,16],[18,12],[1,4],[1,5],[16,20],[14,16], [0, 20], [0, 13]]).sort
# [[0, 6], [0, 20], [1, 4], [4, 4], [11, 6], [16, 20], [18, 12]]















#
