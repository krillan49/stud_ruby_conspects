puts '                                            self'

# self - это ссылка на объект, в контексте которого интерпретатор выполняет блок кода. Для обращений к элементам интанс-объекта не обязательно указывать self, так как он подразумевается по умолчанию. Такой объект всегда существует, даже когда вы работаете в корневой области видимости
p self #=> main
p self.class #=> Object


puts
puts '                                             Scope'

# Scope - Область видимости -  это то, где что-то(переменные, константы, методы) видно и доступно в данный момент

# Вы входите в новую область действия, когда:
# Определить класс (с помощью class SomeClass)
# Определить модуль (с помощью module SomeModule)
# Определить метод (с помощью def some_method)
# Каждое определение метода/модуля/класса называется шлюзом области , поскольку создается новая область. Старая область видимости вам больше не доступна, а все доступные в ней переменные заменяются новыми.


puts
puts '                                         Типы переменных'

# 1. local variable/локальная переменная
local_var = 'some'
# переменная доступная только в области действия(той области кода, в которой она объявлена), например внутри метода, можно определить(объявить) только в том же методе.
# Если локальная переменная не объявлена, то будет ошибка исполнения программы.
# Локальные переменные начинаются со строчной буквы или с символа "_".

# 2. instance variable/переменная экземпляра
@instance_var = 'some'
# доступня только внутри определенного объекта и для всех методов экземпляра класса(или методах той области в которой объявлена вне класса). Недоступна непосредственно из определений классов.
# Желательно объявлять instance variables в конструкторе, но можно определить в любом методе класса.
# Если переменная экземпляра класса не объявлена, то ее значение по-умолчанию будет равно nil и ошибки как с необъявленной локальной переменной не будет.
# Имеют разные значения для разных объектов. Эти переменные определяют состояние объекта.

# 3. class variable/переменная класса(переменная шаблона/статическая переменная)
@@class_var = 'some'
# доступна из определения класса и любых подклассов. Недоступна откуда-либо снаружи.
# переменная сохраняет свое значение во всех экземплярах класса(для всех объектов класса эта переменная будет одинакова). Например если мы меняем ее значение для одного объекта, то ее значение изменится на такое же для других объектов класса. Переменная класса принадлежит классу и является характеристикой класса.
# Невозможна инициализация вне тела класса. Неинициализированная переменная класса приводит к ошибке.

# 4. global variable/глобальная переменная
$global_var = 'some'
# доступна во всей программе как вне так и внутри класса, можно определить ее вне класса и она будет доступна и внутри класса и в любом месте кода вне класса.
# Неинициализированные глобальные переменные имеют значение nil и выдают предупреждения с опцией -w.

# 5. CONSTANT константа
CONSTANT = 'some'
# значение этой переменной никогда не меняется(Как только константа определена, вы не можете изменить ее значение), определяется без метода. Нужна для задания неких констант, например PI = 3.14. Имя константы начинается с заглавной буквы.
# К константам, определенным внутри класса или модуля, можно получить доступ из этого класса или модуля, а к константам, определенным вне класса или модуля, можно получить глобальный доступ. Константы не могут быть определены внутри методов.
# Ссылка на неинициализированную константу приводит к ошибке

# Специальные переменные. Например, переменная `ARGV` содержит аргументы, переданные в программу. А переменная `ENV` содержит параметры окружения (environment) - т.е. параметры, которые заданы в вашей оболочке (shell).

$global_var = 'Доступна везде. Определяется где угодно'
CONSG = 'Константа вне класса'
class App
  CONSTANT = 'Значение никогда не меняется. Попытка изменения выдаст ошибку'
  @@class_var = 'Одно значение для всех экземпляров класса'
  def initialize
    @instance_var = 'Доступна в методах класса. Определяется в методах класса'
  end
  def print_variables
    local_var = 'Доступна и определяется только в конкретном методе'

    puts $global_var
    puts CONSTANT
    puts @@class_var
    puts @instance_var
    puts local_var

    ::CONSG # Вызов константы извне тела класса в тело класса
  end
  def chenge_class_var
    @@class_var += ' +1'
  end
  def print_class_var
    puts @@class_var
  end
end

App.new.print_variables #=> значения всех переменных выводимых(puts) методом print_variables
puts $global_var #=> "Доступна везде. Определяется где угодно"

# Примеры для @@class_var
a = App.new
a.print_class_var #=> "Одно значение для всех экземпляров класса"
puts a.chenge_class_var #=> "Одно значение для всех экземпляров класса +1"
b = App.new
b.print_class_var #=> "Одно значение для всех экземпляров класса +1"
puts b.chenge_class_var #=> "Одно значение для всех экземпляров класса +1 +1"
c = App.new
c.print_class_var #=> "Одно значение для всех экземпляров класса +1 +1"

# Получить доступ к константе класса вне класса(classname::constant)
puts App::CONSTANT #=> "Значение никогда не меняется. Попытка изменения выдаст ошибку"


puts '                             Область видимости локальных переменных'

# Интерпретатор Ruby помещает локальную переменную в область видимости всякий раз, когда видит(Не имеет значения, если код не выполняется, в тот момент), присвоение этой локальной переменной.
# Локальные переменные изменяются и заменяются с каждой новой областью действия.

a #=> undefined local variable or method `a' for main:Object (NameError)
if false # те код в блоке условия не будет выполнен
  a = 'hello' # но интерпритатор увидел присвоение переменной, поэтому локальная переменная попала в эту область видимости
end
p a #=> nil  # тк код в блоке не выполнился, переменная не была инициализирована, но тк она попала в область видимости ошибки нет


puts
puts '                                Конфликты имен локальных переменных'

# В Ruby методы можно вызывать без явного получателя и круглых скобок, те так же как и локальные переменные. Так могут возникнуть потенциальные конфликты имен
def something
  'I am a method'
end
p something #=> "I am a method"
something = 'I am a variable' # Если есть локальная переменная и вызов метода с тем же именем в той же области видимости, локальная переменная будет «затенять» метод и иметь приоритет
p something #=> "I am a variable"
# Для подсказки интерпретатору, что мы хотим именно метод, можно приписать self. или приписать () справа.
public :something # (?? Хз зачем нужно работает и без этого) Поскольку все методы, определенные на верхнем уровне, по умолчанию являются private
p self.something #=> "I am a method"
p something() #=> "I am a method"















#
