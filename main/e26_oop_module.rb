puts '                                         ООП: Module/namespace(Модули)'

# module == namespace == пространство имён
# Модули — это способ группировки методов, классов и констант; своего рода новый уровень логического разделения программы после классов и методов.
# Модули позволяют помещать различные методы в отдельный фаил. В разные модули можно поместить методы с одинаковыми именами и тогда они никак не будут конфликтовать в основном коде.

# Модули дают два основных преимущества:
# 1. Модули предоставляют пространство имен и предотвращают конфликты имен.(Модули определяют пространство имен, песочницу, в которой ваши методы и константы могут работать, не беспокоясь о том, что другие методы и константы вступят с ними в противоречие.)
# 2. Модули реализуют возможность миксина.

# Константы модуля называются так же, как константы класса, с начальной прописной буквы. Определения методов также выглядят одинаково: методы модуля определяются точно так же, как методы класса.

# ПРИМЕЧАНИЕ: Предпочитайте модули классам содержащим только методы класса. Классы следует использовать только тогда, когда имеет смысл создавать из них экземпляры.

# Это ....
include A
B.new
# тоже самое что и ...
A::B.new
#  ??


puts
puts '                                       Вызов методов и констант из модуля'

# Вызов методов из модуля способ 1: Название методов должно иметь префикс с именем модуля либо префикс self, аналогично методам класса. Эти методы будут методами модуля(вызываться от модуля)
module Amodule
  PI = 3.14
  # Синтаксис 1
  def Amodule.somemeth(par) # Как и методы класса, всякий раз, когда вы определяете метод в модуле, вы указываете имя модуля, за которым следует точка, а затем имя метода.
    par - 1
  end
  # Синтаксис 2
  def self.somemeth2(par)
    par - 5
  end
end
# Мы можем определить еще один модуль с тем же именами функции, но с другой функциональностью и конфликта в программе не возникнет изза того что этот метод будет методом другого модуля:
module Bmodule
  PI = 5
  def Bmodule.somemeth(par)
    par + 10
  end
  def self.somemeth2(par)
    par + 100
  end
end
# Константа модуля вызывается аналогично тому как вызывается константа класса:
p Amodule::PI #=> 3.14
p Bmodule::PI #=> 5   # Не возникает конфлика при вызове констант с одинаковым именем и разными значениями из разных модулей
# Вызов методов модуля:
p Amodule.somemeth(5) #=> 4 #(5 - 1)
p Amodule.somemeth2(20) #=> 15 #(20 - 5)
p Bmodule.somemeth(Bmodule::PI/4) #=> 11  # Вызов метода модуля с помещением константы в параметр и итогового значения в переменную
p Bmodule.somemeth2(Amodule::PI) #=> 103.14  # Используем константу одного модуля в методе другого


puts
# Вызов методов из модуля способ 2: Можно не добавлять имя модуля префиксом к названию метода(в теле модуля), но тогда перед вызовом метода нужно воспользоваться оператором вызова модуля "include Modulename"
module Cmodule
  PI = 3.14
  def somemeth(par) # Метод задается базовым способом
    par - 1
  end
  def somemeth2(par) # Модуль может содержать любок количество методов
    par + 10
  end
end
# Константа модуля вызывается без include Modulename
p Cmodule::PI #=> 3.14
# Вызывая метод заданный без префикса имени модуля получим ошибку:
p Cmodule.somemeth(5) #=> undefined method `somemeth' for Cmodule:Module (NoMethodError)

# Для того чтобы методы вызывались подключим модуль в этом фаиле:
include Cmodule
# Теперь мы можем вызвать метод не содкржащий префикса с именем модуля
p Cmodule.somemeth(5) #=> 4
p Cmodule.somemeth2(Cmodule::PI + 7) #=> 20.14


puts
# Вызов методов из модуля способ 3: при помощи ключевого слова module_function, которое указывает на то, что нижестоящие методы являются методами модуля.
module Megaphone
  def shout(whatever)
    puts whatever.upcase
  end

  module_function

  def shout2(whatever)
    puts whatever.upcase
  end
end
Megaphone.shout('Hello') #=> undefined method `shout' for Megaphone:Module (NoMethodError)
Megaphone.shout2('Hello') #=> "HELLO"  # метод является методом модуля тк стоит ниже module_function


puts
puts '                                    Подключение модуля из другого фаила require'

# Если третья программа хочет использовать какой-либо определенный модуль, она может просто загрузить файлы модуля, используя оператор Ruby require
# Создаем для модуля новый фаил(example10tools.rb) и создаем в нем модуль


# ВАРИАНТ 1
# require_relative загружает файл с указанным путём относительно текущего файла
# Теперь нам нужно "подключить" фаил в котором содержится модуль(example10tools.rb), а потом подключить сам модуль

require_relative "example20tools.rb" # "Подключение" фаила. Тк фаил с модулем и данный фаил в одной папке то путь не прописываем, а иначе необходимо было бы указывать путь

include Tools # Подключаем теперь сам модуль
extend Tools # альтернатива include ?? - погуглить

# Использование модуля:
Tools.say_hello("George") # Так обратившись(в данном случае и задав значение переменной метода) к одному из методов(say_hello) принадлежащих модулю Tools мы получим заданный методом вывод "Hi, #{name}", в данном случае "Hi, George"
Tools.say_bye("Вася") #=> Bye, Вася
say_hello("George") #=> Hi, George  Не обязательно обращаться к подключенному модулю


# ВАРИАНТ 2
# require - ключевое слово для подключения фаила, оно использует для загрузки набор каталогов, заданных настройками среды и параметрами запуска интерпретатора
# require './failname.rb'   где './' - текущая директория и далее путь к этому фаилу
# Можно подключить "$LOAD_PATH << '.'" чтобы искать фаилы в текущем каталоге
require './e28_tools' #=> .rb писать необязательно
BB.say_hi #=> "hi"


puts
puts '                                              Классы из модулей'

# ::  - Синтаксис обращения к классу через модуль
module Humans
	class JessiePinkman # классов в модуле может быть сколько угодно.
		def say_hi
			puts 'hi, bitch'
		end
	end
end
jessie_pinkman = Humans::JessiePinkman.new
jessie_pinkman.say_hi #=> "hi, bitch"


puts
puts '                                           Подключение модуля в класс'

# Подключение модуля в класс вне тела класса
Array.include SelfInject


# Чтобы встроить модуль в класс, используется оператор include в теле класса:
module Week
  FIRST_DAY = "Sunday"
  def Week.weeks_in_month
    puts "You have four weeks in a month"
  end
  def weeks_in_year
    puts "You have 52 weeks in a year"
  end
end

class Decade
  include Week # Подключаем модуль в теле класса, теперь все что содержит модуль доступно в классе

  def no_of_months
    number = 10*12
    puts "#{number} months from #{Week::FIRST_DAY}" # Константа модуля вызвана в методе класса
  end
  #def weeks_in_month  # Так можно вызвать метод модуля от объекта
    #Week.weeks_in_month
  #end
end
d1 = Decade.new
# Константу можно вызвать и от модуля и от класса в который он подключен:
p Week::FIRST_DAY #=> "Sunday"
p Decade::FIRST_DAY #=> "Sunday"
# Метод класса с подключенной константой модуля:
d1.no_of_months #=> "120 months from Sunday"

# Вызов методов от объекта:
d1.weeks_in_month #=> undefined method `weeks_in_month' for #<Decade:0x000001d3105e4d38> (NoMethodError)  # Нельзя вызвать от объекта метод модуля(с префиксом инмени модуля в имени метода). Чтобы вызвать этот метод из объекта нужно будет поместить Week.weeks_in_month в метод класса
d1.weeks_in_year #=> "You have 52 weeks in a year"

# Вызов методов модуля(с префиксом имени)
Week.weeks_in_month #=> "You have four weeks in a month"
Week.weeks_in_year #=> undefined method `weeks_in_year' for Week:Module (NoMethodError) # Нельзя вызвать без объекта класса метод не являющийся методом модудя(с префиксом имени модуля в имени метода) тк модуль подключен только в теле класса
include Week # Придется его подключить и вне класса:
Week.weeks_in_year #=> "You have 52 weeks in a year"


puts
# Подключение атрибутов и конструктора в класс из модуля:
module MyModule
  attr_accessor :x, :y

  def initialize(options = {})
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right
    self.x += 1
  end
  def left
    self.x -= 1
  end
  def up
    self.y += 1
  end
  def down
    self.y -= 1
  end
end

class Dog
  include MyModule # Теперь класс получает все методы, конструктор и атрибуты из модуля

  def up # Можно переопределить методы модуля для данного класса
  end
  def left
  end

  def label # Собственный метод
    '@'
  end
end

dog = Dog.new x: 10, y: 5
# Используем атрибуты и конструктор из модуля
p dog.x #=> 10
p dog.y = 7 #=> 7
# Используем методы из модуля
p dog.down #=> 6 (y = 7 - 1)
p dog.up #=> nil # Метод переопределен в классе и значение переменной y не меняется
p dog.y #=> 6  # Значение y осталось прежним


puts
puts '                                   Наследование из модуля'

class Client < ActiveRecord::Base
end


puts
puts '                                  Mix-ins/Примеси(Подключение 2+ модуля в класс)'

# Миксины в значительной степени устраняют необходимость в множественном наследовании, которое не поддерживается Руби

# Класс Sample может испльзовать методы из модулей A и B(наследуется от обоих модулей), соответсвенно можно сказать, что класс Sample показывает множественное наследование или примесь:
module A
  def a1
    puts 'a1'
  end
end

module B
  def b1
    puts 'b1'
  end
  def b2
    puts 'b2'
  end
end

class Sample
  include A # Подключаем 1й мродуль в класс
  include B # Подключаем 2й мродуль в класс
  def s1
    puts 's1'
  end
end

samp = Sample.new
samp.a1 #=> "a1"  # Вызов объектом метода из модуля A
samp.b1 #=> "b1"  # Вызов объектом метода из модуля B
samp.b2 #=> "b2"
samp.s1 #=> "s1"
