# 0. Методы из доки пройти заново, массивы, строки, хэши

# ?? В руби можно сразу отправлять что-то в командную строку на выполнение, если заключить строку в обратные кавычки ``



# В Ruby класс - это тоже объект. А раз вы можете в объект-класс помещать методы, то почему бы не добавить метод в индивидуальный объект? Т.е. напекли мы при помощи класса Person сто объектов p1, p2, ..., p100. А потом говорим, а давате у нас p100 - будет руководитель и у него будет метод manage, а в классе Person и 99 других объектов его не будет. Ruby позволяет это сделать
def p100.manage
  true
end
# Но вы чаще такие методы будете видеть в такой форме (хотя вместо self может быть любой произвольный объект Ruby)
def self.manage
  true
end


# Потому что в объекте сложнее понять, чей метод, какому классу он принадлежит. Объект сформирован несколькими классами, которые наследуются друг от друга. В классе вы просто берете instance_methods и говорите вытащи мне все методы этого класса. В другие не смотри. А в объекте так не получится, так как из-за цепочки наследования в него методы добавили несколько классов и модулей. А ведь часть методов совпадают по названию и нужно отдать предпочтение какому-то конкретному из этих разных классов и модулей (а порядок выбора зависит еще от способа миксования модуля). Эта проблема называется поиском метода. Когда при вызове он в самом деле ищется по всем классам наследникам и включенным по дороге модулям. Поэтому язык не такой шустрый, особенно, по сравнению с компилируемыми и поэтому не так просто фильтровать список методов объекта.

puts "\e[H\e[2J" # Хитрый способ очистить экран
