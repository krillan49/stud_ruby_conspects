# 1. Создать фаил про require взять туда инфу из methods и наследования ??

# ?? В руби можно сразу отправлять что-то в командную строку на выполнение, если заключить строку в обратные кавычки ``


# _2 - аргументы без пайпов
# gsub(/[A-Z]/).with_object([])
p "hrdhgd".upcase.gsub(/[A-Z]/).with_object([]){_2 << _1.ord-64}.sum


# Странная херня, определяется метод при присвоении из переменной method
a = method
p a #=>  wrong number of arguments (given 0, expected 1) (ArgumentError)



# В Ruby класс - это тоже объект. А раз вы можете в объект-класс помещать методы, то почему бы не добавить метод в индивидуальный объект? Т.е. напекли мы при помощи класса Person сто объектов p1, p2, ..., p100. А потом говорим, а давате у нас p100 - будет руководитель и у него будет метод manage, а в классе Person и 99 других объектов его не будет. Ruby позволяет это сделать
def p100.manage
  true
end
# Но вы чаще такие методы будете видеть в такой форме (хотя вместо self может быть любой произвольный объект Ruby)
def self.manage
  true
end


# Потому что в объекте сложнее понять, чей метод, какому классу он принадлежит. Объект сформирован несколькими классами, которые наследуются друг от друга. В классе вы просто берете instance_methods и говорите вытащи мне все методы этого класса. В другие не смотри. А в объекте так не получится, так как из-за цепочки наследования в него методы добавили несколько классов и модулей. А ведь часть методов совпадают по названию и нужно отдать предпочтение какому-то конкретному из этих разных классов и модулей (а порядок выбора зависит еще от способа миксования модуля). Эта проблема называется поиском метода. Когда при вызове он в самом деле ищется по всем классам наследникам и включенным по дороге модулям. Поэтому язык не такой шустрый, особенно, по сравнению с компилируемыми и поэтому не так просто фильтровать список методов объекта.

puts "\e[H\e[2J" # Хитрый способ очистить экран




# ???
arr = ['a', 'b', 'c']
arr[0] << '???' #=> "a???"
arr[1] << 69 #=> "bE"
arr #=> ["a???", "bE", "c"]












#
