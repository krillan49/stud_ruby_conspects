puts '                               Математика разное(формулы и готовые решения)'

# Рекурсивное сложение всех цифр в числе до однозначного
("1879-03-14".chars.sum(&:to_i) - 1) % 9 + 1


# 1 (mod N)   или  x ≡ 1 (mod N) может быть представлен как x % N === 1
def inverseMod(a,m)
  #a*x%m==1
  return nil if a.gcd(m)!=1
  return m if m==1
  m0, x, x0 = m, 1, 0
  while a>1
    x-=(a/m)*x0
    a, m = m, a%m
    x, x0 = x0, x
  end
  x<0 ? x+=m0 : x
end


puts
# Решение простых математических выражений представленных строкой
def calc(expression) # вар 1 (через нодежс ??)
  `echo 'console.log(#{expression})' | node`.to_f
end
def calc(expression) # вар 2
  RubyVM::InstructionSequence.compile("1.0*" + expression).eval
end
def calc(expression) # вар 3
  eval("1.0*" + expression)
end
p calc('2 / (2 + 3) * 4.33 - -6')#7.732
p calc('2 /2+3 * 4.75- -6') # 21.25
p calc("(1 - 2) + -(-(-(-4)))") # 3.0
p calc('-123') # -123
p calc('123') # 123
p calc('12* 123') # 1476


puts
# https://www.evkova.org/kombinatorika

# сочетания == комбинации, перестановки == пермутации

# число перестановок без повтора = n!
# число перестановок без повтора с неподвижными точками = n!/e
# число беспорядков https://ru.wikipedia.org/wiki/Беспорядок_(перестановка) Особым видом перестановки является та, в которой все ее элементы находятся в другом положении, чем исходное.
(2..n).map{|k| (-1)**k*(1..n).inject(:*)/(1..k).inject(:*)}.sum
(2..n).map{|k| k<n ? (-1)**k*(k+1..n).inject(:*) : k==n ? (-1)**k : 0 }.sum # быстрее

# Биномиальный коэффициент(сочетания/комбинации)(Binomial coefficient) — коэффициент перед членом разложения бинома Ньютона. Читается «биномиальный коэффициент из n по k или «число сочетаний из n по k» (C n-внизу k-вверху):  Cmn=n!/(m!(n-m)!)
# Равноценно arr.combination(k).to_a.size где  arr==(1..n).to_a
(1..n).inject(:*)/((1..k).inject(:*)*(1..n-k).inject(:*))

# Сочетания с повторениями repeated_combination(n) - сочетания с m элементов, которые могут повториться n раз
(1..m+n-1).inject(:*) / ((1..n).inject(:*) * (1..m-1).inject(:*))

# Делится ли чисто сочетаний(тоесть количество подмножеств по k чисел из множества n чисел) на число num
def counter(m,num) # считаем число 2ек в каждом факториале формулы числа комбинаций
  sum2=0
  num0=num
  until m/num==0
    sum2+=m/num
    num*=num0
  end
  sum2
end
def subsets_parity(n,k,num) # (1..n).inject(:*)/((1..k).inject(:*)*(1..n-k).inject(:*))
  res=counter(n,num)-counter(k,num)-counter(n-k,num)
  res>0 ? 'Y' : 'N'
end
p subsets_parity(227337362, 189263427, 2) # 'Y'

# aCb := a * (a-1) * (a-2) * ... * (a-b+1) / b!  # для случаев когда только значение "a" целое, а значение "b" любое

# формула разложения (степенного 2члена) бинома Ньютона( (a+b)**n = sum(k=0..n){Ckn*a**(n-k)*b**k}).
(1..n-1).map{|k| [bin_coef(k, n), a*(n-k), b**k]} # Без 1го и последнего члена


# формула уникальных пермутаций из n групп одинаковых элементов по k штук в каждом == n**k
[["3", "3", "3"], ["7", "7", "7"], ["8", "8", "8"], ["1", "1", "1"]] #=> n==4 k==3 C==4**3

# Количество размещений([0, ... n-1].permutation(k).to_a.size) без повторений из n элементов по k определяется следующей формулой:
(1..n).inject(:*)/(1..n-k).inject(:*)

# формула уникальных пермутаций(перестановок символов) с повторяющимися элементами
# p=n! / (r1!*r2!*..*rn!) - где r число повторов элемента
el=2342
(1..el.to_s.size).inject(:*)/el.to_s.chars.uniq.map{|n| el.to_s.chars.count(n)}.map{|n| (1..n).inject(:*)}.inject(:*) #=>12(быстро)
(1..arr.size).inject(:*)/arr.uniq.map{|n| arr.count(n)}.map{|n| (1..n).inject(:*)}.inject(:*) # для массива

# Сумма чисел(самих чисел, полученных перестановками) всех перестановок цифр в числе
# https://translated.turbopages.org/proxy_u/en-ru.ru.0b77b025-637b8453-6f81ba1d-74722d776562/https/www.geeksforgeeks.org/sum-numbers-can-formed-permutations-n-digits/
k=n.digits.sum*(1..n.to_s.size-1).inject(:*)
(0..n.to_s.size-1).map{|e| 10**e*k}.sum


# http://bigor.bmstu.ru/?cnt/?doc=PO_CAD/5.1.mod/?cou=PO_CAD/base.cou (количество разбиений числа)

# Количество всех разбиений числа n на слагаемые(уникальные тк 1+1+2==2+1+1==1+2+1) => P(n,n) по формуле Эйлера
# https://neerc.ifmo.ru/wiki/index.php?title=Нахождение_количества_разбиений_числа_на_слагаемые
$ugol=[]
(1..100).map{|q| # генерация всех пятиугольных(?) чисел для скобок по формуле эйлера
  $ugol << (-1)**(q+1)*(-(3*q**2-q)/2)
  $ugol << (-1)**(q+1)*(-(3*q**2+q)/2)
}
$res=[1] # используем предыдущие кол разбиений для подсчета p(5)=p(4)+p(3)−p(0)
def exp_sum(n)
  m=$res.size-1
  until $res.size>=n+1
    m+=1
    res=0
    $ugol.each do |k|
      break if m<k.abs
      k.negative? ? res+=$res[m-k.abs] : res-=$res[m-k.abs]
    end
    $res << res
  end
  $res[n]
end

# генерация массивов разбиений числа (ср скорость ?)(https://www.codewars.com/kata/55cf3b567fc0e02b0b00000b/solutions/ruby)
$part = {1 => [[1]], 2 => [[2],[1,1]], 3 => [[3],[2,1],[1,1,1]]}
$prod = {1 => [1], 2 => [1,2], 3 => [1,2,3]}
def part(n)
  m = $part.keys.max
  until m >= n
    m += 1
    res = [[m]]
    (1..m-1).each do |k| # добавляем к каждому наибольшему числу меньшему чем N все варианты разбиений его разницы с N
      partm = $part[k].select{|a| a[0] <= m - k} # только те в которых все элементы меньше этого числа
      r = [m - k].product(partm).map{|a| a.flatten}
      res += r
    end
    $part[m] = res
    $prod[m] = res.map{|a| a.inject(:*)}.uniq.sort
  end
  nprod = $prod[n]
  size = nprod.size # site тк сам вывод результата оч долгий тк Для n = 50 количество частей равно 204226, для 80 — 15 796 476
  median = size.odd? ? nprod[size/2] : ((nprod[size/2] + nprod[size/2-1]) / 2.0).round(2)
  "Range: #{nprod[-1] - nprod[0]} Average: #{'%.2f' % (nprod.sum / size.to_f)} Median: #{'%.2f' % median}"
end


# Формула числа уникальных подмножеств в массиве начиная с пустого. [1, 2, 2] => {}, {1}, {2}, {1, 2}, {2, 2}, {1, 2, 2}.(6)
arr.uniq.map{|n| arr.count(n)+1}.inject(:*)
# Вариант с уникальными без повтора элементов. [1, 2, 2] => {}, {1}, {2}, {1, 2} (3)
arr.uniq.map{|n| arr.uniq.count(n)+1}.inject(:*)
2**arr.uniq.size # альт
# найти сами эти последовательности можно при помощи метода combination тк он сохраняет порядок(5 kyu Longest Common Subsequence)

# Формула всех непоследовательных подмножеств(все члены непоследовательны) чисел от 1 до n = сумме чисел фибоначи по число n


# генерация строки треугольника паскаля #nCr = (nCr(-1) * (n - r + 1))/r, где 1 ≤ r ≤ N   и  тС0 == 1
# строка треугольника паскаля это колличество подмножеств(1е значение число нулевых подмножеств, 2е- число подмножеств из одного элемента, 3е - число подмножеств из 2х элементов...)
# так же это коэфициенты многочлена получаемого из (a+b)**n
def paskal_line(n)
  res = [1]
  1.upto(n-1) do |x|
    res << res[-1]*(n-res.size)/res.size #nCr = (nCr(-1) * (n - r + 1))/r, где 1 ≤ r ≤ N
  end
  res
end
# сумма элементов диагонали треугольника Паскаля до элемента энной строки(нумерация от 0)
# 1 * (p+1)/1 * (p+2)/2 * (p+3)/3 * ... * (p+n)/n   формула энного элемента диагонали
def diagonal(n, p) # p номер диагонали, n номер строки
  m=n-p
  e,k=1,1
  res=[1]
  m.times do
    e=e*(p+1)/k
    res << e
    p+=1
    k+=1
  end
  res.sum
end
# короткий вариант
(1..n+1).last(p+1).reduce(:*) / (1..p+1).reduce(:*)


puts
# Сумма чисел от 1 до N, формула n*(n+1)/2

# колличество чисел от 1 до n делящееся на числа от a до z
n/(a..z).to_a.reduce(:lcm) # для простых чисел, вместо lcm просто их произведение

# Cумма чисел кратных m и n до числа x(включительно(если нет то x-1))
(1..x/n).sum*n + (1..x/m).sum*m - (1..x/(n*m)).sum*(n*m)

# Сумма n чисел делящихся на 3
3*(n/3).floor*(n/3+1).floor/2


# 1 3 6 10 15 21 ...
# Формула энного пятиугольного числа n*(3*n-1)/2
# Формула суммы первых к треугольных чисел  S = (n*(n+1)*(n+2))/6


puts
# Колличество прямоугольников(втч пересекающихся) в прямоугольнике (x**2+x)*(y**2+y)/4
# (x+1)*(y+1)*z + (x+1)*y*(z+1) + x*(y+1)*(z+1)  Число ребер в блоке включая внутренние

# число квадратов в сетке nxn
(1..n).map{|e| e**2}.sum # медленно
(n*(n+1)*(2*n+1))/6  # быстро
# число квадратов в сетке mxn
(0..[m,n].min).sum{|k| (n-k)*(m-k)}
y*(y + 1)*(3*x - y + 1)/6
# число прямоугольников в сетке mxn
m*(m+1)*n*(n+1)/4

# Формула путей вправо-вниз для квадратной сетки n*n  =>  (2*n)!/(n!)**2
(1..2*n).inject(:*)/(1..n).inject(:*)**2
# Формула путей вправо-вниз для прямоугольной сетки m*n
(1..m+n).inject(:*)/((1..m).inject(:*)*(1..n).inject(:*))
# Если есть оштбки с nil
mn=(1..m+n).inject(:*) || 1
mm=(1..m).inject(:*) || 1
nn=(1..n).inject(:*) || 1
mn/(mm*nn)


# сумма всех блоков пирамиды с высотой h  где начальные стороны w l а каждый след блок w2=w1+1 l2=l1+1
#(w..w+h-1).to_a.zip((l..l+h-1).to_a).map{|a,b| a*b}.sum
#h*w*l+(1..h-1).sum*w+(1..h-1).sum*l+(1..h-1).map{|k| k**2}.sum
h*w*l+(1..h-1).sum*w+(1..h-1).sum*l+(h-1)*(2*h-1)*h/6 # самое быстрое


# сколько клеток пересекает диагоняль в клетчатом прямоугольнике
h+w+h.gcd(w)-2 # вместе с касаниями по углам клеток(без 2 крайних точек)
h+w-h.gcd(w) # без касаний по углам клеток


puts
# На сумму последовательных положительных чисел можно разложить любое число кроме степеней 2йки

# Минимальное число послед чисел [n/2+1,n/2] if n.odd? а для четных просто делим на след число частей (на 3 на 4 итд) делаем эти числа последовательными и проверяем сумму( друг решения https://www.codewars.com/kata/59321f29a010d5aa80000066/solutions/ruby)

# максимальное число послед чисел: суммируем цифры с 1 до тех пор пока сумма не превысит n (для 25 это 1+2+3+4+5+6+7=28) если эта сумма больше заданного выбрасываем слагаемые слева, иначе добавляем следующее слагаемое справа, все это пока не получим n

# найти отсутствующее число в массиве последовательных чисел при помощи арифм прогрессии (s=(a1+an)*n/2)
(a[0]+a[-1])*(a.size+1)/2-a.sum


# разложить число на максимальную сумму квадратов если это возможно: находим корень из числа = k (1..k) суммируем квадраты первых чисел пока сумма не станет больше заданного числа тогда отнимаем из начала, если становится больше снова прибавляем числа дальше и так пока не будет равно числу.

# разложить число на все суммы 2х квадратов что возможно:
def all_squared_pairs(num)
  (0..((num/2)**0.5).floor).each.with_object([]) do |n,res| # (1..((num...
    r=(num-n**2)**0.5
    res << [r,n].sort if r%1==0  # return [r,n].map(&:to_i).sort if r%1==0
  end
end

# сумма последовательных квадратов чисел от 1 до n  ->  Sn=n(n+1)(2n+1)/6


puts
# Число цифр в факториале числа n
(Math.log10(2 * Math::PI * n) / 2 + n * Math.log10(n / Math::E)).ceil

# https://habr.com/ru/post/444112/    Подсчет конечных нулей факториала числа в любой системе счисления
require 'prime'
def factorial_tail_zeroes(base, n) # число нулей == коллич base на которые можно поделить факториал
  base.prime_division.map{|k,p| # колич base == минимальному из количеств множителей base
    x=Math.log(n, k).round(7).floor # считаем коллич простых множителей base в множителях факториала
    res=0
    until x==0 # считаем общее коллич простых множителей(например в 25 две 5)
      res+=n/k**x
      x-=1
    end
    res/p # делим на степень(число) у простого множителя base, тк их минимальное чило для получения факториала именно такое
  }.min
end
p factorial_tail_zeroes(16, 16)# 3, "16! has 3 zeroes"

# последняя ненулевая цифра факториала https://www.justquant.com/numbertheory/how-to-find-last-non-zero-digit-in-a-factorial/
# последняя цифра степени https://www.justquant.com/numbertheory/units-digit-of-a-number-raised-to-power/
# пример 2х этих   https://www.codewars.com/kata/5f79b90c5acfd3003364a337  6 kyu  Last non-zero digit of factorial


puts
#Нахождение последней цифры числа фебоначи с индексом i, начиная от 1 1 2...
q=5**0.5
(((1+q)/2)**(i%60)/q).round%10


# Сортировка чисел(разного порядка) чтобы собрать(сложив как строки) из них наибольшее число
array.map(&:to_s).sort{|a,b| b+a <=> a+b}.join.to_i


# формула ряда треугольника флоида по числу
Math.sqrt(n * 2).round
((1+Math.sqrt(1+8*(n-1)))/2).floor


# задачи про открывание и открывание n шкавчиков(сначала каждый потом через 1 потом через 2 итд) - в конце останутся элементы с индексами квадратов чисел от 1 до k**2<=n
(1..Math.sqrt(n).floor).size
Math.sqrt(n).floor # равнозначно тому что выше


# Входят или нет числа в бесконечную последовательность из которой удалили кажое 2е чисто, потом каждое 3е из оствшихся, потом каждое 4е из оставшихся итд до бесконечности (1,3,7,13...)
def survivor(n)
  k=2
  until k>n
    return false if n%k==0
    n-=n/k
    k+=1
  end
  true
end


# сумма индексов в d-мерном массиве где в каждой мерности по n элементов
n**d*d*(n - 1)/2


# все нечетные числа и все четные числа, кратные 4, могут быть выражены как разность двух совершенных квадратов.
# n/4+(n.odd? ? n/2+1 : n/2)
















#
