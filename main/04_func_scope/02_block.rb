puts '                                        Block, Proc и lambda'

# Block, Proc и lambda - это анонимные функции (способы создания анонимных функций) тоесть методов без имени с особым синтаксом и минорными отличиями друг от друга. Они позволяют передавать код как данные

# Анонимный метод - это в Руби метод без имени, блок/кусок кода, который можно присвоить в переменную, тоесть сделать его выполнение отложенным
proc = Proc.new { 'какойто_код' } # создание анонимного метода и присвоение его в переменную
p proc.call #=> "какойто_код"     # вызов анонимной функции

# Callback (функция обратного вызова) - передача исполняемого кода в качестве одного из параметров другому коду. Обратный вызов позволяет в функции исполнять код, который задаётся в аргументах при её вызове

# Сходства:
# Позволяют создавать код, который можно вызывать как функцию без необходимости объявления ее имени.
# Можно передавать как аргументы в методы, сохранять в переменные и передавать между функциями.
# Содержат код, который можно выполнить с помощью метода `call` (или `()`).

# Различия:
# |                       | Block                       | Proc                          | Lambda                    |
# |-----------------------|-----------------------------|-------------------------------|---------------------------|
# | Синтаксис             | `{ }` или `do  end`         | `Proc.new { }` или `proc { }` | `lambda { }` или `-> { }` |
# | Аргументы             | Неявно передаются методу    | Явно определяются             | Явно определяются         |
# | Возврат               | non-local return            | non-local return              | local return              |
# | Количество аргументов | Не проверяется              | Не проверяется                | Проверяется               |
# | Область видимости     | Зависит от контекста вызова | Сохраняет область видимости, в которой создан             |

# И лямбды и процедуры и блоки(переданные через &) это образцы одного класса Proc
def three_ways(proc, lambda, &block)
  p proc   #=> #<Proc:0x0000020841c7b2f8 E:/doc/ruby_exemples/test3.rb:14>
  p lambda #=> #<Proc:0x0000020841c7a768 E:/doc/ruby_exemples/test3.rb:15 (lambda)>
  p block  #=> #<Proc:0x0000020841cb33d8 E:/doc/ruby_exemples/test3.rb:17>
  proc.call               #=> "I'm a Proc for sure."
  lambda.call             #=> "But what about me?"
  yield                   #=> "I'm a block"
  block.call              #=> "I'm a block"
end
anonymous = Proc.new { puts "I'm a Proc for sure." }
nameless  = lambda { puts "But what about me?" }
three_ways(anonymous, nameless) { puts "I'm a block" }

# Block: Лучше всего подходят для простых, одноразовых задач, передаваемых непосредственно в методы (например, итерация по массиву, фильтрация, сортировка). Не требуют явного сохранения в переменную.
# Proc: Подходят для более сложных задач, которые нужно переиспользовать несколько раз, передавать между методами или сохранять в переменные. Однако, следует помнить о не-локальном возврате.
# Lambda: Подходят для создания функций, которые должны вести себя как обычные функции (с локальным возвратом и строгой проверкой аргументов). Особенно полезны для написания тестов и случаев, когда важна предсказуемость и изоляция. Часто используются, когда необходимо передать поведение (алгоритм) в качестве аргумента в функцию, и при этом хочется избежать побочных эффектов нелокального возврата. Как правило, Lambda является более безопасным и предсказуемым вариантом, особенно в сложных сценариях.



puts '                                               Block'

# Блок - это кусок кода, что содержится между {} или do end. Нужен чтобы чтобы добавить какую-то опциональную логику в определенный метод. Не являются объектами сами по себе, а передаются методам. Блоки могут быть вложенными, тоесть находиться/передаваться внутри тела других блоков.

# Блок может быть принят методами, через синтаксис пристыковки кострукции {} / do...end после параметров. Таким способом передать методу можно только 1 блок. Это нужно, например чтобы добавить какую-то опциональную логику в определенный метод
function_name(par1, par2) do |a1, a2|
  # ... код блока
end

[1, 2, 3].each do |el| # block - это все что содержится между {} или do end, например тут в итераторе код из блока будет выполняться для каждого элемета массива
  %w[a b c].each { |e| e } # блок вызван внутри другого блока
  a = 1
end

# Локальные переменные инициализированные в блоке, во вне его уже не будут существовать:
p a #=> undefined local variable or method `a' for main:Object (NameError)



puts '                                               yield'

# yield - ключевое слово(на самом деле метод), вызывает/исполняет блок (как бы плэйсхолдер оператора метода, только анонимного, работает похоже на super), который был передан в метод через синтаксис пристыковывания, код из блока помещается/выполняется в тех местах где стоит yield. yield может передавать значения для параметров блока.
def demo0(n1, n2)
  yield      #=> "Hello from block!"    # тоесть код из блока подставляется сюда
  sum = n1 + n2
  yield      #=> "Hello from block!"    # можно вызвать сколько угодно раз в любом месте тела метода
  sum
end
# оператор метода принимает аргументы(если они есть) и блок, но "пристыкованный блок" имеет как бы отложенное исполнение
demo0(101, 50) { puts "Hello from block!" }
# Чтобы использовать оператор 'p' к оператору принимающему блок с синтаксисом do end нужно взять все в скобки иначе будет ошибка
p (demo0(101, 50) do
  print "Foo!"
end) #=> 151

# Передача аргументов в блок и соответсвующие параметры для yield
def demo(*args)
  args.map do |n|
    yield(n, 5) # тут подставляется блок, например { |e, num| ... }, в переменную 'e' которого передается значение 'n', а в переменную 'num' число 5, в итоге блок исполнает свой код с этими параметрами тут. Тоесть yield работает как оператор метода
  end.sum
end
p demo(101, 50, 2, 3, 5, 6, 7) { |e, num| e.even? ? e + num : e - num } #=>  169



puts '                                           block_given?'

# По умолчанию будет вызвана ошибка если вызывается yield, а блок не передан
def compute
  yield
end
p compute #=> no block given (yield) (LocalJumpError)


# block_given?  - метод обределяет был ли передан блок в текущий метод. Помогает не получать ошибку если блок не передан
def compute
  if block_given?              # проверяем был ли передан блок, чтобы избежать возможной ошибки
    yield                      # теперь будет выполнено только если блок передан
  else
    'block is not transmitted' # теперь вместо ошибки получаем строку с сообщением
  end
end
p compute { 'Block' } #=> "Block"
p compute             #=> "block is not transmitted"



puts '                                    Синтаксис &block. Метод call'

# Если перед последним параметром метода стоит &, то этот параметр может и должен принять блок. Параметр с & всегда должен быть самым последним, после параметров с * и **.
# & - обозначанет что в переменную передан кусок кода/блок, который может быть выполнен потом(отложенное исполнение)

# Блок помещенный в переменную при помощи & превращается в Proc, тоесть в объект ??ссылающийсяна функцию??

# call - метод вызывает/исполняет блок процедуру, это действие равнозначное с yield и можно их использовать в одном и том же методе. Может принимать аргументы для блока.

# Метод call обычно ассоциируется с объектами, которые являются экземплярами классов, реализующих интерфейс "вызова" (callable interface). Это может быть как Proc, так и Lambda. Эти объекты могут быть вызваны как методы, используя call.

def some(par, &block)
  block.call    #=> "foo 0"      # содержание блока подставляется/исполняется методом call
  block.call(1) #=> "foo 1"      # можно вызвать блок несколько раз
  block.()      #=> "foo 0"      # альтернативный способ вызова
  block.(par)   #=> "foo a"      # альтернативный способ вызова
  block[]       #=> "foo 0"      # альтернативный способ вызова 2
  block[2]      #=> "foo 2"      # альтернативный способ вызова 2
  yield         #=> "foo 0"      # block.call это равнозначное действие с yield и можно их использовать в одном и том же методе
end
some('a') { |n = 0| p "foo #{n}" }


# block.call может быть удобнее чем yield, тк можно передать переменную с блоком, например в другой метод:
def method1(proc, &block)
  # Если метод принимает парамертр с синтаксисом & то и в операторе, тоже нужно использовать &
  method2(&block)  #=> "hello from method1!"
  # Соответсвенно также можно передать и предварительно созданный Proc
  method2(&proc)   #=> "hello"
end
def method2(&block)
  block.call
end
proc = proc { p "hello" }
method1(proc) { p "hello from method1!" }

# Тк синтаксис &block взаимозаменяем с синтаксисом пристыковки блока, то можем передавать его вместо пристыковки во встроенные методы принимающие блоки:
def all_nums?(*args, &block)
  args.all?(&block) # передаем блок {|n| n.positive? } во встроенный метод массивов
end
p all_nums?(1, 2, 3) {|n| n.positive? } #=> true


# Пример. Помещаем блоки в хэш
@hh = {}
def on(par, &block)
  @hh[par] = block
end
on('a') { puts 'foo' }
on('b') { puts 'bar' }
@hh.each_value(&:call) #=> foo #=> bar



puts '                                Метод call (Дополнение) Chain adding function'

# Можно дополнительно создать свой метод call в любом классе, чтобы сделать экземпляры этого класса вызываемыми, например через синтаксис .() тк вызов метода без названия тоже вызывает метод call
class MyCallable
  def call(x)
    x * 2
  end
end
obj = MyCallable.new
p obj.call(5) #=> 10
p obj.(3)     #=> 6

# Проверим через method_missing что вызывается
class Fixnum # класс можно, например Integer, в зависимости от того какие значения
  def method_missing(method, par)
    # p method #=> :call  # method по умолчанию(если после точки ничего нет) имеет значение :call
    self + par
  end
end
# Возвращенное число уже от себя вызывает несуществующий инстанс метод
p 5.(6).(1)      #=> 12

# Реализуем сразу через метод call
class Fixnum
  def call n  # тк метод без названия по умолчанию это call, то сразу можно его и использовать
    self + n
  end
end
p 5.(6).(1)      #=> 12

# (?? как это работает нихера не понятно)
def add(n)
  def call(m)
    self + m
  end
  n
end
p add(5).(6).(1)      #=> 12



puts '                                               Proc'

# Proc — это объект, который инкапсулирует блок кода. Можете создать объект Proc и вызвать его с помощью метода call. Преимущество процедур в том, что в отличие от простых блоков, метод может принимать множество процедур как обычные параметры

# 1. Создание процедуры в методе через &
def method1(&block)
  p block       #=> #<Proc:0x000001b6ff2263b8 E:/doc/ruby_exemples/test.rb:4>
  # E:/doc/ruby_exemples/test.rb:4  - те имеет привязку к строке кода в которой определен изначально
  p block.class #=> Proc   # тоесть блок помещенный в переменную превращается в процедуру
end
method1 { "hello from method1!" }

# 2. Создание процедуры через класс Proc, куда передаем блок кода который будет исполнять процедура. Синтаксис или {} или do end
p = Proc.new { puts "hello from proc!" } #=> #<Proc:0x000001b8e954e3b0 E:/doc/ruby_exemples/test.rb:1>
p.call #=> "hello from proc!"  # код процедуры вызывается при вызове мтодом call, те это отложенный вызов
p.()   #=> "hello from proc!"  # альтернативный способ вызова процедуры (тоже применит метод call)
p[]    #=> "hello from proc!"  # альтернативный способ вызова процедуры 2

# 3. Создание процедуры при помощи метода proc, в который передаем блок кода который будет исполнять процедура
p2 = proc do |a, b|
  puts "hello from proc!"
  a + b
end
p p2.call(10, 20) #=> 30     # Процедура в Руби возвращает результат своей работы
p p2.(10, 20)     #=> 30
p p2[10, 20]      #=> 30


# Можно передать процедуру в метод, предварительно поместив ее в обычную переменную без &, тк это уже изначально процедура - объект и образец класса Proc, а не просто блок(кусок кода).
def caller(my_proc, my_proc2) # метод может принимать множество процедур
  my_proc.call(5) + my_proc2.call(10, 20)
end
pr = proc { |n| n * 2 } # помещаем процедуру в переменную
pr2 = proc { |a, b| a + b }
p caller(pr, pr2) #=> 49



puts '                                            lambda-функции'

# Lambda (lambda-функции / lambda-выражения) - это другой тип объекта клааса Proc, который также инкапсулирует блок кода, создающий анонимный метод, который можно передавать в качестве аргумента или по другому - это указатель на функцию у которой нет названия/имени, но ведет себя чуть иначе, чем Proc. Например, он проверяет количество аргументов.

# Если функция содержит более 3х операторов то принято использовать обычные функции(методы), если 2 и меньше тогда lambda-функции.

# 1. Создание лямбды через метод lambda, в который передаем блок кода который будет исполнять лямбда. Синтаксис или {} или do end
my_l1 = lambda do |a|
  a + ' кто-то'
end
# Вызов lambda-функции производится:
p my_l1.call("hello") #=> "hello кто-то"      # 1. ключевым словом call
p my_l1.('hi')        #=> "hi кто-то"         # 2. просто точкой без имени метода что равнозначно call
p my_l1['yo']         #=> "yo кто-то"         # 3. через []

# 2. Создание лямбды через синтаксис "->" (lambda rocket). Синтаксис или {} или do end
my_l2 = ->(n) { n**2 } # скобки вокруг аргументов не обязательны, но рекомендуется для читаемости
my_l2 = -> n { n**2 }
p my_l2.call(6) #=> 36


# Лямбду(и обычный прок) можно передать и через & как обычный блок, например для методов что ожидают именно такой передачи
def array_procs(arr, lamb)
  arr.map(&lamb)
end
p array_procs([1, 2, 4, 6], lambda{|i| i * 2}) #=> [2, 4, 8, 12]
p array_procs [1, 2, 4, 6], ->(i) do
  i * 2
end #=> [2, 4, 8, 12]


# Пример использования 1:
say_hi = lambda { puts 'hi'}
say_bay = lambda { puts 'bay'}
week = [say_hi, say_hi, say_hi, say_hi, say_hi, say_bay, say_bay]
week.each{|f| f.call} #=> "hi" "hi" "hi" "hi" "hi" "bay" "bay"

# Пример использования 2:
sub_10 = lambda {|x| return x - 10} # return в lambda-функции так же необязателен как и в обычной
a = sub_10.call 1000
puts a #=> 990

# Пример использования 3 (Однорукий бандит):
add_10 = lambda {|x| x + 10}
add_20 = lambda {|x| x + 20}
sub_5 = lambda {|x| x - 5}
hh = {11 => add_10, 22 => add_10, 33 => add_10, 44 => add_10, 55 => add_10, 66 => add_10, 77 => add_20, 88 => add_20, 99 => add_20}
sum = 1000
loop do
	puts "sum is #{sum}"
	gets
	res = rand(100)
	puts "res is #{res}"
	sum = hh[res] ? hh[res].call(sum) : sub_5.call(sum)
end

# (?? Потом перенести в замыкания ??)
# Пример использования 4 (С мутными цепными вызовами и вложенными лямбдами):
def compose(add, id)
  # Вернем лямбду принимающую вызовы лямбд
  ->(*args){ add.(id.(*args)) } # *args в данном случае это 0, так что можно было написать и просто arg
  # id.(*args) => ->(a){a}  => ->(a){0}  => 0
  # add.(id.(*args)) => add.(id.(0)) => ->(a){a + 1}  => ->(a){0 + 1}  =>  1
end
add = ->(a){a + 1}
id  = ->(a){a}
add_id = compose(add, id)
p add_id               #=> #<Proc:0x0000028151244af8 E:/doc/ruby_exemples/test3.rb:3 (lambda)>
p add_id.(0)           #=> 1
p compose(add, id).(0) #=> 1



puts '                                     Отличия лямбды и процедуры'

# 1. Количество аргументов:
# Ruby позволяет вызывать Proc с любым количеством аргументов. Если при вызове процедуры не передать аргументы, то в их параметры назначатся значения nil. А если передать больше аргументов, чем есть параметров - то они проигнорируются
p = proc { |arg1| arg1 }
p p.call          #=> nil
p p.call(1, 2, 3) #=> 1
# Ruby строго проверяет количество аргументов, переданных Lambda.  Если количество не совпадает, будет выброшено исключение `ArgumentError`
l = lambda { |arg1| arg1 }
p l.call          #=> wrong number of arguments (given 0, expected 1) (ArgumentError)
p l.call(1, 2, 3) #=> wrong number of arguments (given 3, expected 1) (ArgumentError)


# 2. Возврат:
# Block и Proc: `return` внутри блока или Proc вызывает *non-local return*, то есть, возвращает управление из метода, *который вызвал блок/Proc*
def my_method_proc
  my_proc = Proc.new { return 10 }
  my_proc.call
  puts "After proc call" # Никогда не будет выполнено
  20
end
puts my_method_proc # Выводит 10, так как Proc вернул из my_method_proc
# Lambda: `return` внутри Lambda вызывает *local return*, то есть, возвращает управление из Lambda, подобно тому, как `return` работает в обычных методах.  Lambda действует как независимая функция.
def my_method_lambda
  my_lambda = lambda { return 10 }
  my_lambda.call
  puts "After lambda call" # Будет выполнено
  20
end
puts my_method_lambda # Выводит "After lambda call", затем 20


# 3. Proc и Lambda: Сохраняют область видимости, в которой они были созданы (замыкание или closure). Это означает, что они имеют доступ к переменным, которые были определены в окружающей их области.  Блок, хотя технически не объект, ведет себя похожим образом.
def my_method
  x = 10
  my_proc = Proc.new { puts x }
  my_lambda = lambda { puts x }
  x = 20
  my_proc.call    # Выводит 20
  my_lambda.call  # Выводит 20
end
my_method


# 4. Лямбда создает свою область выдимости, а процедура нет
def demo(obj)
  puts "before obj call"
  obj.call # внутри этого вызова будет выполняться return для лямбды или процедуры
  puts "after obj call"
end
p = proc do
  puts "I'm inside proc!"
  return 42 # возврат сработает не в том месте, где вызвана процедура или блок, а в том где определена, те срабатывает в контексте той области видимости, в которой определена, соотв завершает и метод и всю программу тут.
end
l = lambda do
  puts "I'm inside lambda!"
  return 42 # срабатывает в контексте лямбды и завершает лямбду, соотв лямбда сосздает собственную область видимости
end
demo(p) #=> before obj call #=> I'm inside proc!
demo(l) #=> before obj call #=> I'm inside lambda! #=> after obj call


# Тоже на примере создания внутри метода
def fuu
  f = Proc.new {return "return from foo from inside proc"}
  f.call
  "return from fuu"
end
def bar
  f = lambda {return "return from lambda"}
  f.call
  "return from bar"
end
p fuu #=> "return from foo from inside proc"
p bar #=> "return from bar"



puts '                           Блоки объявления начала и конца кода(BEGIN и END)'

# BEGIN - ключевое слово/оператор объявляет блок который будет исполнен в самом начале программы
puts "This is main Ruby Program"
BEGIN {
  puts "Initializing Ruby Program" # эта строка будет 1й в прграмме
}
#=> Initializing Ruby Program
#=> This is main Ruby Program

# END - ключевое слово/оператор объявляет блок который будет исполнен в самом конце программы
END {
  puts "Terminating Ruby Program"  # эта строка будет последней в программе
}
puts "This is main Ruby Program"
#=> This is main Ruby Program
#=> Terminating Ruby Program



puts '                                              Разное'

# Блок и Enumerator. Вызов yield как метода
def sequence(&b) # передача блока в параметры
  Enumerator.new do |y|
    n = 0
    loop do
      # вариант синтаксиса 1 (не нужна передача блока в параметры)
      y << yield(n)
      # вариант синтаксиса 2 (нужна передача блока в параметры)
      y.yield b.call(n)
      n += 1
    end
  end
end
sequence{|n| n}.take_while {|n| n < 10} #=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
sequence{|n| (n * n)}.take(10)          #=> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]













#
