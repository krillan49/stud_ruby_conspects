puts '                                             Scope'

# scope / область видимости - область в коде, в которой переменные и другие идентификаторы (например, функции или классы) доступны для использования. Это понятие определяет, где переменные могут быть определены и доступны, а также как они могут быть использованы в коде

# Понимание области видимости помогает избежать конфликтов имен и непреднамеренного изменения данных

# В Ruby вложенность может влиять на область действия констант и классов. Если класс или модуль определен внутри другого класса или модуля, он является вложенным, и его область действия ограничивается включающим его классом или модулем. Это означает, что доступ к нему возможен только из класса или модуля, в который он вложен.



puts '                                   self. Область верхнего уровня'

# self - это специальная переменная, ссылающаяся на текущий объект, тот в контексте которого интерпретатор выполняет блок кода. Такой объект всегда существует, даже в корневой области видимости (объект main класса Object)

# Нахождение на верхнем уровне просто означает, что либо вы еще не вызывали ни одного метода, либо все ваши вызовы методов вернулись

p self       #=> main
p self.class #=> Object

# Для обращений к элементам интанс-объекта не обязательно указывать self, так как он подразумевается по умолчанию.



puts '                               Типы переменных и их область видимости'

# Область видимости переменных бывает 3х типов:
# глобальная (global scope) - переменную объявленную в этой области ($) видно в любой части программы. С этой областью нужно быть осторожным и в Руби она почти не используется, кроме как для хранения технической информации, например версии ОС
# локальная (lockal scope) - например тело метода для созданной в нем локальной переменной
# классовая (class scope) - используется в ООП-языках. Например в Руби переменные экземпляра доступны во всех методах класса, а извне класса только через методы-геттеры


# 1. local variable / локальная переменная
local_var = 'some'
# Переменная доступная(локализованная) только в области действия(той области кода, в которой она объявлена), например внутри метода, можно определить(объявить) только в том же методе.
# Если локальная переменная не объявлена, то будет ошибка исполнения программы.
# Локальные переменные начинаются со строчной буквы или с символа "_".

# 2. instance variable / переменная экземпляра / переменная образца класса
@instance_var = 'some'
# Доступня только внутри определенного объекта и для всех методов экземпляра класса (или методах той области в которой объявлена вне класса, тоесть объект main класса Object). Недоступна непосредственно из области определений классов.
# Переменные экземпляра, self-привязаны и доступны для всех связанных с данным объектом методов
# Желательно объявлять instance variables в конструкторе, но можно определить в любом методе класса.
# Если переменная экземпляра не объявлена, то ее значение по-умолчанию будет равно nil
# Имеют разные значения для разных объектов. Эти переменные определяют состояние объекта.

# 3. class variable / переменная класса / переменная шаблона / статическая переменная
@@class_var = 'some'
# Доступна из области определения класса и любых подклассов. Недоступна откуда-либо снаружи.
# Переменная сохраняет свое значение во всех экземплярах класса(для всех объектов класса эта переменная будет одинакова). Например если мы меняем ее значение для одного объекта, то ее значение изменится на такое же для других объектов класса. Переменная класса принадлежит классу и является характеристикой класса.
# Невозможна инициализация вне тела класса. Неинициализированная переменная класса приводит к ошибке.
# Так как это глобальная переменная для всех объектов класса и она изменяема, то ее использование нежелательно, лучше использовать константу

# 4. global variable / глобальная переменная
$global_var = 'some'
# Доступна во всей программе как вне так и внутри класса, можно определить ее вне класса и она будет доступна и внутри класса и в любом месте кода вне класса.
# Неинициализированные глобальные переменные имеют значение nil и выдают предупреждения с опцией -w.

# 5. constant / константа
CONSTANT = 'some'
# Значение этой переменной невозможно изменить после ее определения. Нужна для задания неких констант, например PI = 3.14. Имя константы начинается с заглавной буквы.
# Константы не могут быть определены внутри методов.
# К константам, определенным внутри класса или модуля, можно получить доступ из этого класса или модуля, а к константам, определенным вне класса или модуля, можно получить глобальный доступ
# Ссылка на неинициализированную константу приводит к ошибке

# 6. Специальные переменные
# Например, переменная `ARGV` содержит аргументы, переданные в программу. А переменная `ENV` содержит параметры окружения (environment) - т.е. параметры, которые заданы в вашей оболочке (shell).

$global_var = 'Доступна везде. Определяется где угодно'
CONSG = 'Константа вне класса'

class App
  CONSTANT = 'Значение никогда не меняется. Попытка изменения выдаст ошибку'
  @@class_var = 'Одно значение для всех экземпляров класса'

  def initialize
    @instance_var = 'Доступна в методах класса. Определяется в методах класса'
  end

  def print_variables
    local_var = 'Доступна и определяется только в конкретном методе'

    puts $global_var
    puts CONSTANT
    puts @@class_var
    puts @instance_var
    puts local_var

    ::CONSG # Вызов константы извне тела класса в тело класса
  end

  def chenge_class_var
    @@class_var += ' +1'
  end

  def print_class_var
    puts @@class_var
  end
end

App.new.print_variables #=> значения всех переменных выводимых(puts) методом print_variables
puts $global_var        #=> "Доступна везде. Определяется где угодно"

# Примеры для @@class_var
a, b, c = App.new, App.new, App.new
a.print_class_var    #=> "Одно значение для всех экземпляров класса"
p a.chenge_class_var #=> "Одно значение для всех экземпляров класса +1"
b.print_class_var    #=> "Одно значение для всех экземпляров класса +1"
p b.chenge_class_var #=> "Одно значение для всех экземпляров класса +1 +1"
c.print_class_var    #=> "Одно значение для всех экземпляров класса +1 +1"

# classname::constant - получить доступ к константе класса вне класса
p App::CONSTANT #=> "Значение никогда не меняется. Попытка изменения выдаст ошибку"



puts '                                    Жизненный цикл переменных'

# Глобальные переменные существуют пока существует программа, как только программа перестала выполняться, то и глобальные переменные исчезают, а объекты на которые они ссыллись удаляются их оперативной памяти сборщиком мусора

# Локальная переменная, например объявленная в методе, существует до того как интерпритатор отработает с этим методом, когда метод закончился, то локальная переменная удаляется, а объект на который она ссылалась стирается из оперативной памяти сборщиком мусора, если на него не было других ссылок. Но если объект возвращается как результат работы метода, тогда он не удаляется, если для него будет создана переменная в той области

# Переменные экземпляра класса существуют пока на объект есть какие-то ссылки в программе, а когда ссылок не будет, то объект удаляется сборщиком мусора и удаляются все его переменные



puts '                        Область видимости локальных переменных. Метод local_variables'

# Интерпретатор Ruby помещает локальную переменную в область видимости каждый раз, когда видит присвоение этой локальной переменной, независимо от того исполнялся ли код с этим присвоением или нет
# Локальные переменные изменяются и заменяются с каждой новой областью действия.

a #=> undefined local variable or method `a' for main:Object (NameError)
if false      # тоесть код в блоке условия не будет выполнен
  a = 'hello' # но интерпритатор увидел присвоение переменной, поэтому локальная переменная попала в эту область видимости
end
p a #=> nil   # тк код в блоке не выполнился, переменная не была инициализирована, но она попала в область видимости


# local_variables - метод, который возвращает массив имен (в виде символов) всех локальных переменных в данной области видимости
p local_variables #=> [:a]



puts '                                   Конфликты имен локальных переменных'

# Тк в Ruby методы можно вызывать без явного получателя и круглых скобок, те синтаксически они могут быть аналогичны локальным переменным, то могут возникнуть потенциальные конфликты имен методов и переменных
# Если есть локальная переменная и вызов метода с тем же именем в той же области видимости, локальная переменная будет «затенять» метод и иметь приоритет

# Для подсказки интерпретатору, что мы хотим вызвать метод, можно приписать self. или ():
def something
  'I am a method'
end
p something      #=> "I am a method"
something = 'I am a variable'
p something      #=> "I am a variable"
public :something # (?? Хз зачем нужно работает и без этого, мб устарело) Поскольку все методы, определенные на верхнем уровне, по умолчанию являются private
p self.something #=> "I am a method"
p something()    #=> "I am a method"



puts '                                        Врата области действия'

# Создание / переход в новую область действия осуществляется, когда:
# Определяется класс  (class SomeClass)
# Определяется модуль (module SomeModule)
# Определяется метод  (def some_method)

# Каждое определение метода/модуля/класса называется воротами области, поскольку создается новая область. Предыдущая область видимости больше не доступна, а все доступные в ней переменные заменяются новыми.

v0 = 0
p local_variables     #=> [:v0, :some_class]
# :some_class - (?? тк константа класса это тоже переменная ??)

class SomeClass   # class scope gate - когда мы вошли в класс, область верхнего уровня была заменена(временно).
  v1 = 1
  p local_variables   #=> [:v1]

  def some_method # def scope gate - Область действия класса была заменена областью действия метода экземпляра
    v2 = 2
    p local_variables #=> [:v2]
  end             # end of def scope gate
end               # end of class scope gate

some_class = SomeClass.new
some_class.some_method

p local_variables     #=> [:v0, :some_class]



puts '                                        Слом границ области'

# Чтобы получить доступ к переменным или методам из другой области видимости, нужно заменить стандартный синтаксис определения вызовами методов new или define_method с присвоением им блоков, содержащих тело класса, модуля или метода, тогда область видимости будет работать по правилам для блоков:
# Класс    class SomeClass ... end     ->   SomeClass = Class.new do ... end
# Модуль   module SomeModule ... end   ->   SomeModule = Module.new do ... end
# Метод    def some_meth ... end       ->   define_method(:some_meth) do ... end

v0 = 0
p local_variables #=> [:v0, :some_class]

SomeClass = Class.new do
  v1 = 1
  p local_variables #=> [:v1, :v0, :some_class]

  define_method(:some_method) do
    v2 = 2
    p local_variables #=> [:v2, :v1, :v0, :some_class]
  end
end

some_class = SomeClass.new
some_class.some_method

p local_variables #=> [:v0, :some_class]



puts '                                       Область видимости блоков'

# Локальная переменная определенная во внешней области - будет попадать в область видимости блока
# Локальную переменную из внешней области можно изменить в блоке
# Локальная переменная определенная в блоке - не будет попадать во внешнюю область видимости
hi = '123'
1.times do |item| # block scope begins here
  p hi #=> 123
  hi += 'AAA'
  hello = 'hello'
end
p hi #=> "123AAA"
# Переменная из блока не определена во внешней области:
p hello #=> undefined local variable or method "hello"


# Каждая итерация использования блока представляет собой новое определение блока, которое сбрасывает локальные переменные внутри него. В данном случае есть 2 итерации, поэтому в момент начала второй i снова сбрасывается в неопределенную и в 1.
res = []
2.times do
  i #=> undefined local variable or method `i'    # При каждой новой итереции переменной i снова не существует
  i ||= 1    # Тут переменная каждый раз назначается заново
  res << i
  i += 1
  res << i
end
p res #=> [1, 2, 1, 2]



puts '                                      Блочные локальные переменные'

# Чтобы блоки не изменяли внешние переменные, можно их продублировать(затенить) блочными локальными переменными.
# Локальные переменные блока пишутся через точку с запятой в конце, после параметров блока:
hi, hello = 'hi', 'hello'
1.times do |i; hi, hello| # тут i - единственный параметр блока, а hi и hello - блочные переменные
  p i #=> 0
  p [hi, hello] #=> [nil, nil]
  hi, hello = 'A', 7      # тут назначаются значения одноименным блочным переменным, еслиб их не было заданно, то были бы переназначены переменные из внешней области
  p [hi, hello] #=> ["A", 7]
end
p hi    #=> "hi"
p hello #=> "hello"



puts '                                Замыкание и блочные объекты(проки и лямбды)'

# Блоки, проки и лямбды видят ту область действия в которой они определены, а не ту в которой вызваны. Это связано с тем, что в Ruby они рассматриваются как замыкания.

# Замыкание — это код, который:
# 1. может передаваться как объект (который можно вызвать позже)
# 2. может запоминать переменные, которые находились той в области видимости, в которой было определено замыкание

# Так замыкания не будет тк область видимости с переназначением переменной это та же область, где назначили переменную и определили лямбду, тоесть переназначенная переменная будет доступна, вызванному после блоку лямбды
a = 1
ld = lambda { a }
a = 2
p ld.call #=> 2

# Чтобы создать замыкание, нужно создать отдельную область видимости, например при помощи метода:
def foo
  x = 1
  lambda { x }
end
x = 2
p foo.call #=> 1
# блок лямбды как бы остается во внешней области метода, а не в той, где она вызвана после возврата методом


# Это может пригодиться при определении генератора бесконечных чисел:
def increase_by(n)
  start = 0
  lambda { start += n } # блок видит переменную из внешней области и соотв определяет ее и в блоке
end
increase = increase_by(3) # присваиваем возвращаемую методом лямбду в переменную, теперь переменная start блока - независима
p increase.call #=> 3
p increase.call #=> 6


# Это может пригодиться, чтобы отложить изменение переменной, используя лямбду:
i = 0
change_i = lambda{ i = 3 }
p i #=> 0
change_i.call
p i #=> 3



puts '                       Использование одной локальной переменной 2мя методами'

# Можно создать 2 замыкания использующие одну и туже переменную (примерно как переменные класса для всех объектов, либо как множество методов в классе использующих переменные как бы экземпляра)

def let_us_define_methods
  shared_variable = 0

  define_method(:increase_var) do
    shared_variable += 1
  end

  define_method(:decrease_var) do
    shared_variable -= 1
  end
end

let_us_define_methods
p increase_var #=> 1
p increase_var #=> 2
p decrease_var #=> 1
















#
