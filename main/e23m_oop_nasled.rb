puts '                                        ООП. Наследование(inheritance)'

# https://habr.com/ru/articles/87205/   -   определения наследования, инкапсуляции, абстракции, полиморфизма

# В большинстве объектно-ориентированных языков, основанных на классах, объект, созданный путем наследования, «дочерний объект», приобретает все свойства и поведение «родительского объекта», за исключением: конструкторов, деструкторов, перегруженных операторов и функций друга базового класса.


# Наследование(inheritance) - позволяет создать класс, что будет наследовать(получит) все методы, поля и конструкторы главного класса. В подклассе можно использовать все методы надкласса, но при этом в каждом классе-наследнике добавить свои уникальные методы и свойства, не распространяющиеся на материнский класс или другие классы наследники.
# Материнский класс так же называется суперклассом
# Наследование может быть многоуровневым, когда класс наследник от одного класса является сам суперклассом для третьего.

class Transport # материнский класс
  attr_accessor :color, :wheels # данные переменные и их геттеры и сетторы унаследуются

  def say_bip # метод унаследуется
    puts "BipBip"
  end
end

class Car < Transport # Знаком < обозначаем, что класс Car унаследует все свойства, методы и конструктор у класса Transport
  attr_accessor :is_mechanic # Переменная(свойство) подкласса, не затрагивающая материнский класс

  def kolesa # При помощи метода тоже можно обращаться к переменной из материнского класса
    puts @wheels + 2 # значение этой переменной мат класса у объекта подкласса мы задали ниже
  end
end

class Moto < Transport
  def say_bip # Если мы создаем тот же метод и в подклассе, то мы его переопределяем для этого подкласса
    puts "Тыц Тыц"
  end
end

audi = Car.new # Объект audi класа Car, обладает всеми свойствами и родительского класса Transport и своими собственными
audi.color = "Black" # Задаем значение переменной материнского класса объекту подкласса
audi.color #=> "Black"  # Выводим значение переменной материнского класса у объекта подкласса
audi.wheels = 4
audi.kolesa #=> 6 #(4 + 2)
audi.say_bip #=> "BipBip"  # Метод из род класса Transport, работает на объекте подкласса Car

mers = Moto.new
mers.say_bip #=> "Тыц Тыц"  # Метод выводит из подкласса, тк мы его переопределили

mers.class #=> Moto
mers.class.superclass #=> Transport


puts
# Пример с классом почти таким же как сушествующий класс Hash но с другим способом вызова значения(по части ключа, при одинаковых по алфавиту)
class Xuesh < Hash
  def [](key)
    self.clone.to_a.select{|k, v| k.start_with?(key)}.sort_by{|k, v| k}[0][1] rescue nil
  end
end

xuesh = Xuesh.new
{"aaa" => 1,"abc" => 2,"dfg" => 3,"def" => 4,"dfgh" => 5}.each{|k, v| xuesh[k] = v} # заполняем хуеш
p xuesh #=> {"aaa"=>1, "abc"=>2, "dfg"=>3, "def"=>4, "dfgh"=>5}
p [xuesh['aa'], xuesh['ab'], xuesh['df'], xuesh['de'], xuesh['dfg'], xuesh['dfgh'], xuesh['b']] #=> [1, 2, 3, 4, 3, 5, nil]


puts
puts '                                         Subtyping(субтипирование)'

# Субтипирование использует механизм наследования для того чтобы выделить подтипы. Классы наследники являются подтипами к тому суперклассу, который обычно абстрактен и сам по себе не используется, а лишь содержит общий функционал для подклассов

class Player # Абстрактный класс Player содержит общую функциональность для всех подклассов, но при этом сам не используется
  attr_accessor :x
  def initialize(x)
    @x = x
  end
  def right
    self.x += 1
  end
  def left
    self.x -= 1
  end
  def label # Пустой метод(можно убрать) говорит нам что он присудствует во всех подклассах и везде будет разным
  end
end
# Классы Robot и Dog будут являться подтипами класса Player
class Robot < Player
  def label
    '*'
  end
end
class Dog < Player
  def left # Переназначаем метод ограничивая направление движения объектов подкласса Dog
  end
  def label
    '@'
  end
end

# ПРИМЕЧАНИЕ: при использовании наследования важно избежать неверной абстракции, например не сделать суперклассом тот класс, который впоследствии возможно нужно будет менять так, что изменения пойдут вразрез с функциональностью классов наследников, по этой причине иногда даже дублирование кода может быть предпочтительнее. Если вы не уверены в выбранной абстракции, используйте модули и честно копируйте код. Если вам кажется, что абстракция правильная, то создавайте абстрактный класс, который будет содержать общие для всех подклассов методы и данные.


puts
puts '                                     Наследование и конструктор. super'

# super - специальное слово при помощи которого можно передать значение из конструктора подкласса в конструктор суперкласса и соотв в его переменную. (?)Либо так как мы переопределяем конструктов в подклассе, соотв мы копируем при помощи super конструктор из суперкласса, добаляя в него новые переменные или значения.

# super инициализирует переменные экземпляра класса наследника при помощи конструктора материнского класса. Если в классе наследнике не использовать super, то этот конструктор уже будет полностью обособленным от материнского.
class Character
  attr_accessor :strength, :constitution
  def initialize
    @strength, @constitution = 5, 5
  end
end

class Human < Character
  # Если новая переменная не нужна, то можно обойтись и без конструктора подкласса и объект подкласса будет автоматически передавать значеня в конструктор суперкласса
end

class Elf < Character
  def initialize # так мы просто переопредеклим весь конструктор
    @strength = 3
  end
end

class Orc < Character
  def initialize
    super # через super мы используем конструктор суперкласса для инициализации переменных подкласса
    p [@strength, @constitution] #=> [5, 5]
    @strength = 7 # можно переназначить ту что нам надо для этого подкласса, либо добавить новую переменную
  end
end

human = Human.new
p human.strength # => 5

elf = Elf.new
p elf.constitution # => nil

ork = Orc.new
p ork.constitution # => 5


puts
# super  Передача значений аргументов из конструктора подкласса в конструктор суперкласса, для инициализации их в переменных. Передача значений из метода подкласса в метод суперкласса
class Song
  def initialize(name, artist, duration) # аргументы из super будут передаваться в аргументы конструктора тут
    @name, @artist, @duration = name, artist, duration
  end

  def to_info_S
    "Song: #{@name} - #{@artist} (#{@duration}sec)"
  end
end

class KaraokeSong < Song
  def initialize(name, artist, duration, lyrics)
    super(name, artist, duration) # передаем значения аргументов в конструктор суперкласса для того чтоб там инициализировать переменные экземпляра для данного подкласса. Если новая переменная не нужна, то можно обойтись без передачи(и без конструктора подкласса) и объект подкласса будет автоматически передавать значеня в конструктор суперкласса
    @lyrics = lyrics # инициализируем независимую переменную подкласса
  end

  def to_info_KS # используем переменные подкласса инициализированные материнским классом
    "KS: #{@name} - #{@artist} (#{@duration}sec). Text: #{@lyrics}"
  end

  def to_info_S # Метод подкласса с тем же названием что и метод суперкласса может использовать super для передачи к возвращаемого методом суперкласса значения
    "#{super}. Text: #{@lyrics}" # используем то что возвращает метод материнского класса
  end
end

class BrokenSong < Song
  def initialize(name, artist, duration)
    super(duration, name, artist) # тк передаются просто значения то в неправильном порядке передадутся не в те аргументы
  end
end

class HardcodeSong < Song
  def initialize(name, duration)
    super(name, 'Kroker', duration) # тк передаются просто значения то можно их хардкодить если надо
  end
end

ksong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
p ksong.to_info_S #=> "Song: My Way - Sinatra (225sec) [And now, the...]"

bsong = BrokenSong.new("My Way", "Sinatra", 225)
p bsong.to_info_S #=> "Song: 225--My Way (Sinatra)"

hsong = HardcodeSong.new("My Way", 225)
p hsong.to_info_S #=> "Song: My Way - Kroker (225sec)"
















#
