puts '                             ООП. Class Methods или статические(static) методы'

# Методы класса(статические методы) могут иметь дело с управлением всеми существующими экземплярами класса и работают без привязки к какому-либо конкретному объекту, а методы экземпляра класса(instance methods) имеют дело с одним экземпляром за раз. Например, чтобы подсчитать количество объектов, принадлежащих классу, пригодится метод класса
# методы класса запускаются в контексте класса (и имеют доступ только к переменным класса), а методы экземпляра запускаются в контексте объекта (и имеют доступ к переменным объекта/экземпляра)
# доступ к методу класса осуществляется через класс, а к методу экземпляра — через экземпляр/объект класса
# Например метод new является методом класса и создает новый объект, но сам по себе не связан с конкретным объектом.

class Example
  # instance method(метод экземпляра):
  def inst_meth
  end

  # class/static methods:
  def Example.hi_meth # Синтаксис 1. Статический метод(метод класса) определяется префиксом с именем класса.
    puts 'hi'
  end

  def self.bay_meth # Синтаксис 2. Статический метод(метод класса) определяется ключевым словом(в виде префикса) self
    puts 'bay'
  end
end
# Используя статический метод мы можем пользоваться таким упрощенным синтаксисом вызова метода:
Example.hi_meth #=> "hi"
Example.bay_meth #=> "bay"

# ПРИМЕЧАНИЕ: делать классы только со статическими методами не рекомендуется — нужно использовать модули. Классы следует использовать только тогда, когда имеет смысл создавать из них экземпляры.
# Класс содержащий только статические переменные(@@) и статические методы называется статическим классом


puts
# Например когда программа небольшая и нужен только 1 объект писать object_name = Classname.new не очень удобно(излишне) лучше использовать упрощенный синтаксис статичкских методов.
# Используется часто для того, чтоб разбить программу на отдельные блоки, чтоб удобно было разным программистам работать над отдельными блоками. Пример программы(части какой-то игры) разбитой на отдельные блоки:
class RandomEngine
  def self.get_random_value
    rand(100..999)
  end
end
class GameEngine
  def self.play
    random_value = RandomEngine.get_random_value
    # ... какоето использование random_value ...
  end
end
GameEngine.play


puts
# Передача объекта в метод класса в виде параметра
# Пример: Отсев песен превышающих заданное максимальное время.
class Song
  attr_reader :duration
  def initialize duration
    @duration = duration
  end

  def Song.is_too_long?(song) # Метод получает параметром объект
    song.duration > 300
  end
end

song1 = Song.new(260)
p Song.is_too_long?(song1) #=> false
song2 = Song.new(468)
p Song.is_too_long?(song2) #=> true


puts
# Использование методов класса в качестве псевдоконструктора(создание объектов):
# Применяется когда объекты класса нужно будет задавать по параметрам отличным от изначальных
class Shape
  attr_accessor :num_sides, :perimeter

  def initialize(num_sides, perimeter)
    @num_sides, @perimeter = num_sides, perimeter
  end
  # Методы класса которые будут возвращать заданные объекты класса(создавать новые объекты вместо метода new - псевдоконструктор) запрашивая при этом параметры отличные от тех что запрашивает конструктор и задавая при помощи них(и/или отдельно) параметры для конструктора.
  def Shape.triangle(side_length)
    Shape.new(3, side_length * 3)
  end
  def Shape.square(side_length)
    Shape.new(4, side_length * 4)
  end
end
# Объект созданный через конструктор напрямую с обращением к конструктору(new)
figure = Shape.new(5, 50) # требует число сторон и периметр
# Объект созданный через метод класса являющийся псевдоконструктором(triangle)
figure2 = Shape.triangle(8) # требует длинну стороны
p figure2 #=> #<Shape:0x0000012fe78b8f40 @num_sides=3, @perimeter=24>
p figure2.num_sides #=> 3
p figure2.perimeter #=> 24


# В методе класса можно вызвать другой метод класса без префикса
class Code
  def self.some
    some2
  end

  private

  def self.some2
    p 'some2'
  end
end

Code.some #=> some2









#
