puts '                                      Циклы: while, until, loop и for'

# Циклы в Ruby используются для выполнения одного и того же блока кода определенное количество раз

# Переменная заданная в теле цикла, определена только в теле цикла


puts '                                          Цикл while(while true)'

# Условие цикла while отделяется от кода: зарезервированным словом do, новой строкой, обратной косой чертой \ или точкой с запятой
i = 0
some = true
while i <= 5 && some # Условие(может содержать несколько условий) цикла while("пока").
  print i
  i += 1 # Можно ставить операцию где угодно в теле цикла
  some = [false, true].sample
end
# Цикл перезапускается пока условие будет является истинной(true). Выводит столько значений(если в теле цикла есть оператор вывода) сколько их будет до того пока условие не станет false. Если условие не меняется(while 2+2=4) и постоянно является true то цикл будет выполняться бесконечное колличество раз.


# Цикл while с проверкой в конце. Удобно, если код нужно обязательно выполнить хотябы 1 раз, чтоб не писать его еще раз перед телом цикла. + можно создавать проверяемую условием переменную в теле цикла
i = 0
begin
  print "#{list [i]} "
  i += 1
end while i < list.size


# Однострочный синтаксис begin end while
a = 5
puts "#{a -= 1}" while a > 2 #=> 4 3 2


# Пример прграммы угадайки:
def ugadaika()
  secret = "Blue"
  gues = ""
  while gues != secret
    puts "Угадайте цвет: "
    gues = gets().strip.capitalize
    puts "Цвет угадан неверно, попробуйте еще раз:" if gues != secret
  end
  puts "Цвет угадан верно"
end


puts
puts '                                            Цикл until(until false)'

# Цикл until ("пока не") с предусловием. Выполняет код , пока условие имеет значение false. Условие оператора until отделяется от кода зарезервированным словом do , новой строкой или точкой с запятой.
i = 0
until i == list.size do
  print "#{list[i]} "
  i += 1
end


# Цикл until с проверкой в конце
i = 0
begin
  print "#{list[i]} "
  i += 1
end until i == list.size


# Однострочный синтаксис begin end until
a = 5
puts "#{a += 1}" until a == 8 #=> 6 7 8


puts
puts '                                             Цикл loop(do)'

# Цикл loop аналогичен циклу while с условием true(Всегда бесконечный)
i = 10
loop do
  puts "hi"
  i -= 1
  break unless i <= 5 # прерывается только доп оператором
end


puts
puts '                                             Цикл for'

# Выполняет код один раз для каждого элемента в выражении.
# Выражение цикла for отделяется от кода зарезервированным словом do, новой строкой или точкой с запятой(но не фиг скобками)
x, y = 0, 5
for per in x..y do # do писать не обязательно
  # в переменную (тут per) присваивается каждое значение из диапазона
  print per #=> 012345 # Будет выводить каждое число диапазона пока они не кончатся
end


# цикл for не создает новую область для локальных переменных.
b = 10
for per in 0..5
  a = true
  b = per
  print per
end
p a #=> true
p b #=> 5


puts
# Цикл for per in some почти точно эквивалентен: some.each do |per|, только цикл for не создает новую область для локальных переменных.

# Пример цикла for для перебора массива(примерно как each)
nameS = ["Bob", "Kevin", "Alex", "George"]
for name in nameS # Будет выбирать в диапазоне массива nameS
  name += "!" # В цикле удобно добавлять каждому элементу что-то, чтоб не прописывать для каждго отдельно
  puts name # выведет каждый элемент массива
end
print nameS # выведет без добавленных знаков ! тк сам массив не был изменен циклом а только использован


# Пример цикла for изменяющего массив(примерно как map)
for i in 0..nameS.length()-1
  nameS[i] += "!" # Теперь к значению под индексом заданным переменной i добавится '!'
end
print nameS #=> ["Bob!", "Kevin!", "Alex!", "George!"]


for i in (1..7).reverse_each do
  # ...
end










#
