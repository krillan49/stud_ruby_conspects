puts '                                       Exceptions / Исключения'

# (НЕПОНЯТНЫЙ МОМЕНТ 1)  Catch и Throw(?)
# (НЕПОНЯТНЫЙ МОМЕНТ 2)  Кастомные классы исключений(?)
# (?? Сообщение об ошибке может быть перехвачено с помощью $! переменная. ??)
# (retry  - последдний пример)
# (raise  - как работает кондишон)

# Используем саму отловленную ошибку чтобы выдать с ней конкретное сообщение
begin
  # ...
rescue Errno::ENOENT
  raise Errno::ENOENT, "File #{file} does not exist..."
else
  # ...
end


begin
  10/0
rescue ZeroDivisionError => e
  raise # автоматически вызывает ту же ошибку которую спасало
end



# Все виды ошибок можно поделить на:
# 1. Ошибки программиста:
# а) код написан не соответсвующий синтаксису языка
# б) баги - это ошибки которые сразу не видны и проявляются при использовании программы
# 2. Исключения - внешние ошибки, не зависящие от программиста: нет интернета, а программа с ним взаимодействует; нет удаленного фаила, проблемы с ОС

# Если внутренние ошибки программитс может найти и испрааить, то со внешними, он часто поделать ничего не может. Эти внешние ошибки / исключения мы и будем обработывать

# Все вне нашей программы, что этой программой используется, может подкинуть исключения и к этому нужно быть готовым
# Если потерянные в результате обработки исключения критичны, тогда не нужно ее обрабатвать (либо обработать другой ошибкой) и лучше завершить работу программы, а если не критичны, то мб лучше обработать и предупредить пользователя сообщением.


# Если интерпритатор Руби сталкивается с ошибкой, то он вызывает exception/исключение. Выполнение программы прерывается/завершается, если возникает исключение

10 / 0
#=>
# E:/doc/ruby_exemples/test.rb:1:in `/': divided by 0 (ZeroDivisionError)
# 	from E:/doc/ruby_exemples/test.rb:1:in `<main>'

# Исключения используются для отслеживания и обработки различных типов ошибок, которые могут возникнуть во время выполнения программы, дают возможность определить ошибку и предпринять какие-то действия вместо полной остановки программы.



puts '                                        Схема обработки исключений'

# Обрабатываются исключения с использованием блоков begin(для проверяемого кода) и rescue(для обработки исключений). Опционально можно указать тип обрабатываемого исключения(по умолчанию обрабатываются все) и запросить получение информации о нем. Также можно добавлять блоки else (выполняется, если исключения отсутствовали) и ensure (выполняется в любом случае).

begin
  # какой-то код в котором подозреваем возможность появления исключений, эот код нормально сработает если исклчений не было
rescue SomeError # обрабатываем конкретный тип исключений
  # какойто код если данное исключение было вызвано
rescue SomeElseError # можно обрабатывать сколько угодно конкретных исключений. Этот блок сработает только если предыдущий не нашел соответсвующего исключения
  # какойто код если данное исключение было вызвано
rescue RuntimeError => e # передает объект исключения в переменную, которую можем использовать в соотв блоке
  puts e
rescue => e # (=> e - не обязательно/опционально). Обрабатывает все остальные классы исключений не указанные выше
  # какойто код
else # сработает после begin, если исключений не было и соответсвенно блоки rescue не исполнялись
  # какойто дополнительный код
ensure # сработает в любом случае были или нет пойманы и обработанны исключения
  # какойто дополнительный код
end



puts '                                           begin, rescue'

begin # begin - блок с исходным кодом, который хотим проверить на ошибки
  10 / 0 # Ошибка ZeroDivisionError тк на 0 делить нельзя.
  p 'какой-то код' # Изза ошибки весь код что за ней не будет выполняться
rescue # rescue - если ловит ошибку, то выпоняет свой блок с кодом для ее обработки
  p 'ошибка в расчетах'
end # После end дальнейший код работает нормально
p 'дальнейший код выполняется нормально'
#=> "ошибка в расчетах"
#=> "дальнейший код выполняется нормально"


# Если в блоке begin нет ошибок то просто исполняется код блока begin
def some(a, b)
  begin
    a / b
  rescue
    "some exeption"
  end
end
p some(6, 2)   #=> 3
p some(6, 0)   #=> "some exeption"


# Можно отловить ошибку от оператора метода, а не в его теле, удобно если это сторонная библиотека и мы не имеем доступа к исходному коду. А можно ловить сперва в теле, а потом в операторе
def div(a, b)
  a / b
end
begin
  div(100, 0)
rescue
  p "Какая-то ошибка"
end
#=> "Какая-то ошибка"


# несколько ошибок
begin
  10 / 0
  [9, 67, "sisya"]["dog"]   # Ошибка(TypeError) - обращение к массиву как к хэшу
rescue # ловит 1ю ошибку, обрабатывает ее игнорирует следующие ошибки
  p "Какая-то ошибка"
end
p 'дальнейший код выполняется нормально'
#=> "Какая-то ошибка"
#=> "дальнейший код выполняется нормально"


# можно присвоить в переменную возврат итогового блока
exept = begin
  10 / 0
rescue
  'cant div by zero'
end
p exept #=> "cant div by zero"



puts '                                            Классы исключений'

# Все классы исключений образуют иерархию с классом Exception наверху. Следующий уровень содержит 7 различных классов: Interrupt,  NoMemoryError,  SignalException,  ScriptError,  StandardError,  SystemExit.
# ScriptError, и StandardError так же имеют ряд подклассов.
# На этом уровне есть еще одно исключение, Fatal, но интерпретатор Ruby использует его только внутри себя.

# Стоит ловить и обрабатывать исключения по их конкретным классам, чтобы не отловить случайно непонятную ошибку и изза этого потом получить гору багов

# Обработка только ошибки конкретного класса
def some(par)
  begin
    10 / par
  rescue ZeroDivisionError # будет обрабатывать только ошибки относящиеся к этому классу исключений(деление на 0), а другие нет
    p "нельзя делить на 0"
  end
end
some(0)   #=> "нельзя делить на 0"
some('A') #=> String can't be coerced into Integer (TypeError)  # тоесть исключение не обработалась и соотв было вызвано


# Обработка остальных типов ошибок если это ошибка не принадлежит обрабатываемому классу
def some(par)
  begin
    10 / par
  rescue ZeroDivisionError # будет обрабатывать только исключения относящиеся к классу ZeroDivisionError, а другие нет
    p "нельзя делить на 0"
  rescue                   # обработает исключения всех остальных классов
    p "some exeption"
  end
end
some(0)   #=> "нельзя делить на 0"
some('A') #=> "some exeption"



puts '                               Экземпляр класса исключения и его методы'

# Через синтаксис 'Const => var' можно получить экземпляр класса исключения и вызывать от него различные свойства

# Экземпляры ошибок могут содержать разные свойства, например часть содержания HHTP ответа сервера с кодом ошибки, если мы, например не смогли получить какую-то страницу

def some(par)
  begin
    10 / par
  rescue ZeroDivisionError => var # Присваиваем экземпляр класса ZeroDivisionError в переменную, имя переменной можно задать любое
    p var
  rescue => other
    p other
  end
end
some(0)   #=> #<ZeroDivisionError: divided by 0>
some('A') #=> #<TypeError: String can't be coerced into Integer>


# Методы экземпляра исключения
begin
  10 / 0
rescue ZeroDivisionError => e
  e
end
p e           #=> #<ZeroDivisionError: divided by 0>
p e.class     #=> ZeroDivisionError
p e.message   #=> "divided by 0"
p e.backtrace #=> ["E:/doc/ruby_exemples/test.rb:2:in `/'", "E:/doc/ruby_exemples/test.rb:2:in `<main>'"]



puts '                                  Очередность обработки нескольких исключений'

# При возникновении исключения в определенной строке, оно пойдет на проверку по всем rescue пока не будет обработано либо вызвано, после того как ошибка будет обработана, дальнейший код из блока begin исполняться не будет и программа пойдет дальше после end

begin
  num = 10 / 0                # если исключение сработает тут ...
  [9, 67, "sisya"]["dog"]     # ... этот код исполняться уже не будет
  not_initialized_var
rescue NameError => e         # в первой строке, где вызвано исключение, оно не этого класса, соответсвенно оно не поймано тут и переходит к следующему rescue
  p e
rescue ZeroDivisionError => e # обрабатывает ошибку в 1й строке и вызывает код из блока и затем переходит к end
  p e                         # вернет только это, тк обрабатывет по первому исключению из begin ...
rescue
  p "Еще какаято ошибка"      # ... этот код исполнен уже не будет.
end
#=> #<ZeroDivisionError: divided by 0>



puts '                                        retry (возврат к блоку begin)'

# Можно обработать исключение, используя блок rescue, а затем использовать оператор метода повторной попытки retry, чтобы выполнить блок begin еще раз с самого начала.

file_name = "/unexistant_file"
begin
  file = File.open(fname) # Если такой фаил не существует - исключение будет перехвачено в блок rescue
  p file.read
  file.close
rescue # будет фиксировать все типы повторных попыток исключения, если имя фаила все еще не существует
  file_name = "ruby_exemples/text/simple.txt" # исправим путь к фаилу на существующий
  retry # переместит элемент управления в начало begin
  # Если файл с повторно замененным именем не существует, этот код будет повторяется бесконечно, как бесконечный цикл
end
#=> Какое-то содержание фаила


# Счетчик для retry, чтобы избежать бесконечного цикла
def some_request
  retries = 0 # будем учитывать число срабатываний retry
  begin
    unknown # неизвестный метод или переменная
  rescue => e
    puts "Произошла ошибка #{e.class.name}: #{e.message}"
    if retries < 2 # тоесть вызываем новый retry только если он уже был запущен менее 2х раз
      retries += 1
      sleep 2**retries # можно сделать паузу до следующей попытки(удобно для веба, если на API есть ограничение на число вызовов в секунду), которая постоянно растет по экспоненте(экспонентциальный откат - удобно чтобы избежать ошибки от сервера "Слишком много запросов")
      retry # выполнить блок begin ещё раз
    else
      raise e.class, "попробовали 3 раза вызвать этот код, но не вышло..." # как вариант породить свое исключение
    end
  end
end
some_request() #=>
# Произошла ошибка класса NameError: undefined local variable or method `unknown' for main:Object
# Произошла ошибка класса NameError: undefined local variable or method `unknown' for main:Object
# Произошла ошибка класса NameError: undefined local variable or method `unknown' for main:Object
# test.rb:13:in `rescue in div': попробовали 3 раза вызвать этот код, но не вышло... (NameError)
#         from test.rb:4:in `div'
#         from test.rb:17:in `<main>'
# test.rb:5:in `div': undefined local variable or method `unknown' for main:Object (NameError)
#         from test.rb:17:in `<main>'


# (??  почемуто так не обрабатывает все ошибки и получается бесконечный цикл. Не запоминает код из блоков обработки предыдущих ошибок ??)
n, m = 0, 'A'
begin
  a = 10 / n
  b = 2 + m
rescue NameError => e
  p e
  n = 2
  retry
rescue ZeroDivisionError => e
  p e
  m = 3
  retry
end



puts '                                          raise - оператор повышения'

# raise или fail - оператор вызова/создания/формирования собственного исключения, опционально могут быть добавлены текст с сообщением, константа класса исключения и информация о стеке вызовов

# без аргументов повторно вызывает текущее исключение(или RuntimeError, если текущего исключения нет)
raise() #=> unhandled exception

# С аргументом строкой - создает новое исключение RuntimeError, устанавливая аргумент в свойство сообщения. Затем это исключение поднимается вверх по стеку вызовов.
raise "Error Message" #=> Error Message (RuntimeError)
fail "Error Message"  #=> Error Message (RuntimeError)  # алиас

# С аргументом константой - использует аргумент для создания исключения этого класса, этот класс исключения должен уже быть определен иначе будет вызвано: uninitialized constant ExceptionType (NameError)
raise ExceptionType      #=> uninitialized constant ExceptionType (NameError)
raise ZeroDivisionError  #=> RuntimeError (ZeroDivisionError)

# C 2-мя аргументами - использует первый аргумент для создания исключения этого класса, а затем устанавливает сообщение со вторым аргументом.
raise ZeroDivisionError, "My Error Message" #=> My Error Message (ZeroDivisionError)

# (?? хз как это работает ??)
raise ExceptionType, "Error Message" condition # (...OR) похожа на предыдущее, но вы можете добавить любой условный оператор, например, если не вызывает исключение.


# В том числе можно использовать при обработке исключений
begin
  p 'I am before the raise.'
  raise 'An error has occurred.' # например чтобы вызывать исключение для обработки
  p 'I am after the raise.'
rescue
  p 'I am rescued.'
  raise 'output exeption' # Либо, если нужно можно вернуть другое исключение в блоке обработки
end
#=> "I am before the raise."
#=> "I am rescued"
#=> E:/doc/ruby_exemples/test.rb:8:in `rescue in <main>': output exeption (RuntimeError)



puts '                                         else(не найдено исключение)'

# else - выполняется только в том случае, если в begin не обнаружено никаких исключений, идет после предложений rescue и перед ensure. Код в блоке else выполняется после выполнения всего кода из блока begin
def some(n)
  begin
    res = 10 / n
  rescue => e
    e.message
  else # выполняется сразу за begin, если там не поймано исключение.
    "Congratulations no errors, result is #{res}"  # используем переменную из begin
  end
end
p some(2) #=> "Congratulations no errors, result is 5"
p some(0) #=> "divided by 0"



puts '                                        ensure(гарантии/обеспечения)'

# Иногда нужно гарантировать, что некоторая обработка выполняется в конце блока кода, независимо от того, было ли возбуждено исключение или нет. Например, у вас может быть файл, открытый при входе в блок, и нужно его закрыть при выходе из блока.

# ensure - (гарантия) идет после последнего rescue и после else и содержит кусок кода, который всегда будет выполняться, когда блок завершается. Неважно, завершается ли блок нормально, если он вызывает и спасает исключение или завершается из-за неперехваченного исключения, блок ensure будет запущен.
def some(n)
  begin
    res = 6 / n
  rescue ZeroDivisionError => e
    p e.message
  else
    p res
  ensure
    p "Ensuring execution" #.. Это всегда будет выполняться.
  end
end
some(0)   #=> "divided by 0"           #=> "Ensuring execution"
some(2)   #=> 3                        #=> "Ensuring execution"
some('A') #=> "Ensuring execution"     #=> String can't be coerced into Integer (TypeError)



puts '                                            rescue в одну строку'

# Можно спасать тсключение в 1 строку, записывая rescue после проверяемого кода. Можно использовать строковое описание(по желанию), но синтаксис с '=> e' так похоже не работает
p (50 + 'A' rescue 'Error')              #=> "Error"

# Можно спасать несколько исключений в одной строке
p (10 / 0 rescue 10) + (5 / 0 rescue 5)  #=> 15


# Для исключения не переданного блока(вместо метода проверки передачи блока)
def compute
  yield rescue "Do not compute"
end
p compute #=> "Do not compute"



puts '                                        Кастомные классы исключений(?)'

# Помимо встроенных классов исключений можно создавать и использовать свои собственные классы исключений, для обработки случаев, которые мы сами решим считать ошибками

# Если мы создадим свои классы исключений, они должны быть подклассами либо класса Exception, либо одного из его потомков

class Error < StandardError # Создаем наш кастомный класс исключений, который наследует у StandardError
  # Создаем вложенные классы исключений наследующие у внешнего класса Error
  ClientError = Class.new(self)
  ServerError = Class.new(self)

  # Создаем вложенные классы исключений наследующие уже у вложенного класса ClientError
  BadRequest = Class.new(ClientError)
  Unauthorized = Class.new(ClientError)
  NotAcceptable = Class.new(ClientError)
  NotFound = Class.new(ClientError)
  Conflict = Class.new(ClientError)
  TooManyRequests = Class.new(ClientError)
  Forbidden = Class.new(ClientError)
  Locked = Class.new(ClientError)
  MethodNotAllowed = Class.new(ClientError)

  # Создаем вложенные классы исключений наследующие уже у вложенного класса ServerError
  NotImplemented = Class.new(ServerError)
  BadGateway = Class.new(ServerError)
  ServiceUnavailable = Class.new(ServerError)
  GatewayTimeout = Class.new(ServerError)

  # Тоесть создали "дерево" наследования
  # StandardError
  # - Error
  # -- ClientError
  # --- BadRequest
  # --- ...
  # -- ServerError
  # --- NotImplemented
  # --- BadGateway
  # --- ...

  # Константа с хэшем констант наших исключений для их удобного вызова по коду ошибки
  ERRORS = {
    400 => Error::BadRequest,
    401 => Error::Unauthorized,
    403 => Error::Forbidden,
    404 => Error::NotFound,
    405 => Error::MethodNotAllowed,
    406 => Error::NotAcceptable,
    409 => Error::Conflict,
    423 => Error::Locked,
    429 => Error::TooManyRequests,
    500 => Error::ServerError,
    502 => Error::BadGateway,
    503 => Error::ServiceUnavailable,
    504 => Error::GatewayTimeout
  }.freeze

  # Этот метод находится в теле родительского класса Error, соответсвенно будет унаследован всеми выше созданными классами
  # Этот метод класса вызванный от константы будет порождать исключение данного класса с данным сообщением
  def self.from_response(message)
    new message.to_s # порождает исключение текущего класса, от константы которого вызван метод 'from_response', тк 'new' это метод класса, соотв у нас получается self.new или Error::BadRequest.new в который передаем дополнительно текстовое сообщение
  end
end

# Например сервер возвращает ответ из которого мы достаем код ошибки и сообщение про эту ошибку и передаем в данный метод
def error_from_server(code, message)
  # Создаем исключение в ручную от нашего базового класса Error, если сервер передал код, которого нет в хэше ERRORS
  raise(Error, message) unless Error::ERRORS.key?(code)

  # Создаем исключение по коду ошибки вызывающее из хэша например Error::BadRequest
  raise Error::ERRORS[code].from_response(message)
  # получится например Error::BadRequest.from_response(body), тоесть вызываем от константы метод соответсующего класса
end

p error_from_server(400, 'some text') #=>
# E:/doc/ruby_exemples/test.rb:63:in `error_from_server': some text (Error::BadRequest)
# 	from E:/doc/ruby_exemples/test.rb:67:in `<main>'



# (?? хз как работает ??)
# Создаем наш класс исключений
class FileSaveError < StandardError
  attr_reader :reason
  def initialize(reason)
    @reason = reason
  end
end
# Используем наш класс исключений:
File.open(path, "w") do |file|
  begin
    # Write out the data ...
  rescue
    raise FileSaveError.new($!) # Сообщение об ошибке может быть перехвачено с помощью $! переменная.
  end
end
# Важная строка здесь — raise FileSaveError.new($!) . Мы вызываем повышение, чтобы сигнализировать о том, что произошло исключение, передавая ему новый экземпляр FileSaveError, по причине того, что конкретное исключение вызвало сбой записи данных.



puts '                                         ?? Catch и Throw(неправильно) ??'

# Хотя механизм исключений raise и rescue отлично подходит для отказа от выполнения, когда что-то идет не так, иногда нужна возможность выпрыгнуть из какой-то глубоко вложенной конструкции во время обычной обработки. Вот где catch и throw пригодится.

# catch определяет блок, который помечен заданным именем (которое может быть Symbol или String). Блок выполняется нормально, пока не встретится throw.

# Синтаксис
throw :lablename # тут можно добавить условие например: if something
#.. это не будет выполнено
catch :lablename do
  #.. соответствующий catch будет выполнен после обнаружения throw.
end


# (!!! Неправильное описание, первым выполняется catch итд все по другому)В следующем примере используется catch для прекращения взаимодействия с пользователем, если '!' вводится в ответ на любое приглашение.
def promptAndGet(prompt)  # 2. Пошло исполнение
  print prompt
  res = gets.strip
  throw :quitRequested if res == "!"  # 3. Проверяем данные на условие, если соответствует прыгаем на 4а иначе идем на 4б
  return res   # 4б.
end

catch :quitRequested do  # 4а. Прыгаем сюда и заново вызываем метод(переходим к шагу 2)
  promptAndGet("Name: ")
end

name = promptAndGet("Name: ") # 1. Вызываем метод



















#
