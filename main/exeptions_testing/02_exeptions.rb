puts '                                  Отслеживание ошибок (Exceptions/Исключения)'

# (НЕПОНЯТНЫЙ МОМЕНТ 1)  Catch и Throw(?)
# (НЕПОНЯТНЫЙ МОМЕНТ 2)  Кастомные классы исключений(?)


# Если интерпритатор Руби сталкивается с ошибкой, то он вызывает exception/исключение. Выполнение программы прерывается/завершается, если возникает исключение

10 / 0
#=>
# E:/doc/ruby_exemples/test.rb:1:in `/': divided by 0 (ZeroDivisionError)
# 	from E:/doc/ruby_exemples/test.rb:1:in `<main>'

# Исключения используются для обработки различных типов ошибок, которые могут возникнуть во время выполнения программы, дают возможность определить ошибку и предпринять какие-то действия вместо полной остановки программы.


# Обрабатываются исключения с использованием блоков begin(для проверяемого кода) и rescue(для обработки исключений). Опционально можно указать тип обрабатываемого исключения(по умолчанию обрабатываются все) и запросить получение информации о нем. Также можно добавлять блоки else (выполняется, если исключения отсутствовали) и ensure (выполняется в любом случае).
begin # пробуем что-то сделать
  # какой-то код в котором подозреваем возможность появления исключений по какимто ошибкам
rescue SomeError # обрабатываем конкретный тип исключений
  # какойто код если данное исключение было вызвано
rescue SomeElseError # можно обрабатывать сколько угодно конкретных исключений. Этот блок сработает только если предыдущий не нашел соответсвующего исключения
  # какойто код если данное исключение было вызвано
rescue RuntimeError => e # передает более подробную инфу об исключекнии в переменную, которую можем использовать в соотв блоке
  puts e # напечатаем сообщение об ошибке
rescue => e # (=> e - не обязательно). Обрабатывает все остальные исключения не обработанные выше
  # какойто код
else # сработает после begin, если исключений не было
  # какойто код
ensure # сработает в любом случае были или нет обработанны исключения
  # какойто код
end


# одна ошибка
begin # блок в который помещаем код, что хотим проверить на ошибки
  10 / 0 # Ошибка(ZeroDivisionError) тк на 0 делить нельзя. Изза ошибки весь код что за ней не будет выполняться
  p 'какой-то код'
rescue
  p 'ошибка в расчетах'
end # После end дальнейший код работает нормально
p 'дальнейший код выполняется нормально'
#=> "ошибка в расчетах"
#=> "дальнейший код выполняется нормально"


# Если в блоке begin нет ошибок то просто исполняется код этого блока
def some(a, b)
  begin
    a / b
  rescue
    "some exeption"
  end
end
p some(6, 2)   #=> 3
p some(6, 0)   #=> "some exeption"


# несколько ошибок
list = [9, 67, "sisya"]
begin
  10 / 0
  list["dog"]   # Ошибка(TypeError) - обращение к массиву как к хэшу
rescue # так непонятно какая именно ошибка и где именно она
  p "Какая-то ошибка"
end
#=> "Какая-то ошибка"


# можно присвоить в переменную возврат итогового блока
exept = begin
  10 / 0
rescue
  'cant div by zero'
end
p exept #=> "cant div by zero"


# Можно отловить ошибку от оператора метода а в его теле, удобно если это сторонная библиотека и мы не имеем доступа к исходному коду. А можно ловить сперва в теле а потом в операторе
def div(a, b)
  a / b
end
begin
  div(100, 0)
rescue => e
  p e.class.name
end
#=> "ZeroDivisionError"


puts
puts '                             Классы исключений. Экземпляр исключения и его методы'

# Все классы исключений образуют иерархию с классом Exception наверху. Следующий уровень содержит семь различных типов: Interrupt,  NoMemoryError,  SignalException,  ScriptError,  StandardError,  SystemExit. ScriptError, и StandardError имеют ряд подклассов. На этом уровне есть еще одно исключение, Fatal, но интерпретатор Ruby использует его только внутри себя.

# Обработка только ошибки конкретного класса
def some(par)
  begin
    10 / par
  rescue ZeroDivisionError # будет обрабатывать только ошибки относящиеся к этому классу исключений(деление на 0), а другие нет
    p "нельзя делить на 0"
  end
end
some(0)   #=> "нельзя делить на 0"
some('A') #=> String can't be coerced into Integer (TypeError)  # тоесть исключение не обработалась и соотв было вызвано


# Обработка остальных типов ошибок если это ошибка не выбранного класса
def some(par)
  begin
    10 / par
  rescue ZeroDivisionError # будет обрабатывать только ошибки относящиеся к этому классу исключений(деление на 0), а другие нет
    p "нельзя делить на 0"
  rescue                   # обработает все остальные ошибки
    p "some exeption"
  end
end
some(0)   #=> "нельзя делить на 0"
some('A') #=> "some exeption"


# Через синтаксис 'Const => var' можно получить экземпляр класса исключения и вызывать от него различные свойства
def some(par)
  begin
    10 / par
  rescue ZeroDivisionError => var  # Присваивам экзнмпляр в переменную, имя переменной можно задать любое
    p var
    p var.class
  rescue => other
    p other
  end
end
some(0)   #=> #<ZeroDivisionError: divided by 0>
          #=> ZeroDivisionError
some('A') #=> #<TypeError: String can't be coerced into Integer>


# Методы экземпляра исключения
begin
  10 / 0
rescue ZeroDivisionError => e
  e
end
p e           #=> #<ZeroDivisionError: divided by 0>
p e.class     #=> ZeroDivisionError
p e.message   #=> "divided by 0"
p e.backtrace #=> ["E:/doc/ruby_exemples/test.rb:2:in `/'", "E:/doc/ruby_exemples/test.rb:2:in `<main>'"]


puts
puts '                                  Очередность обработки нескольких исключений'

# При возникновении исключения в определенной строке, оно пройдет на проверку по всем rescue пока не будет обработано, после того как ошибка будет обработана, дальнейший код из блока begin исполняться не будет и программа пойдет дальше после end

begin
  num = 10 / 0                # если исключение сработает тут ...
  list["dog"]                 # ... этот код исполняться уже не будет
  not_initialized_var
rescue NameError => e         # в первой строке, где вызвано исключение, оно не этого класса, соотв не поймано тут и переходит к следующему rescue
  p e
rescue ZeroDivisionError => e # обрабатывает эту ошибку в 1й строке и вызывает код из блока и затем переходит к end
  p e                         # вернет только это, тк обрабатывет по первому исключению из begin ...
rescue
  p "Еще какаято ошибка"      # ... этот код исполнен уже не будет.
end
#=> #<ZeroDivisionError: divided by 0>


puts
puts '                                        retry (возврат к блоку begin)'

# Можно обработать исключение, используя блок rescue, а затем использовать оператор метода повторной попытки retry, чтобы выполнить блок begin еще раз с самого начала.

file_name = "/unexistant_file"
begin
  file = File.open(fname) # Если такой фаил не существует - исключение будет перехвачено в блок rescue
  p file.read
  file.close
rescue # будет фиксировать все типы повторных попыток исключения, если имя фаила все еще не существует
  file_name = "ruby_exemples/text/simple.txt" # исправим путь к фаилу на существующий
  retry # переместит элемент управления в начало begin
end
#=> "Какое-то содержание фаила"


# Если файл с повторно замененным именем не существует, этот код будет повторяется бесконечно, как бесконечный цикл
# Счетчик для retry, чтобы избежать бесконечного цикла
def div(a, b)
  retries = 0 # будем учитывать число срабатываний retry
  begin
    unknown # неизвестный метод или переменная
  rescue => e
    puts "Произошла ошибка класса #{e.class.name}: #{e.message}"
    if retries < 2 # тоесть вызываем новый retry только если он уже был запущен менее 2х раз
      retries += 1
      sleep 2**retries # можно сделать паузу до след попытки(удобно для веба, если на API есть ограничение на число вызовов в секунду), которая постоянно растет по экспоненте(экспонентциальный откат) (удобно чтобы избежать ошибки от сервера "Слишком много запросов")
      retry # выполнить блок begin ещё раз
    else
      raise e.class, "попробовали 3 раза вызвать этот код, но не вышло..." # породить исключение
    end
  end
end
div(1, 2) #=>
# Произошла ошибка класса NameError: undefined local variable or method `unknown' for main:Object
# Произошла ошибка класса NameError: undefined local variable or method `unknown' for main:Object
# Произошла ошибка класса NameError: undefined local variable or method `unknown' for main:Object
# test.rb:13:in `rescue in div': попробовали 3 раза вызвать этот код, но не вышло... (NameError)
#         from test.rb:4:in `div'
#         from test.rb:17:in `<main>'
# test.rb:5:in `div': undefined local variable or method `unknown' for main:Object (NameError)
#         from test.rb:17:in `<main>'


# (??  почемуто так не обрабатывает все ошибки и получается бесконечный цикл. Не запоминает обработку предыдущих ошибок ??)
a, b = nil, nil
begin
  a = 10 / 0
  b = 2 + 'A'
rescue NameError => e
  p e
  n = 2
  retry
rescue ZeroDivisionError => e #
  p e
  m = 3
  retry
end
p [a, b]


# (?? Сообщение об ошибке может быть перехвачено с помощью $! переменная. ??)


puts
puts '                                          raise - оператор повышения'

# raise/fail - оператор вызова(создания/формирования) собственного исключения, опционально могут быть добавлены текст с сообщением, тип исключения и информация о стеке вызовов

# без аргументов повторно вызывает текущее исключение(или RuntimeError, если текущего исключения нет). Используется в обработчиках исключений, которым необходимо перехватить исключение перед его передачей.
raise #=> unhandled exception

# С аргументом строкоцй - создает новое исключение RuntimeError, устанавливая аргумент в сообщение при вызове исключения. Затем это исключение поднимается вверх по стеку вызовов.
raise "Error Message" #=> Error Message (RuntimeError)
fail "Error Message"  #=> Error Message (RuntimeError)  # алиас

# С аргументом константой - использует аргумент для создания исключения, этот класс исключения должен уже быть определен иначе будет вызвано: uninitialized constant ExceptionType (NameError)
raise ExceptionType      #=> uninitialized constant ExceptionType (NameError)
raise ZeroDivisionError  #=> RuntimeError (ZeroDivisionError)

# C 2-мя аргументами - использует первый аргумент для создания исключения(этот тип исключения должен уже быть определен), а затем устанавливает сообщение со вторым аргументом.
raise ZeroDivisionError, "My Error Message" #=> My Error Message (ZeroDivisionError)

# (?? хз как это работает ??)
raise ExceptionType, "Error Message" condition # (...OR) похожа на предыдущее, но вы можете добавить любой условный оператор, например, если не вызывает исключение.


begin
  p 'I am before the raise.'
  raise 'An error has occurred.' # вызываем исключение
  p 'I am after the raise.'
rescue
  p 'I am rescued.'
end
#=> "I am before the raise."
#=> "I am rescued"


puts
puts '                                         else(не найдено исключение)'

# else - выполняется только в том случае, если основная часть кода не вызывает никаких исключений, идет после предложений rescue и перед ensure. Выполняется после выполнения основной части кода из блока begin
def some(n)
  begin
    res = 10 / n
  rescue => e
    e.message
  else # выполняется сразу за begin, если там не поймано исключение.
    "Congratulations no errors, result is #{res}"  # используем переменную из begin
  end
end
p some(2) #=> "Congratulations no errors, result is 5"
p some(0) #=> "divided by 0"


puts
puts '                                        ensure(гарантии/обеспечения)'

# Иногда нужно гарантировать, что некоторая обработка выполняется в конце блока кода, независимо от того, было ли возбуждено исключение или нет. Например, у вас может быть файл, открытый при входе в блок, и нужно его закрыть при выходе из блока.

# ensure - (гарантия) идет после последнего rescue и после else и содержит кусок кода, который всегда будет выполняться, когда блок завершается. Неважно, завершается ли блок нормально, если он вызывает и спасает исключение или завершается из-за неперехваченного исключения, блок ensure будет запущен.
begin
  raise 'A test exception'
rescue => e
  p e.message
ensure
  p "Ensuring execution" #.. Это всегда будет выполняться.
else
  p "Else"
end
#=> "A test exception"
#=> "Ensuring execution"


puts
puts '                                            rescue в одну строку'

# Можно спасать тсключение в 1 строку записывая rescue после проверяемого кода. Можно использовать строковое описание(по желанию), но синтаксис с '=> e' так похоже не работает
p (50 + 'A' rescue 'Error')             #=> "Error"
p (10 / 0 rescue 10) + (5 / 0 rescue 0) #=> 10       # второе на этой же строке уже не работает


# Для исключения не переданного блока(вместо проверки передачи блока)
def compute
  yield rescue "Do not compute"
end
p compute #=> "Do not compute"


puts
puts '                                        Кастомные классы исключений(?)'

# Если мы создадим свои классы исключений, они должны быть подклассами либо класса Exception, либо одного из его потомков

# Создаем наш класс исключений
class FileSaveError < StandardError
  attr_reader :reason
  def initialize(reason)
    @reason = reason
  end
end
# Используем наш класс исключений:
File.open(path, "w") do |file|
  begin
    # Write out the data ...
  rescue
    raise FileSaveError.new($!) # Сообщение об ошибке может быть перехвачено с помощью $! переменная.
  end
end
# Важная строка здесь — raise FileSaveError.new($!) . Мы вызываем повышение, чтобы сигнализировать о том, что произошло исключение, передавая ему новый экземпляр FileSaveError, по причине того, что конкретное исключение вызвало сбой записи данных.


puts
puts '                                         ?? Catch и Throw(неправильно) ??'

# Хотя механизм исключений raise и rescue отлично подходит для отказа от выполнения, когда что-то идет не так, иногда нужна возможность выпрыгнуть из какой-то глубоко вложенной конструкции во время обычной обработки. Вот где catch и throw пригодится.

# catch определяет блок, который помечен заданным именем (которое может быть Symbol или String). Блок выполняется нормально, пока не встретится throw.

# Синтаксис
throw :lablename # тут можно добавить условие например: if something
#.. это не будет выполнено
catch :lablename do
  #.. соответствующий catch будет выполнен после обнаружения throw.
end


# (!!! Неправильное описание, первым выполняется catch итд все по другому)В следующем примере используется catch для прекращения взаимодействия с пользователем, если '!' вводится в ответ на любое приглашение.
def promptAndGet(prompt)  # 2. Пошло исполнение
  print prompt
  res = gets.strip
  throw :quitRequested if res == "!"  # 3. Проверяем данные на условие, если соответствует прыгаем на 4а иначе идем на 4б
  return res   # 4б.
end

catch :quitRequested do  # 4а. Прыгаем сюда и заново вызываем метод(переходим к шагу 2)
  promptAndGet("Name: ")
end

name = promptAndGet("Name: ") # 1. Вызываем метод



















#
