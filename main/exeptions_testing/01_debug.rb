puts '                                     Отладка программ(debugging)'

# Существует несколько способов отладки программы, написанной на языке Руби:
# С использованием вывода в консоль (puts, print)
# С использованием консольного отладчика
# С использованием отладчика, встроенного в текстовый редактор или среду разработки (IDE)

# Дебажить стоит если:
# Нужно найти какую-то ошибку, которая не вызывает исключений
# Когда непонятна логика работы программы и нужно потыкать, например чужой код



puts '                                Отладка с использованием вывода в консоль'

# Это один из самых эффективных способов отладки программы

# inspect - метод (реализован в объекте любого типа), который возвращает строковое представление объекта. Например puts nil и puts "" выведут на экран пустую строку, а с .inspect на экран будет выведено nil и "" соответственно
puts nil         #=> пустая строка
puts ""          #=> пустая строка
puts nil.inspect #=> nil
puts "".inspect  #=> ""

# p - метод который вызывает "puts obj.inspect"
p nil            #=> nil
p ""             #=> ""


# Если код выполняется в цикле, то иногда полезно комбинировать if и puts:
puts something.inspect if i == 100


# чтобы прервать выполнение программы на этом участке кода, можно воспользоваться ключевым словом raise, которое выбросит исключение (стандартную ошибку) и завершит работу (фреймворк Ruby on Rails завершит только текущий запрос [request]):
puts something.inspect
raise


# Для программ с отладочным выводом, наприер Ruby on Rails, полезна будет следующая конструкция:
something = '123'
puts 'Каша служебных сообщений'
puts '=' * 80
puts something.inspect
puts '=' * 80
puts 'Каша служебных сообщений'
# Вывод переменной в этом случае не затеряется среди «простыни» служебных сообщений


# Т.к. руби — язык с динамической типизацией, по исходному коду не всегда можно сказать где именно определен тот или иной метод, пока программа не запустится и не дойдет до определенной точки. В RubyMine существует комбинация клавиш Cmd + B (на macOS) или Ctrl + B (на ОС Windows и Linux), которая покажет где именно находится тот или иной метод. Однако и RubyMine не всегда способен определить точное месторасположение вызываемой функции. В этом случае поможет следующая конструкция:
puts method(:something).source_location
# Если в объекте определен метод something, то на экран будет выведен путь к файлу с номером строки.


# В случае если требуется узнать стек вызова (stack trace, последовательность вызова функций), можно вывести массив caller. Это зарезервированное слово, которое доступно в любом месте:
def random_pow
  pow(rand(1..10)) # передаеем в метод pow рандомное число
end
def pow(x)
  puts "=" * 80
  puts caller      # вызываем последовательность работы методов
  puts "=" * 80
  x ** 2
end
puts random_pow
#=> ================================================================================
#=> E:/doc/ruby_exemples/test2.rb:3:in `random_pow'
#=> E:/doc/ruby_exemples/test2.rb:12:in `<main>'
#=> ================================================================================
#=> 9
# Читать stack trace нужно в обратном порядке. Мы видим, что первый вызов функции random_pow произошел на 12-й строке, а второй вызов на 3-й. Таким образом, caller ничто иное как call stack (стек вызовов).



puts '                           Отладка с использованием консольного дебагера pry'

# pry может использоваться не только как REPL, но и как отладчик/дебагер. Например мрожно установить breakpoint(точку остановки) в определенном месте программы. И когда запущенная программа дойдет до этой точки, то будет остановлена и управление будет передано через pry пользователю(как при запуске pry в консоли) и он, с помощью специальных инструментов, сможет проанализировать программу именно в этой точке: посмотреть на переменные, переданные параметры, на стек вызова.

# Иногда программы в режиме дебага могут вести себя немного по другому чем обычно. Например при многопоточных программах, когда другой поток продорлжет выполняться, может измениться что-то на внешних ресурсах

require 'pry' # нужно подключить, тк запускаться pry будет не из непосредственно из командной строки

def random_pow
  pow(rand(1..10))
end
def pow(x)
  binding.pry # binding.pry - специальный синтаксис, указывает где будет остановка программы и должен быть вызван отладчик.
  x ^ 2
end
puts random_pow

# Тперь когда будет запущен фаил с этой программой, то в точке остановки запустится pry

# $ ruby app.rb
# From: /Users/ro/work/book/app.rb @ line 8 Object#pow:
#    7: def pow(x)
# => 8: binding.pry
#    9: x ^ 2
#   10: end

# => - показывает в какой точке находится интепритатор. Если ввести команду "whereami" — то покажет место текущего брейкпоинта.

# Теперь вывод в режиме pry и можно просто вводить код после pry(main)>:
# [3] pry(main)> x
# 2
# [4] pry(main)> x ^ 2
# 0

# В режиме отладки можно:
# Посмотреть или изменить значения переменных
# Вызвать какой-либо метод один или несколько раз
# Вставить код (например, скопированный из буфера обмена) и посмотреть как он работает
# Попытаться вычислить результат выполнения следующей строки (например, путем ее копирования или просто ввода с клавиатуры) и посмотреть что произойдет

# Команды pry в точке остановки:
exit     # выход из режима отладки Pry, программа продолжит интерпритироваться дальше
exit!    # прервет выполнение программы с выходом в терминал.
next     # выполнит следующую строку. После этого снова можно посмотреть, например значение переменных.
whereami # может быть полезна когда, например, после вывода большого текста на экран (или очистки экрана кодом из нашей программы) нужно знать в каком месте программы мы в данный момент находимся.

# Можно из режима отладки вызывать команды терминала при помощи метода Руби system, например
system('ls')    # можно получить список файлов в текущей директории
system('pwd')   # покажет путь к текущей директории процесса
system('reset') # выполняет команду оболочки reset команда используется для сброса настроек оболочки в настройки поумолчанию. В больших проектах существует множество gem’ов, которые могут выводить в консоль отладочную информацию, иногда эта информация сбивает настройки терминала и возникает необходимость вернуть эти настройки обратно без перезапуска отладчика. Сделать это можно с помощью system('reset') или просто взяв слово reset в обратные кавычки (backticks)
# [1] pry(main)> `reset`
# (произошла очистка экрана)
# ""
# [2] pry(main)> whereami



puts '                           Отладка с использованием консольного дебагера byebug'

# https://github.com/deivid-rodriguez/byebug

# byebug - гем консольный дебагер

# $ gem install byebug


# 1. Если нужно отладить скрипт Ruby, не редактируя его, можно вызвать byebug из командной строки.
# $ byebug myscript.rb

# 2. Из кода Ruby. Нужно Просто включить byebug туда, где нужно начать отладку, и выполнение остановится там:
require 'byebug'
def index
  byebug # метод для брйкпоинта остановит программу в этой точке
  @articles = Article.find_recent
end















#
