puts '                                      Тестирование. Автотесты'

# Автотест - это набор инструкций(код) который программа должна выполнить, например подключить, класс, вызвать метод, проверить результат

# Обычно unit и acceptance тесты используются вместе в проектах

# Юнит-тестирование(unit) - тестирование отдельных частей программы на возможные ошибки(проверка чтобы не сломалось)

# Приёмочное тестирование(Acceptance Testing)  - проверка функциональности на соответствие требованиям. Для этих тестов обычно существует план приёмочных работ(список требований и выполняются эти требования или нет).
# http://protesting.ru/testing/levels/acceptance.html

# Интеграционное тестирование - тестирование функциональности сайта со стороны браузера


# Разработка через тестирование (англ. test-driven development, TDD) — техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода к соответствующим стандартам.


# В Руби есть фрэймворки/библиотеки для тестирования такие как Rspec и Minitest



puts '                                          Юнит-тесты'

# Юнит-тесты предназначены для тестирования отдельных модулей программы - юнитов.
# юнит - каждая отдельная часть программы, которую уже нельзя/бессмысленно разбивать на более мелкие

# Не все ошибки можно определить автоматически, программа просто может работать, но не правильно, чтобы не бояться таких скрытых ошибок при изменении программы и нужны юнит-тесты.
# Юнит тестирование нужно, чтобы при возрастании сложности приложения функциональность большого приложения сохранялась

# code/test coverage - покрытие кода тестами(измеряется в процентах, есть автоматические утилиты которые это считают)
# Покрытие тестами увеличивает бюджет проекта

# Тк Руби язык динамический то мы не узнаем об ошибке в той части кода которую не запускаем, те части программы запускаются только если до их расположения в коде добирается программа, те баги могут жить непойманными месяцы и даже годы. Поэтому в Руби тесты особенно важны. В отличие от какого нить Си# языка со строгой типизацией, компилируемого - его программы перед запуском компидируются в исполняемый фаил (пр exe-фаил на винде) и если программа скомпилировалась то явных ошибок в ней нет, поэтому нужно меньше тестов(только критические учаски кода)

# Написание тестов в большом приложении - это вклад в будущее, защита приложения от ошибок.

# Тесты должны быть:
# 1. надёжные (reliable) - дают тот же результат во множестве попыток, без зависимостей от соединения (но в Рэилс не удастся избежать зависимости от БД).
# 2. easy to write - если тест пишется не легко, то нужно например разбить класс на несколько подклассов.
# 3. easy to understand - лёгкие для понимания другими программистами.
# 4. скорость работы тестов не особо важна, тк может противоречить надежности и читаемости
# 5. DRY(Don`t Repeat Yourself) тоже не особо важен

# Невозможно протестировать все возможные случаи, например результатов, возвращаемых методом. Нужно протестировать обычный случай, например те +- данные, что предполагаются в этом методе обычно, а потом протестировать пограничные случаи. Например при умножении 2х параметров, проверим сперва 2 и 3, потом -1 и 1, потом 0 и 0, потом 9999999 и 999999, потом 2 и 'A'
# Тестировщик заходит в бар, сперва заказывает 1 пиво, потом 0 пива, потом -1 пиво, потом 99999999 пива, потом крокодила

# В идеале юнит тесты должны быть изолированны и независимы друг от друга и можно было запустить их в любом порядке и ничего не сломалось. Зависимые тесты это не очень хорошо

# Сперва луше тестировать основные методы приложения, которые запускают зависимый функционал, те множество других методов, тк как косвенно будут проверены и все зависимые от этого функционала методы. А потом уже если нужно можно тестировать отдельные независимые методы, например на крайние случаи



puts '                                 Встроенный функционал юнит-тестов Ruby'

require "test/unit"

# Класс который нужно проверить
class Brokened
  def uh_oh
    "I needs fixing"
  end
end

# Класс теста для класса выше, этот класс и будет запускаться для проверки
class BrokenedTest < Test::Unit::TestCase
  def test_uh_oh # метод осуществляющий проверку(если будет несколько методов то они запустятся все)
    actual = Brokened.new # будем проверять метод экземпляра, потому создаем экземпляр
    assert_equal("I'm all better!", actual.uh_oh) # проверяем на соответсвие с эталонным значением
  end
end # Далее пример вывода(мне выдало более подробный)
#=> Started
#=> F
#=> Finished in 0.663831 seconds.
#=>
#=>   1) Failure:
#=> test_uh_oh:11
#=> <"I'm all better!"> expected but was
#=> <"I needs fixing">.
#=>
#=> 1 tests, 1 assertions, 1 failures, 0 errors   # тут assertions это вызовы - пр: assert_equal("I'm all better!", actual.uh_oh)













#
