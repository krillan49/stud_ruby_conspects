puts '                              Паттерн Singleton (один объект на всех)'

# Singleton - это паттерн в ООП

# Паттерн - шаблон(прием) проектирования

# Банда Четырёх - GoF (Gang of Four) - 4 программиста из США, описали паттерны для решения типичных задач в своей книге
# https://ru.wikipedia.org/wiki/Design_Patterns
# https://habr.com/ru/post/210288/     -   Шпаргалка по шаблонам проектирования

# В разработке программного обеспечения шаблон синглтон — это шаблон проектирования, который ограничивает создание экземпляра класса одним объектом. Это полезно, когда для координации действий в системе требуется ровно один объект.


# Hапишем логгер, который будет сначала выводить на экран, а затем сохранять в файл.
# Если будем создавать экземпляры класса, то объектов создаётся много(занимаем память итд), а действие совершается одно(выполнение метода), поэтому лучше использовать метод клесса

# app.rb:
class Logger
  # Добавим ещё метод для записи в фаил:
  def self.log_foo(bar)
    f = File.open 'log.txt', 'a'
    f.puts bar # puts - записывает с новой строки ??
    f.close
  end
end

Logger.log_foo 'Wow!' # чтото запишем
# Недостаток в том, что мы постоянно открываем и закрываем(.open .close) файл log.txt - это увеличивает нагрузку, тк если программа будет большая и фаил большой, а способ записи 'a' всегда переходит в конец фаила.


# Эту проблему решает паттерн Singleton - наша цель сделать один объект на всех.
class Logger
  def initialize
    @f = File.open 'log.txt', 'a' # тоесть фаил будет создаваться/открываться при создании экземпляра(new)
  end

  @@x = Logger.new # инициализируем экземпляр класса в теле класса (тк в методе класса не пропустит private_class_method) (при помощи переменной класса, тк она не меняется ??)

  def self.instance # название можно любое но в синглтон принято instance
    return @@x # чтобы метод возвращал экземпляр нашего класса(чтобы можно было от него вызвать метод экземпляра)
  end

  # instance method
  def log(bar) # теперь этот метод будет вызываться от объекта созданного выше
    @f.puts bar
    @f.flush # означает что все изменения будут сброшены на диск(втф?) можно не писать, тк само закроет при окончании программы, но можно написать отдельный метод для закрытия
  end

  # механизм защиты, метод .new можно было вызвать только внутри класса(соотв нельзя создать экземпляр вне класса)
  private_class_method :new
end

Logger.instance.log 'Kroker'


puts
# В стандартной библиотеке ruby есть модуль Singleton, который реализует паттерн синглтон
# https://ruby-doc.org/stdlib-2.5.3/libdoc/singleton/rdoc/Singleton.html

# Перепишем программу используя этот встроенный модуль(заодно разнесем по разным фаилам).

# logger.rb:
require 'singleton'

class Logger
  include Singleton # создание экземпляра и метод instance и запрет создания внешнего экземпляра

  def initialize
    @f = File.open 'log.txt', 'a'
  end

  def log(bar)
    @f.puts bar
    @f.flush
  end
end

# app.rb:
require "./logger"

Logger.instance.log "It`s work!"


















#
