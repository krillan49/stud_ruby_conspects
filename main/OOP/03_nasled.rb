puts '                                      Наследование(inheritance)'

# Наследование(inheritance) - позволяет создать класс наследник, что получит все методы, поля, переменные, константы и конструкторы материнского класса (суперкласса). При этом в каждом классе-наследнике можно добавить свои уникальные методы и свойства, не распространяющиеся на материнский класс или другие классы наследники, либо переопределить унаследованные

# Наследование может быть многоуровневым, когда класс наследник от одного класса является сам суперклассом для третьего.

class Transport # материнский класс
  attr_accessor :color, :wheels # геттеры и сетторы унаследуются

  def say_bip # метод унаследуется
    puts "BipBip"
  end
end

class Car < Transport # "<" обозначает, что класс слева (Car) наследует от класса справа (Transport)
  attr_accessor :is_mechanic # уникальное свойство подкласса, не затрагивающее материнский класс

  def kolesa # метод использующий свойство материнского класса (если предварительно задать значение от объекта этого наследника)
    @wheels + 2
  end
end

class Moto < Transport
  def say_bip # если в подклассе заново определить метод суперкласса, то он будет переопределн для этого подкласса
    "Тыц Тыц"
  end
end

# Объекты классов-наследников, обладают всеми свойствами и родительского класса и своими собственными

audi = Car.new
audi.color = "Black" # задаем объекту подкласса значение свойства унаследованного от материнского класса
audi.color           #=> "Black"
audi.wheels = 4
audi.kolesa          #=> 6    # (4 + 2)
audi.say_bip         #=> "BipBip"       # метод унаследованный из материнского класса Transport

mers = Moto.new
mers.say_bip         #=> "Тыц Тыц"      # унаследованный метод метод переопределен для подкласса

# superclass - метод принимает константу класса и возвращает константу его материнского класса
mers.class.superclass #=> Transport
mers.class #=> Moto



puts '                                  Наследование констант и переменных класса'

# Константы и переменные класса наследуются, но константы ведут себя не совсем интуитивно при наследовании:

class A
  A1 = 'A'
  A2 = 1

  @@some1 = 'some1'
  @@some2 = 'some2'

  attr_reader :a2

  def initialize
    @a2 = A2
  end

  def const_check
    A2
  end

  def const_check2
    A2
  end

  def some1
    @@some1
  end

  def some2
    @@some2
  end
end

class B < A
  A2 = 2

  @@some2 = 'no'

  def const_check2
    A2
  end
end

# Константы и переменные класса наследуются
p B::A1       #=> "A"
p B.new.some1 #=> "some1"

# Константы при наследовании можно переопределять в классе наследнике
p A::A2       #=> 1
p B::A2       #=> 2

# Переменные класса при наследовании можно переопределять в классе наследнике и при выводе через метод они будут браться из контекста класса наследника
p B.new.some2 #=> "no"

# !! Но унаследованные методы (в том числе и конструктор) берут константу из контекста материнского класса
p B.new.a2           #=> 1
p B.new.const_check  #=> 1
# Потому придется переопределить методы (или конструктор), чтобы использовать константу из контекста класса наследника
p B.new.const_check2 #=> 2



puts '                                    Наследование от встроенного класса'

# Класс наследующий у встроенного класса Hash, но с другим способом вызова значения(по части ключа, при одинаковых по алфавиту)
class Xuesh < Hash
  def [](key)
    self.clone.to_a.select{|k, v| k.start_with?(key)}.sort_by{|k, v| k}[0][1] rescue nil
  end
end

x = Xuesh.new
{"aaa" => 1,"abc" => 2,"dfg" => 3,"def" => 4,"dfgh" => 5}.each{ |k, v| x[k] = v } # заполняем хуеш
p x #=> {"aaa"=>1, "abc"=>2, "dfg"=>3, "def"=>4, "dfgh"=>5}
p [x['aa'], x['ab'], x['df'], x['de'], x['dfg'], x['dfgh'], x['b']] #=> [1, 2, 3, 4, 3, 5, nil]



puts '                                         Subtyping(субтипирование)'

# Субтипирование - это использование механизма наследования для того, чтобы выделить подтипы объектов. Классы наследники являются подтипами к суперклассу

# При использовании наследования важно избежать неверной абстракции, например не делать суперклассом тот класс, который впоследствии возможно придется менять так, что изменения пойдут вразрез с функциональностью классов наследников.

# Суперкласс лучше создать абстрактным, который будет содержать общие для всех подклассов функционал, но сам использоваться для создания объектов не будет

# Если нет уверенности в выбранной абстракции, стоит использовать модули, а иногда даже дублирование кода может быть предпочтительнее.

# Абстрактный класс Player содержит общую функциональность для всех подклассов, но при этом сам не используется
class Player
  attr_accessor :x

  def initialize(x)
    @x = x
  end

  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  # Абстрактный метод - тоесть пустой метод нужен, чтобы показать другим разработчикам, что он присудствует во всех подклассах с их функционалом, так же при обращении к одноименному методуот разных наследников (полиморфизм) предотвратит ошибку, если у какого-то наследника он не реальзован
  def label
  end
end

# Классы Robot и Dog будут являться подтипами класса Player
class Robot < Player
  # переопредляем/перегружаем метод
  def label
    '*'
  end
end

class Dog < Player
  # переназначаем метод, ограничивая направление движения объектов подкласса Dog
  def left
    right
  end

  def label
    '@'
  end
end



puts '                                                  super'

# super - ключевое слово используется чтобы вызывать одноименные методы и конструкторы суперкласса в методах и конструкторах подкласса, если нужно расширить или чапстично изменить наследуемое поведение этих родительских методов или конструкторов. По сути это просто в методе подкласса вызов одноименного метода суперкласса через его оператор, с возможностью передать ему параметры, если они предполагаются.
# `super` позволяет избежать дублирования кода, не вызывая явно методы суперкласса

class Character
  attr_accessor :strength, :constitution
  def initialize
    @strength, @constitution = 5, 5
  end
end

class Human < Character
  # Если ничего менять в наследуемом конструкторе не нужно, то можно обойтись и без конструктора подкласса будет использовать унаследованный конструктор от суперкласса
end

class Elf < Character
  # Можно переопределить конструктор подкласса полностью (если не использовать super)
  def initialize
    @strength = 3
  end
end

class Orc < Character
  attr_accessor :dexterity
  # Если нужно использовать функционал материнского класса, но изменить или допорлнить его используем super
  def initialize
    super # super инициализирует переменные экземпляра класса наследника при помощи конструктора материнского класса
    p [@strength, @constitution] #=> [5, 5]
    @strength = 7  # можно переназначить ту что нам надо для этого подкласса (по сути это тоже как передать в параметры в примере ниже)
    @dexterity = 3 # можно добавить новую переменную
  end
end

human = Human.new
p human.strength   #=> 5

elf = Elf.new
p elf.constitution #=> nil

ork = Orc.new
p ork.constitution #=> 5
p ork.dexterity    #=> 3



# super позволяет передать значения аргументов из метода или конструктора подкласса в метод или конструктор суперкласса, как буд-то это обычный оператор вызова метода, напрмимер для инициализации их в переменных
class Song
  def initialize(name, artist, duration) # аргументы из super будут передаваться в аргументы конструктора тут, в том же порядке, что передаются. Можно добавить значения по умлчанию, чтобы можно было из подкласса передавать не все
    @name, @artist, @duration = name, artist, duration
  end

  def to_info_S
    "Song: #{@name} - #{@artist} (#{@duration}sec)"
  end
end

class KaraokeSong < Song
  def initialize(name, artist, duration, lyrics)
    super(name, artist, duration) # вызываем конструктор суперкласса и передаем в него значения аргументов для того чтоб там инициализировать переменные экземпляра для данного подкласса
    @lyrics = lyrics # инициализируем независимую переменную этого подкласса
  end

  def to_info_KS # используем переменные подкласса инициализированные материнским классом
    "KS: #{@name} - #{@artist} (#{@duration}sec). Text: #{@lyrics}"
  end

  def to_info_S # метод подкласса с тем же названием что и метод суперкласса может использовать super для передачи к возвращаемого методом суперкласса значения
    "#{super}. Text: #{@lyrics}" # вызываем одноименный метод суперкласса и используем его возврат как значение
  end
end

class BrokenSong < Song
  def initialize(name, artist, duration)
    super(duration, name, artist) # тк передаются просто значения то в неправильном порядке передадутся не в те аргументы
  end
end

class HardcodeSong < Song
  def initialize(name, duration)
    super(name, 'Kroker', duration) # тк передаются просто значения то можно их хардкодить если надо
  end
end

ksong = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the...")
p ksong.to_info_S #=> "Song: My Way - Sinatra (225sec). Text: And now, the..."

bsong = BrokenSong.new("My Way", "Sinatra", 225)
p bsong.to_info_S #=> "Song: 225 - My Way (Sinatrasec)"

hsong = HardcodeSong.new("My Way", 225)
p hsong.to_info_S #=> "Song: My Way - Kroker (225sec)"
















#
