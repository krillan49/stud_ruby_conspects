puts '                             ООП. Class Methods или статические(static) методы'

# Методы класса(статические методы) могут иметь дело с управлением всеми существующими экземплярами класса и работают без привязки к какому-либо конкретному объекту, а методы экземпляра класса(instance methods) имеют дело с одним экземпляром за раз. Например, чтобы подсчитать количество объектов, принадлежащих классу, пригодится метод класса
# методы класса запускаются в контексте класса (и имеют доступ только к переменным класса), а методы экземпляра запускаются в контексте объекта (и имеют доступ к переменным объекта/экземпляра)
# доступ к методу класса осуществляется через класс, а к методу экземпляра — через экземпляр/объект класса
# Например метод new является методом класса и создает новый объект, но сам по себе не связан с конкретным объектом.

# Методы класса можно вызывать просто в теле класса или класса наследника, а не только в других методах класса

class Example
  # instance method(метод экземпляра):
  def inst_meth
  end

  # class/static methods:
  def Example.hi_meth # Синтаксис 1. Статический метод(метод класса) определяется префиксом с именем класса.
    puts 'hi'
  end

  def self.bay_meth # Синтаксис 2. Статический метод(метод класса) определяется ключевым словом(в виде префикса) self
    puts 'bay'
  end
end
# Используя статический метод мы можем пользоваться таким упрощенным синтаксисом вызова метода:
Example.hi_meth #=> "hi"
Example.bay_meth #=> "bay"

# ПРИМЕЧАНИЕ: делать классы только со статическими методами не рекомендуется — нужно использовать модули. Классы следует использовать только тогда, когда имеет смысл создавать из них экземпляры.
# Класс содержащий только статические переменные(@@) и статические методы называется статическим классом


puts
# Например когда программа небольшая и нужен только 1 объект писать object_name = Classname.new не очень удобно(излишне) лучше использовать упрощенный синтаксис статичкских методов.
# Используется часто для того, чтоб разбить программу на отдельные блоки, чтоб удобно было разным программистам работать над отдельными блоками. Пример программы(части какой-то игры) разбитой на отдельные блоки:
class RandomEngine
  def self.get_random_value
    rand(100..999)
  end
end
class GameEngine
  def self.play
    random_value = RandomEngine.get_random_value
    # ... какоето использование random_value ...
  end
end
GameEngine.play


puts
# Передача объекта в метод класса в виде параметра
# Пример: Отсев песен превышающих заданное максимальное время.
class Song
  attr_reader :duration
  def initialize duration
    @duration = duration
  end

  def Song.is_too_long?(song) # Метод получает параметром объект
    song.duration > 300
  end
end

song1 = Song.new(260)
p Song.is_too_long?(song1) #=> false
song2 = Song.new(468)
p Song.is_too_long?(song2) #=> true


puts
# Использование методов класса в качестве псевдоконструктора(создание объектов):
# Применяется когда объекты класса нужно будет задавать по параметрам отличным от изначальных
class Shape
  attr_accessor :num_sides, :perimeter

  def initialize(num_sides, perimeter)
    @num_sides, @perimeter = num_sides, perimeter
  end
  # Методы класса которые будут возвращать заданные объекты класса(создавать новые объекты вместо метода new - псевдоконструктор) запрашивая при этом параметры отличные от тех что запрашивает конструктор и задавая при помощи них(и/или отдельно) параметры для конструктора.
  def Shape.triangle(side_length)
    Shape.new(3, side_length * 3)
  end
  def Shape.square(side_length)
    Shape.new(4, side_length * 4)
  end
end
# Объект созданный через конструктор напрямую с обращением к конструктору(new)
figure = Shape.new(5, 50) # требует число сторон и периметр
# Объект созданный через метод класса являющийся псевдоконструктором(triangle)
figure2 = Shape.triangle(8) # требует длинну стороны
p figure2 #=> #<Shape:0x0000012fe78b8f40 @num_sides=3, @perimeter=24>
p figure2.num_sides #=> 3
p figure2.perimeter #=> 24


# В методе класса можно вызвать другой метод класса без префикса
class Code
  def self.some
    some2
  end

  private

  def self.some2
    p 'some2'
  end
end

Code.some #=> some2



puts '                         Переменные экземпляра и attr_reader с методами класса'

# (!! В self методе что @ значит?  - погуглить)
# То же что и в не self? Только инстанс "глобальный", не? Тоесть есть какой-то объект для каждого класса по умолчанию? Или это main?

# Ответ ??:
# У каждого класса есть инстанс. В контексте этого инстанса и выполняются self методы.

# в статических методах возможно юзать переменные экземпляра без привязки к объекту и attr-методы

# Но использовать инстанс переменные в случая когда можно передать в аргументы - зло. Получается неявная передача состояния через инстанс переменные. И надо трекать в голове, что между вызовами методов они апдейтят состояние, что не очевидно, если не читать ВЕСЬ код всех методов.

# class instance variables чтобы просто передать состояние в display result. display_result можно инлайнить и избавиться от переменных, либо использовать параметры функции чтобы передать состояние.
# Так метод становится Не только более чистый, но и его становится проще переиспользовать, ибо когда все неявное состояние вынесено в аргументы функций, эти функции становится можно использовать за пределами класса, так как он становится отвязан от этих функций

class Result
  attr_reader :success, :data, :error_message

  def self.create(success, data = nil, error_message = nil)
    @success = success
    @data = data
    @error_message = error_message

    display_result
  end

  def self.success(data)
    Result.create(true, data)
  end

  def self.failure(error_message)
    Result.create(false, nil, error_message)
  end

  private

  def self.display_result
    {
      success: @success,
      data: @data || @error_message
    }
  end
end

p Result.success('Vasya') #=> {:success=>true, :data=>"Vasya"}
p Result.failure('Pidor') #=> {:success=>false, :data=>"Pidor"}



puts '                                    Алиас для статического метода'

# В Ruby можно создать алиас для статического метода (метода класса) с помощью метода `alias_method`. Однако, так как `alias_method` работает только с методами экземпляра, для создания алиаса статического метода вам нужно использовать `singleton_class` объекта класса. Вот пример, как это можно сделать:
class MyClass
  def self.original_method
    puts "Это оригинальный метод."
  end
end

# Создание алиаса для статического метода
class MyClass
  singleton_class.send(:alias_method, :alias_method_name, :original_method)
end

# Вызов оригинального метода
MyClass.original_method # => Это оригинальный метод.

# Вызов метода через алиас
MyClass.alias_method_name # => Это оригинальный метод.

# В этом примере мы создали класс `MyClass`, определили в нём статический метод `original_method`, а затем создали для него алиас `alias_method_name`, используя `singleton_class.send(:alias_method, ...)`. Теперь оба метода, оригинальный и алиас, могут быть использованы для вызова одного и того же кода.

















#
