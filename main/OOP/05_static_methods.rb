puts '                             Class Methods или статические(static) методы'

# (?? и имеют доступ только к переменным класса)

# Методы класса / статические методы - работают без привязки к какому-либо конкретному объекту, запускаются в контексте класса, часто нужны для управлением всеми существующими экземплярами класса. Доступ к методу класса осуществляется через сам класс, а не через через экземпляр класса

# (?? В наследование добавить ??) Методы класса можно вызывать просто в теле класса или класса наследника, а не только в других методах класса

# Делать классы только со статическими методами не рекомендуется — нужно использовать модули. Классы следует использовать только тогда, когда имеет смысл создавать из них экземпляры.

# Класс содержащий только статические переменные(@@) и статические методы называется статическим классом



puts '                                              Синтаксис'

class Example
  # instance method(метод экземпляра):
  def inst_meth
  end

  # class/static methods:

  # Синтаксис 1. Статический метод(метод класса) определяется префиксом с именем класса
  def Example.hi_meth
    'hi'
  end

  # Синтаксис 2. Статический метод(метод класса) определяется ключевым словом(в виде префикса) self
  def self.bay_meth
    'bay'
  end

  def self.hi_and_bay
    # В методе класса можно вызвать другие методы класса без префикса, тк эта область видимости имеет контекст класса и соответсвенно self возвращает константу этого класса
    hi_meth + ' and ' + bay_meth
  end

  private # ?? приватность не работает для методов класса или работает с другим синтаксисом ??

  def Example.some
    'some'
  end
end

# Вызов статического метода от константы класса:
Example.hi_meth    #=> "hi"
Example.bay_meth   #=> "bay"
Example.hi_and_bay #=> "hi and bay"
Example.some       #=> "some"


puts '                                        Варианты использования'

# Например метод new является методом класса и создает новый объект, но сам по себе не связан с конкретным объектом.

# Например, чтобы подсчитать количество объектов, принадлежащих классу или среди экземпляров выбрать те что пододят пол неким параметрам
class Person
  # ... Какаято реализация ...
end

# Вернем всех людей
Person.all    #=> "hi"

# Вернем всех людей что живут в москве
Person.all('moscow')   #=> "bay"

# Вернем самого высокого среди всех людей
Person.highest


# Используется часто для того, чтоб разбить программу на отдельные блоки, чтоб удобно было разным программистам работать над отдельными блоками. Пример программы(части какой-то игры) разбитой на отдельные блоки:
class RandomEngine
  def self.get_random_value
    rand(100..999)
  end
end
class GameEngine
  def self.play
    random_value = RandomEngine.get_random_value
    # ... какоето использование random_value ...
  end
end
GameEngine.play


# Передача объекта в метод класса в виде параметра
# Пример: Отсев песен превышающих заданное максимальное время.
class Song
  attr_reader :duration
  def initialize duration
    @duration = duration
  end

  def Song.is_too_long?(song) # Метод получает параметром объект
    song.duration > 300
  end
end

song1 = Song.new(260)
p Song.is_too_long?(song1) #=> false
song2 = Song.new(468)
p Song.is_too_long?(song2) #=> true


# Использование методов класса в качестве псевдоконструктора(создание объектов):
# Применяется когда объекты класса нужно будет задавать по параметрам отличным от изначальных
class Shape
  attr_accessor :num_sides, :perimeter

  def initialize(num_sides, perimeter)
    @num_sides, @perimeter = num_sides, perimeter
  end
  # Методы класса которые будут возвращать заданные объекты класса(создавать новые объекты вместо метода new - псевдоконструктор) запрашивая при этом параметры отличные от тех, что запрашивает конструктор и задавая при помощи них(и/или отдельно) параметры для конструктора.
  def Shape.triangle(side_length)
    Shape.new(3, side_length * 3)
  end
  def Shape.square(side_length)
    Shape.new(4, side_length * 4)
  end
end
# Объект созданный через конструктор напрямую с обращением к конструктору(new)
figure = Shape.new(5, 50) # требует число сторон и периметр
# Объект созданный через метод класса являющийся псевдоконструктором(triangle)
figure2 = Shape.triangle(8) # требует длинну стороны
p figure2 #=> #<Shape:0x0000012fe78b8f40 @num_sides=3, @perimeter=24>
p figure2.num_sides #=> 3
p figure2.perimeter #=> 24



puts '                         Переменные экземпляра и attr_reader с методами класса'

# (!! В self методе что @ значит?  - погуглить) То же что и в не self? Только инстанс "глобальный", не? Тоесть есть какой-то объект для каждого класса по умолчанию? Или это main?

# Ответ ??:
# У каждого класса есть инстанс. В контексте этого инстанса и выполняются self методы.

# в статических методах возможно юзать переменные экземпляра без привязки к объекту и attr-методы

# Но использовать инстанс переменные в случая когда можно передать в аргументы - зло. Получается неявная передача состояния через инстанс переменные. И надо трекать в голове, что между вызовами методов они апдейтят состояние, что не очевидно, если не читать ВЕСЬ код всех методов.

# class instance variables чтобы просто передать состояние в display result. display_result можно инлайнить и избавиться от переменных, либо использовать параметры функции чтобы передать состояние.
# Так метод становится Не только более чистый, но и его становится проще переиспользовать, ибо когда все неявное состояние вынесено в аргументы функций, эти функции становится можно использовать за пределами класса, так как он становится отвязан от этих функций

class Result
  attr_reader :success, :data, :error_message

  def self.create(success, data = nil, error_message = nil)
    @success = success
    @data = data
    @error_message = error_message

    display_result
  end

  def self.success(data)
    Result.create(true, data)
  end

  def self.failure(error_message)
    Result.create(false, nil, error_message)
  end

  private

  def self.display_result
    {
      success: @success,
      data: @data || @error_message
    }
  end
end

p Result.success('Vasya') #=> {:success=>true, :data=>"Vasya"}
p Result.failure('Pidor') #=> {:success=>false, :data=>"Pidor"}



puts '                                    Алиас для статического метода'

# В Ruby можно создать алиас для статического метода (метода класса) с помощью метода `alias_method`. Однако, так как `alias_method` работает только с методами экземпляра, для создания алиаса статического метода вам нужно использовать `singleton_class` объекта класса. Вот пример, как это можно сделать:

class MyClass
  def self.original_method
    puts "Это оригинальный метод."
  end
end

# Создание алиаса для статического метода
class MyClass
  singleton_class.send(:alias_method, :alias_method_name, :original_method)
end

# Вызов оригинального метода
MyClass.original_method # => Это оригинальный метод.

# Вызов метода через алиас
MyClass.alias_method_name # => Это оригинальный метод.

# В этом примере мы создали класс `MyClass`, определили в нём статический метод `original_method`, а затем создали для него алиас `alias_method_name`, используя `singleton_class.send(:alias_method, ...)`. Теперь оба метода, оригинальный и алиас, могут быть использованы для вызова одного и того же кода.

















#
