puts '                                         ООП: Module/namespace(Модули)'

# ?? class Admin::UsersController < ApplicationController  ?? хз что это

# В модулях тоже можно создавать приватные методы

# Модули можно подключать в другие модули


# Модуль/namespace/пространство имён — это способ группировки методов, классов и констант; новый уровень логического разделения программы после классов и методов. Модуль может содержать любое количество методов, классов и других модулей.

# Модули дают преимущества:
# 1. Модули предоставляют пространство имен и предотвращают конфликты имен(В разные модули можно поместить константы и методы с одинаковыми именами и тогда они никак не будут конфликтовать в основном коде, примерно как положить фаилы с одинаковыми именами в разные папки)
# 2. Модули позволяют удобно создавать набор методов и подключать их в разные области, например в классы
# 3. Модули реализуют возможность миксина.
# 4. Можно использовать для своей библиотеки, выбрав уникальное имя модуля(лучше придумать необычное, чтоб не попасть на такое же, можно проверить в поиске рубиджемс, тк обычно имена модулей и название гемов одинаковое)

# Обычно принято что именем модуля называют директорию в которой лежит фаил с модулем и классом(или вложенным модулем), а имя этого фаила называют так же как класс/вложенный модуль
# my_gem.rb         -> MyGem
# my_gem/foo.rb     -> MyGem::Foo
# my_gem/bar.rb     -> MyGem::Bar
# my_gem/woo/zoo.rb -> MyGem::Woo::Zoo
# Тоесть в разных фаилах одной директории вложено в модули с одинаковым именем

# Имена(константы) модуля записываются так же, как константы класса, с начальной прописной буквы. Методы модуля определяются точно так же, как методы класса.

# Предпочитайте модули классам содержащим только методы класса. Классы следует использовать только тогда, когда имеет смысл создавать из них экземпляры.


# Модуль может использовать attr_
module Some
  attr_accessor :aaa
end

include Some

Some.aaa = 'x'
p Some.aaa #=> 'x'



# Статические методы модуля внутри себя вызывают по умолчанию только Статические методы модуля как классы


# Классы - это шаблоны по которым создаются объекты, а модули - это некий набор методов который, как правило, подключается внутри класса через include/prepend/extend (в зависимости от того как именно мы хотим наследоваться что-либо с модуля)


puts
puts '                Вызов методов и констант из модуля в текущую область видимости. Методы модуля'

# Методы записанные с префиксом или под module_function не могут запускаться без префикса модуля, в то время как записанные без префикса могут и так и так

module Amodule # Модуль создается при помощи ключевого слова module, название модуля с большой буквы
  # Константа
  PI = 3.14

  # Статические методы модуля - название методов должно иметь префикс с именем модуля либо префикс self, аналогично методам класса. Эти методы будут вызываться от модуля
  def Amodule.module_meth1(par)
    par - 1
  end
  def self.module_meth2(par)
    par - 5
  end

  # Стандартные методы модуля - перед вызовом метода нужно воспользоваться оператором вызова модуля "include"
  def somemeth(par)
    par + 1
  end

  module_function # module_function - ключевое слово, определяющее, нижестоящие методы методами(статическими) модуля.

  def shout(whatever)
    whatever.upcase
  end
end

# 1. Константа модуля вызывается через '::' это значит, что внутри модуля нужно найти(вызвать из модуля) константу с этим названием
p Amodule::PI #=> 3.14

# 2. Вызов статических методов модуля из модуля может осуществляться без подключения через include, от константы модуля
p Amodule.module_meth1(5)  #=> 4
p Amodule.module_meth2(20) #=> 15
p module_meth2(20)         #=> undefined method `module_meth2' for main:Object (NoMethodError)
p Amodule.shout('Hello')   #=> "HELLO"        # является методом модуля тк стоит ниже module_function
p shout('Hello')           #=> undefined method `shout' for main:Object (NoMethodError)

# 3. Вызов стандартных методов модуля - необходимо использовать include, можно вызывать как от константы модуля, так и без не
p Amodule.somemeth(5) #=> undefined method `somemeth' for Amodule:Module (NoMethodError)
# Для того чтобы методы вызывались подключим модуль в этом фаиле:
include Amodule # !!! модуль подключается в области ниже этой строки но не выше
# Теперь мы можем вызвать константы без '::' или методы не содкржащие префикса с именем модуля
p PI #=> 3.14
p somemeth(PI + 7)         #=> 11.14
p Amodule.somemeth(PI + 7) #=> 11.14

# Методы с префиксом нельзя без него вызвать и при подключенном модуле
p module_meth1(5) #=> undefined method `module_meth1' for main:Object (NoMethodError)


puts
puts '                                   Пространство имен. Конфликты имен'

# Мы можем определить еще один модуль с теми же именами методов, что и у модуля выше, но с другой функциональностью и конфликта в программе не возникнет изза того что этот метод будет вызван от другого модуля:
module Bmodule
  PI = 5
  def Bmodule.module_meth1(par)
    par + 10
  end
  def somemeth(par)
    par + 11
  end
end

p Bmodule::PI #=> 5   # Не возникает конфлика при вызове констант с одинаковым именем из разных модулей
p Bmodule.module_meth1(Amodule::PI/4) #=> 10.785    # Используем константу одного модуля в методе другого

p PI          #=> 3.14   # вызвалась константа модуля Amodule, тк он подключен а Bmodule нет
p somemeth(1) #=> 2      # вызвался метод модуля Amodule, тк он подключен а Bmodule нет

include Bmodule

p PI          #=> 5      # вызвалась константа от Bmodule, тк он подключен ниже и переопределил константу для этой области
p somemeth(1) #=> 12     # вызвался метод модуля Bmodule так же как с константой



puts '                                           include и extend'

# include и extend - операторы подключения модуля по его константе, переданной как параметр, в ту область видимости в которой этот оператор записан, все содержимое модуля как бы копируется в эту точку. При подключении вне класса оба работают одинаково, но различаются при подключении в классы

# Минусы подключения методов через include и extend для декомпозиции классов:
# 1. Когда модулей в класс подключено много, то сложно создавать новые етоды в классе или подключать ее модули, тк сложно уследить за нэймингом и могут быть в разных модулях или новые методы в классе с тем же именем и в итоге поледний метод переопределит другие и будет путаница. Особенно плохо, когда такие методы изменяют состояние. Тоесть по сути нарушается инкапсуляция и создается большая запутанность, особенно если в модуле будут использованы методы из класса или других модулей
# 2. Методы такого модуля в отрыве от другого фунционала класса могут быть не полноценны, изза чего их невозможно тестировать тдельно и нужно либо использовать весь класс либо создавать специальные тестовые классы
# 3. Тк это модуль, то у него нет конструктора и соответсвенно задание в нем каких-то значений, определяющих изначальное состояние осложнено и нужно использовать какие-то лэйзи штуки вроде ||=

module Some # модуль подключим далее в классы
  def meth
    'aaa'
  end
end

# Чтобы встроить модуль в класс, операторы include или extend прописываются в теле класса, либо при помощи синтаксиса Class.include SelfInject или Class.extend SelfInject:

# include - при подключении через него в класс, стандартные метоы модуля подключаются как методы экземпляра этого класса, а другой функционал будет доступен в методах экземпляра
class Bbb
  include Some
end
p Bbb.meth     #=> undefined method `meth' for Bbb:Class (NoMethodError)
p Bbb.new.meth #=> "aaa"

# extend - при подключении через него в класс, стандартные метоы модуля подключаются как статические методы класса этого класса, а другой функционал будет доступен в методах класса
Aaa.extend Some
class Aaa
end
p Aaa.meth     #=> 'aaa'
p Aaa.new.meth #=> undefined method `meth' for #<Aaa:0x0000021d059099e8> (NoMethodError)

# include и extend можно подключить в рамках одного класса, тогда создаст и методы экземпляра и методы класса, но обычно так не делают


puts
puts '                       require и require_relative(подключение модуля из другого фаила)'

# Желательный подход - 1 фаил для одного модуля/класса

# Создаем для модуля новый фаил(31_tools.rb) и создаем в нем модули

# require и require_relative - операторы загружающие фаил как бы прописывают код из него(например модуль) в этой точке


# require_relative - загружает/подключает фаил с указанным путём относительно местоположения/директории текущего фаила
require_relative "31_tools" # "Подключение" фаила. Если подключаемый фаил и данный фаил в одной папке то путь не прописываем, а иначе необходимо указывать путь
Tools.say_hello("George") #=> "Hi, George"
include Tools # подключаем теперь модуль
say_bye("Вася")           #=> 'Bye, Вася'


# require - ключевое слово для подключения фаила, оно использует для загрузки набор каталогов, заданных настройками среды и параметрами запуска интерпретатора
require './main/31_tools' #=> .rb писать необязательно
# './' - текущая директория и далее путь к этому фаилу
# Можно подключить "$LOAD_PATH << '.'" чтобы искать фаилы в текущем каталоге
BB.say_hi #=> "hi"
include BB
say_bye_bye() #=> "Bye bye"


puts
puts '                                           Классы из модулей'

# Если подключить одинаковые константы из модуля при помощи include, то будет применяться последняя, тк она получится записанной позже и переопределит предыдущую. Потому в этом случае лучше использовать синтаксис "::"
module Humans
	class JessiePinkman # классов в модуле может быть сколько угодно.
		def say_hi
			'hello'
		end
	end
end
module Dillers
	class JessiePinkman # классов в модуле может быть сколько угодно.
		def say_hi
			'hi, bitch'
		end
	end
end
# ::  - Синтаксис обращения к классу через модуль аналогичен синтаксису обращения к константе, это значит, что внутри модуля нужно найти(вызвать) константу с этим названием
jessie_pinkman = Humans::JessiePinkman.new
jessie_pinkman2 = Dillers::JessiePinkman.new
# Теперь это объекты разных классов и соотв будут обращаться к своим отдельным методам
p jessie_pinkman.say_hi  #=> "hello"
p jessie_pinkman2.say_hi #=> "hi, bitch"


puts
puts '                                        Подключение модуля в класс'

# Удобно как альтернатива наследованию, если есть классы в которох будет совсем немного общего функционала или классы, которые уже наследуют у какихто классов и в них надо добавить функционал


# Подключение модуля в класс вне тела класса Так же удобно для добавления функциональности во встроенные классы
Array.include SelfInject


# Константы и статические методы модуля подключенные в класс
module Week
  FIRST_DAY = "Sunday"

  def Week.weeks_in_month
    "You have four weeks in a month"
  end
end

class Decade
  include Week # Подключаем модуль в теле класса, теперь все что содержит модуль доступно в классе

  def no_of_months
    "120 months from #{FIRST_DAY}" # Константа модуля вызвана в методе класса
  end
  def weeks_in_month  # Так можно вызвать метод модуля от объекта
    Week.weeks_in_month
  end
end

d = Decade.new

# Константу можно вызвать и от модуля и от класса в который он подключен:
p Week::FIRST_DAY   #=> "Sunday"
p Decade::FIRST_DAY #=> "Sunday"
p d.no_of_months    #=> "120 months from Sunday"     # Метод класса с константой подключенной из модуля:

# Метод модуля с префиксом нельзя вызвать от объекта класса или как метод класса, а можно только от модуля или обернув вызов этого метода модуля в метод класса:
p d.weeks_in_month      #=> undefined method `weeks_in_6_month' for #<Decade:0x000001f507519660> (NoMethodError)
p Decade.weeks_in_month #=> undefined method `weeks_in_6_month' for Decade:Class (NoMethodError)
p Week.weeks_in_month   #=> "You have four weeks in a month"
p d.weeks_in_month      #=> "You have four weeks in a month"    # вызываем метод класса который вызывает одноименный метод модуля


puts
# В модуль можно помещать attr_ ... и конструктор и подключить их потом в класс
module MyModule
  attr_accessor :x

  def initialize(x)
    @x = x
  end

  def right
    self.x += 1
  end
  def left
    self.x -= 1
  end
end

class Dog
  include MyModule # Теперь класс получает все методы, конструктор и атрибуты из модуля

  def left # Можно переопределить методы модуля для данного класса
  end

  def label # Собственный метод класса
    '@'
  end
end

dog = Dog.new(10)
# Используем атрибуты и конструктор из модуля
p dog.x     #=> 10
p dog.x = 7 #=> 7
# Используем методы из модуля
p dog.right #=> 8
p dog.left  #=> nil # Метод переопределен в классе и значение переменной y не меняется
p dog.x     #=> 8   # Значение y осталось прежним


puts
puts '                                        Наследование класса из модуля'

# Наследуем у класса Base из модуля ActiveRecord
class Client < ActiveRecord::Base
end


puts
puts '                                  Mix-ins/Примеси(Подключение 2+ модуля в класс)'

# Миксины в значительной степени устраняют необходимость в множественном наследовании, которое не поддерживается Руби

# Класс Sample может одновремено испльзовать методы из модулей A и B, соответсвенно можно сказать, что класс Sample показывает множественное наследование или примесь:
module A
  def a1
    puts 'a1'
  end
end

module B
  def b1
    puts 'b1'
  end
end

class Sample
  include A # Подключаем 1й модуль в класс
  include B # Подключаем 2й модуль в класс
  def s1
    puts 's1'
  end
end

samp = Sample.new
samp.a1 #=> "a1"  # Вызов объектом метода из модуля A
samp.b1 #=> "b1"  # Вызов объектом метода из модуля B
samp.s1 #=> "s1"













#
