puts '                                            Полиморфизм'

# Полиморфизм (Polymorphism) - концепция ООП, которая позволяет объектам разных классов обрабатываться единообразно через общий интерфейс. Полиморфизм позволяет вызывать один и тот же метод на объектах разных классов, и каждый объект будет выполнять этот метод по-своему

# Полиморфизм реализует общий функционал для объектов и не важно что объекты могут сильно отличаться друг от друга.

# В Ruby, полиморфизм достигается через:
# 1. Утиную типизацию (Duck Typing) - "Если это выглядит как утка, крякает как утка, то это, вероятно, утка."
# 2. Наследование (Inheritance) - подклассы могут переопределять методы своих суперклассов.
# 3. Модули (Modules) - Ruby не имеет явных интерфейсов, как в Java или C#, но модули с набором методов могут играть роль интерфейсов.

# Преимущества Полиморфизма:
# 1. Позволяет легко добавлять новые классы и типы объектов, не изменяя существующий код.
# 2. Делает код более расширяемым и поддерживаемым.  Новые функциональные возможности можно добавить, переопределяя методы в подклассах.
# 3. Общий интерфейс позволяет использовать один и тот же код для обработки различных типов объектов.
# 4. Уменьшает количество условных операторов (if/else), так как выбор правильного метода выполняется автоматически во время выполнения



puts '                                            Duck Typing'

# Утиная типизация - это самый распространенный способ реализации полиморфизма в Ruby. Если есть какие-либо классы, у которых есть одинаковые методы, то с точки зрения потребителя это одинаковые классы. Тоесть мы воспринимаем объект с позиции того на какие методы он отвечает, а не того какой у него класс. Тоесть если что-то выглядит как утка и крякает как утка - то это утка.

# Если 2 класса содержат одноименные методы, то желательно чтобы у них было схожая суть, тоесть по смыслу они работали похожим образом, чтобы обеспечиить интуитивность использования

class Duck
  def say
    'quack'
  end
end

class Dog
  def say
    'wof'
  end
end

# Метод `command` принимает любой объект `animal` и вызывает метод `say` на этом объекте. Неважно, является ли `animal` экземпляром класса `Dog` или `Duck`. Важно лишь то, что у него есть метод `say`
def command(animals)
  animals.map { |animal| animal.say }
end

p command([Duck.new, Dog.new]) #=> ["quack", "wof"]



puts '                                 Наследование с переопределение методов'

# Например, в главном классе даем возможность передвижения для всех объектов. Далее в классах наследниках можем дополнительно указать возможность передвижения другими способами. Получается, что есть общий функционал что записан в главном чертеже, но его можно переписать для каждого наследника.

class Animal
  def speak
    "Generic animal sound"
  end
end

class Dog < Animal
  def speak
    "Woof!"  # Переопределяем метод speak
  end
end

# Здесь класс `Dog` наследуются от класса `Animal` и переопределяет метод `speak`, чтобы выводить специфичный звук.  При итерации по массиву `animals` и вызове метода `speak` для каждого элемента, вызывается правильная реализация метода `speak` в зависимости от фактического типа объекта
p [Animal.new, Dog.new].map { |animal| animal.speak } #=> ["Generic animal sound", "Woof!"]



puts '                                       Модули как "Интерфейсы"'

# Хотя Ruby не имеет явных интерфейсов, можно использовать модули, чтобы определить набор методов, которые должны быть реализованы в классе. Это позволяет обеспечить определенный контракт и, следовательно, полиморфное поведение.

module Speakable
  def speak
    raise NotImplementedError, "Method 'speak' must be implemented in the class that includes Speakable"
  end
end

# Модуль `Speakable` определяет метод `speak`. Классы, которые включают этот модуль, должны реализовать метод `speak`. Если класс не реализует `speak`, то при вызове будет вызвано исключение `NotImplementedError`. Это позволяет гарантировать, что любой объект, который "является Speakable", будет иметь метод `speak`.

class Duck
  include Speakable

  def speak
    "Quack!"
  end
end

class Person
  include Speakable

  def speak
    "Hello!"
  end
end

p [Duck.new, Person.new].map { |animal| animal.speak } #=> ["Quack!", "Hello!"]















#
