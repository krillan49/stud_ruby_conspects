puts '                                                Классы'

# Класс - это тип данных, например встроенные клаасы в Ruby: Integer, String, Array итд; либо свои классы

# Клаcсы в Руби это тоже объекты и у них могут быть свои переменные, как у любого объекта

# Все классы Руби наследуют у корневых классов Object и BasicObject

# В Ruby все что написано с большой буквы - это константа. Передать из файла в файл при помощи require можно только константы. Поэтому классы с маленькой буквы хоть и возможны (при помощи метапрограммирования), но бессмыслены с практической точки зрения

# Класс есть смысл создавать только если необходим объект этого класса.

# Классы принято создавать каждый в отдельном фаиле с тем же названием что и класс, только в снэйккейс.

# Состояние объекта (state) - это совокупность значений всех его переменных (свойств) (есть в cs)



puts '                                     Синтаксис, экземпляр. Метод new'

class MyAnimal # Классы называют существительными в единственном числе, каждое слово с большой буквы без разделения пробелами.
  def run # метод экземпляра, который будет работать при вызове от любых объектов класса
    "Muska run!!!"
  end

  def eat
    print 'I am eating '
    # Можно обращаться к методу экземпляра в другом методе экземпляра, он вызовется от того же самого объекта, тк применит к нему self по умолчанию:
    run # вызываем метод экземпляра run в теле метода eat, теперь метод при вызове от объекта вызовет и метод run, это будет аналогично self.run тк в писать self в методе экземпляра не обязательно, он автоматически будет вызван от текущего объекта
  end
end

# Объекты/образцы/экземпляры класса создаются вне класса при помощи метода new и их можно присвоить в переменные:
dog = MyAnimal.new # Новый объект класса задается в переменную dog.

# Объект возвращает индентификатор объекта, где описан класс и ссылки на ячейки памяти в которых располагается объект, где 0x обозначает 16ричное число
dog #=> #<Animal:0x000001fa1ac61928>

# Вызов метода экземпряра класса для этого объекта класса. Тоесть метод на который отвечает объект. Тоесть у самого экземпляра есть этот метод, а не у класса(?)
dog.run #=> "Muska run!!!"

# Метод eat исполнил и метод run:
dog.eat #=> I am eating "Muska run!!!"

# Объектов можно создать сколько угодно
cat = MyAnimal.new # new - это выделение памяти. Теперь этот созданный объект имеет все переменные заданные классом
cat.run #=> "Muska run!!!"

# Альтернативный способ создания объекта с одновременным вызовом метода без присваивания объекта в переменную
MyAnimal.new.run #=> Muska run!!!

# class - метод вернет константу класса объектов
dog.class #=> Animal

# name - метод возвращает строковый ватант имени класса от его константы
dog.class.name #=> "MyAnimal"
''.class.name  #=> "String"


# instance_methods - метод вернет массив со всеми методами в виде констант доступными объектам класса(например __id__)
MyAnimal.instance_methods
# Удобно при помощи него искать в массиве какй-то метод:
MyAnimal.instance_methods.include?(:run)  # => true

# methods - метод вернет массив со всеми методами доступными классу(как созданными так и встроенными) ? с методами класса ?
MyAnimal.methods


# respond_to?('name') / respond_to?('name=') - метод проверки наличия указанного метода в клаасе. Возвращает true, если obj отвечает на данный метод. Закрытые и защищенные методы включаются только если необязательный второй параметр имеет значение true
dog.respond_to?('run')        #=> true
dog.respond_to?('change=')    #=> false
dog.respond_to?('run', 'eat') #=> true



puts '                                     Переменная экземпляра. Атрибуты'

# Локальная переменная заданная внутри метода будет существовать только внутри него, чтобы задать переменную доступную для всех методов экземпляра класса, нужно сделать ее переменной экземпляра

# “@” (читается как “at”) - Переменная экземпляра/instance variable - переменная экземпляра класса будет видна только внутри тела этого класса и доступна в каждом методе экземпляра класса

# Переменные образца класса являются атрибутами, тк сохраняют свое состояние для образца класса. Данные атрибутов сохраняются отдельно в областях памяти приписанных этим объектам, тоесть это данные объектов

class Xuinya
  def z
    @zz = 44 # Инициализация переменных методом для объекта происходит только в момент вызова метода объектом
    puts "zz #{@zz} zz"
  end

  def x
    puts "xx #{@zz} xx"
  end
end

xuy = Xuinya.new
pen = Xuinya.new
xuy.x #=> "xx  xx"    # Переменная @zz не инициализировалась, потому что метод z еще не вызывался для данного объекта
xuy.z #=> "zz 44 zz"  # Тут переменная инициализируктся, тк вызван метод в теле которого она задана
xuy.x #=> "xx 44 xx"  # Теперь она доступна и для других методов этого объекта
pen.x #=> "xx  xx"    # Но для другого объекта переменнаую снова нужно инициализировать

# instance_variables - метод выведет массив всех доступных объекту переменных экземпляра в виде символов
xuy.instance_variables          #=> [:@zz]

# instance_variable_get(:@zz) - метод вернет значение переменной экземпляра
xuy.instance_variable_get(:@zz) #=> 44
# так же в методах класса (Name.new.methods) можно посмотреть и другие методы



puts '                                              Конструктор'

# Конструктор - это специальный метод внутри класса, он выполняются каждый раз, когда мы создаем новый объект, тоесть вызываем метод new от класса. Нужен для того, чтобы определить начальное состояние объекта, например для инициализаций переменных необходимых для работы класса

# initialize - название метода конструктора, которое зарезервировано

# Удобнее всего переменные экземпляра задать в конструкторе, а не в одном из методов класса тк в конструкторе она будет инициализированна автоматически в момент создания объекта методом new

# Mожно передавать параметры в конструктор, так же как и в обычные методы, данные должны передаваться через аргументы метода new при созданнии экземляра. Либо данные можно передать посзже обычным методом

class Bbro
  # Конструктор сработает автоматически для каждого экземпляра в момент его создания:
  def initialize(helmet=0, shild=0, weapon=0) # принимает аргументы как обычный метод
    # Любой код в конструкторе будет исполняться при создании новых объектов:
    puts "Helmet(#{helmet} armor), shild(#{shild}% block), weapon is #{weapon}"
    # Инициализируем переменные, теперь они доступны для всех методов класса в момент создания объектов:
    @players = {}
    # Устанавливаем значения параметров конструктора значениями в переменные класса. Теперь мы можем использовать эти значения в других методах класса:
    @armor = helmet
    @block = shild
    @weapon = weapon
    @defence = helmet * (1 + shild * 0.01)
  end

  def add_player(options) # передача хэша в метод при вызове метода от объекта класса.
		return if @players[options[:name]]
		@players[options[:name]] = options[:age]
	end

  def show_players # необходим метод для обращения к переменной
    @players
  end

  def big_defence?
    @defence > 200
  end

  def to_info # метод для наглядного вывода характеристик объектов класса
    "Brozer def is #{@defence}, weapon is #{@weapon}"
  end
end

# Метод new, помимо создания объекта, вызывает метод конструктора initialize:
a = Bbro.new  #=> "Helmet(0 armor), shild(0% block), weapon is 0"
b = Bbro.new  #=> "Helmet(0 armor), shild(0% block), weapon is 0"

# Передаем хэш в метод, чтобы присвоитиь значения в переменные
b.add_player name: 'Mike', age: 55
# Чтобы обратиться к переменной заданной в классе, нужно создать для этого метод
b.show_players          #=> {"Mike"=>55}
b.show_players['Mike']  #=> 55            # можно обращаться к методам возвращаемых объектов

# Передаем данные для параметров конструктора:
hedge_knite = Bbro.new(150, 50, 'Noble sword') #=> "Helmet(150 armor), shild(50% block), weapon is Noble sword"

hedge_knite.big_defence? #=> true
a.big_defence?           #=> false

hedge_knite.to_info #=> "Brozer def is 225.0, weapon is Noble sword"

hedge_knite         #=> #<Bbro:0x00000153d6657518>
hedge_knite.inspect #=> "#<Bbro:0x00000153d6657518 @players={}, @armor=150, @block=50, @weapon=\"Noble sword\", @defence=225.0>"



puts '                                           Getter. Setter'

# Способы присвоения новых значений переменных при помощи методов, name_method= и конструктора.

class Song
  def initialize(duration)
    @duration = duration
  end

  # getter methods (методы доступа)
  def duration
    @duration
  end

  # setter methods (методы установки)
  def new_duration(new_duration) # 1й способ привоения новых значений, стандартный
    @duration = new_duration
  end
  def duration=(new_duration)    # 2й споcоб, через метод имя которого оканчивается на = (фича Руби)
    @duration = new_duration
  end

  # Методы доступа к атрибутам не обязательно должны быть просто оболочками вокруг переменных экземпляра объекта (Инкапсуляция). Например, можно получить доступ к продолжительности в минутах:
  def duration_in_minutes
    @duration / 60.0   # не меняя или добавляя новую переменную вводим новую функциональность(создание виртуальной переменной экземпляра). Для пользователя продолжительность в минутах кажется таким же атрибутом, как и любой другой. Однако внутри нет соответствующей переменной экземпляра.
  end
  # Сеттер с = тоже может содержать сложную логику
  def duration_in_minutes=(value)
    @duration = (value * 60).to_i
  end
end

song = Song.new(260)
song.duration             #=> 260
# 1й способ:
song.new_duration 240
song.duration             #=> 240
# 2й споcоб:
song.duration = 257    # тут 'duration =' это метод
# вызывает метод duration= от объекта, передавая ему 257 в качестве аргумента. Фактически, определение имени метода, заканчивающегося знаком равенства, делает это имя подходящим для отображения в левой части присваивания.
song.duration             #=> 257

song.duration_in_minutes       #=> 4.283333333333333
song.duration_in_minutes = 4.2
song.duration                  #=> 252


# Setter-ы (методы с =) ведут себя не как обычне методы(которые возвращают значение последнего выражения) а как присваивания: значение выражения ticket.price = 63.00 равно 63.00, даже если метод ticket= возвращает строку “Ха-ха!”. Это вызов метода, но он выглядит как присваивание и ведет себя как присваивание в отношении своего значения в виде выражения.
class Some
  def initialize
    @n = 1
  end

  def set_n(val)
    @n = val
    "ha-ha"
  end

  def set_n=(val)
    @n = val
    "ha-ha"
  end
end

s = Some.new
p s.set_n(1)   #=> "ha-ha"
p s.set_n = 1  #=> 1



puts '                         attr_reader, attr_writer и attr_accessor. Свойства класса'

# Свойства класса  - переменные экземпляра и их методы заданные атрибутами. Свойства класса позволяют создавать и обращаться к переменным класса от объектов(читать и менять значения переменных экземпляра, те состояние объектов) без необходимости задавать отдельные методы.

# attr_ конструкция при объявлении создает методы и переменные для каждого имени переданного в нее через символы:
# attr_accessor - метод создает переменную экземпляра и одноименные и геттер и сеттер для нее
# attr_reader   - метод создает переменную экземпляра и одноименный геттер для нее
# attr_writer   - метод создает переменную экземпляра и одноименный сеттер для нее

# attr_accessor и attr_writer инициализируют переменные, если они не были инициализированны в конструкторе тк за ними скрыты сеттеры

# Можно добавлять новые свойства класса и уже после создания объектов

class Car
  attr_accessor :speed, :model     # переменные задаются через символ, между ними запятые(в конце запятую не надо).
  attr_accessor :color, :name      # либо можно задавать с новой строки с нового кодового слова
  attr_reader :wheels
  attr_writer :auto_pilot

  def initialize(name)
    @name = name
  end
end

bmw = Car.new('Mac5')
# присваиваем значение(инициализируем) переменной @speed, тк сеттер метод= существует "внутри" attr_accessor
bmw.speed = 230
bmw.model = "X5"
bmw.color = "Black"
bmw.wheels = 3         #=> (NoMethodError) attr_reader(только для чтения)
bmw.auto_pilot = 'GPT' # attr_writer - можно переназначать.

bmw.speed      #=> 230             # Вывод значения переменной экземпляра от геттера через attr_
bmw.model      #=> "X5"            # attr_accessor - можно выводить
bmw.color      #=> "Black"
bmw.wheels     #=> nil             # attr_reader - можно выводить
bmw.auto_pilot #=> (NoMethodError) # attr_writer - нельзя выводить

# Для переменной инициализированной в конструкторе, тк геттеры и сеттеры обращаются к переменным экземпляра с тем же именем
bmw.name  #=> "Mac5"
# Поменяем значение при помощи сеттерва из attr_accessor:
bmw.name = 'Kroker'
bmw.name  #=> "Kroker"



puts '                             Что под капотом у attr_. Кастомный accessor'

# Класс который будет унаследован, классом в котором будем использовать кастомный аксессор
class SuperFoo
  attr_reader :data

  def initialize
    @data = {}
  end

  # Наш кастомный accessor
  def SuperFoo.data_accessor(*args)
    args.each do |meth|
      # Определим геттер и сеттер для переменных, которые зададим параметрами в кастомный акссессор
      define_method(meth.to_s) { @data[meth] }          # в блоке тело метода, он сработает при обращении к методу
      define_method("#{meth}=") {|v| @data[meth] = v }  # имя значение переменной будем хранить в хэше @data
    end
  end
end

class SubFoo < SuperFoo
  data_accessor :fizz, :pi # вызываем унаследованный метод SuperFoo.data_accessor(*args) и создаем сеттеры и геттеры для переменных, имена и значения которых будем хранить в @data
end

sub_foo = SubFoo.new

sub_foo.fizz = "FIZZ"
p sub_foo.fizz        #=> "FIZZ"
sub_foo.pi = 3.14
p sub_foo.pi          #=> 3.14

p sub_foo.data               #=> {:fizz => "FIZZ", :pi => 3.14}
p sub_foo.instance_variables #=> [:@data]














#
