puts '                          Методы/функции, блоки, return, yield, lambda, alias, undef'

# Метод всегда имеет получателя - объект, вот его можно передать, если присвоить константе. Если вы видете глобальный метод - это иллюзия, у него все-равно есть объект. когда определяешь функции или в файле, то они определяются к объекту main, у него класс Object
# в Ruby функций нет, есть только методы. Методы не существуют в отрыве от объекта. Объекты можно передавать между файлами. Поэтому если вы объявляете метод в одном файле, а он автоматом цепляется к глобальному объекту main, то в другом файле вы его тоже вызовете - потому, что там тоже этот глобальный объект есть (но файлы придется связать при помощи require, сами по себе они не свяжутся). А вот с локальными переменными, которые тоже с маленькой буквы объявляются, уже такое не прокатит. Локальная переменная не передастся, а классы, константы, модули и методы - передаются.

# Точка перед ключевым словом метода ставится, когда это ключевое слово, тоесть начинается с буквы, а если оператор метода задается символом, то точка не обязательна.


# Блок - это какой-то кусок кода(программа) начинающийся с ключевого слова(в зависимости от типа блока например n.times do) и заканчивающийся end. Блоки могут быть вложенными, тоесть находиться внутри тела других блоков.

# &:  указатель на функцию.
[0, 0, 1, 1, 0, 0, 1, 0].count(&:zero?) #=> 5 проверяя массив методом count применяет метод zero? к каждому элементу
[11, 22, 33, 44, 55].count(&:even?) #=> 2

# 2+3 следует читать как 2.+(3) где + это метод вызванный на объекте 2 с аргументом 3
2+3 #=> 5
2.+(3) #=> 5


puts
puts '                                               Методы/Функции'

# Так как в Руби все данные это объекты то все функции в Руби являются методами.

# функции - это обособленный фрагмент кода(подпрогрпмма), который называется по имени. В нее могут быть переданны данные для работы(параметры). Функция может опционально возвращать данные (возвращаемое значение). Все данные, передаваемые функции, передаются явно.
# Метод в объектно-ориентированном программировании — это функция, принадлежащая какому-то классу или объекту. Методы классифицируются по применимости к объектам: статические и простые/нестатические; по возможности использования: public, private, protected. Метод может работать с данными, содержащимися в классе (помня, что объект является экземпляром класса - класс является определением, объект является экземпляром этих данных).

# процедуры - альтернативное название функций и методов.

# Основная задача - выделить какие-то логические блоки и сделать программу более читаемой для человека(например вынести повторяющийся код и обращаться к нему, когда это будет нужно). Часто такой процесс называется рефакторингом (а эту технику рефакторинга - extract method/выделить метод). В результате рефакторинга большой участок программы разбивается на несколько маленьких.
# рефакторинг кода — это процесс реструктуризации существующего компьютерного кода — изменение факторинга — без изменения его внешнего поведения. Рефакторинг предназначен для улучшения дизайна, структуры и/или реализации программного обеспечения (его нефункциональных атрибутов) при сохранении его функциональности.

# Методы должны быть определены до их вызова

def kroker_say # def (define/определить) Обозначение(ключевое слово) начала(открытия) метода, def определяет/задает функцию, имя метода/функции в Руби пишется без больших букв, разделяя слова нижним подчеркиванием
  puts "Я Крокер!" # тело метода между def и end
end # обозначение конца(закрытия) метода end

puts "Привет"
# Вызов метода(и его работа) производится его названием в любом месте(сколько угодно раз), например между других строк
kroker_say() #=> "Я Крокер!"
puts "Нихуясе!"
kroker_say() #=> "Я Крокер!"


puts
puts '                                            Методы с параметрами'

# параметр в методе == локальная переменная
# Методы с параметрами. Если значения указанных параметров не заданы ни при вызове метода ни по умолчанию, выдаст ошибку
def kroker_say2(word = "Я огромен!", num = 9000) # word и num - некие параметры, после = значения параметров по умолчанию
  puts "Я Крокер!"
  puts ("Крокер говорит: " + word + " Крокер достает и измеряет: " + num.to_s)
  puts "Hello, #{word}"
end
kroker_say2("Вот мой огромный меч!", 100500) # В скобках заданы значения параметров для word и num
kroker_say2() # Если не указать значение параметров после вызова метода, то выдаст значение параметров заданных по умолчанию
kroker_say2 'Roman'  # Синтаксис без скобок

# сумма параметров
def sum(x, y)
  puts (x + y)
end
sum(5, 20) #=> 25

# хэш в виде параметра
def hash_1 hash
  print hash
end
hh = {1=> :a, 2 => :b}
hash_1 hh #=> {1=>:a, 2=>:b}

# Неопределенное колличество параметров. Помещаются в массив при помощи символа * перед параметром
def sum(*args)
  args
end
p sum(1, '2', 3, 'gbcz') #=> [1, '2', 3, 'gbcz']

# Неопределенное колличество параметров, включая элементы хэша
def args_count(*args, **kwargs)
  p args
  p kwargs
end
args_count(1, 2, a: 1, b: 2)
#=> [1, 2]
#=> {:a=>1, :b=>2}

# Вызов метода внутри самого себя(зацикленный метод/рекурсия)
def total(arr)
  return arr.first if arr.size == 1
  total(arr.each_cons(2).map{ |a,b| a+b })
end

# метод в одну строку
def met(a) a+1 end
p met(1) #=> 2


puts
puts '                                           Оператор return'

# Оператор return возвращает из функции указанную после него строку кода к оператору вызова метода и завершает работу метода
# По умолчанию функция возвращает последнюю строку кода(для ее возврата return не обязателен)
# Можно в некотором смысле return для функций считать аналогом break в циклах
def raznoe(x = 100, y = 50)
  puts "пися"
  return x - y, 70, "Сися"  # Возвращает что либо из метода и так же выходит из него(не учитывает все последующее тело метода)
  puts (x + y)
end
raznoe() #=> [50, 70, "Сися"] # Выполняет все, что идет до и в return, не выпоняет все что после return.
# Если задано более двух выражений, возвращаемым значением будет массив, содержащий эти значения. Если выражение не задано, возвращаемым значением будет nil

puts
# По умолчанию Руби возвращает результат последнего выражения. Тоесть любой строки когда находящейся последней в теле метода. Соответсвенно return в этом случае можно не ставить.
def get_command
	"left" # аналогично retutn "left"
end
p get_command() #=> "left"

puts
# Если возвращать условие, то return при выводе будет проверять это условие и выдавать false/true
def zad?(x, y) # имя метода, которое возвращает булевое значение пишется с вопросительным знаком
  return (x < 20 and y == 10) # return так же необязателен
end
puts zad?(15, 10) #=> true
puts zad?(21, 10) #=> false

puts
# Не смотря на то что метод возвращает только то что идет в return или в последней строке, но выполняет он весь код соответсвенно все что в нем есть на вывод выводится, а на инициальзацию инициализируется
def some(x = 100, y = 50)
  @a=x
  b=x
  y
end
p some() #=> 50
p @a     #=> 100
p b      #=> undefined local variable or method `b' for main:Object (NameError)


puts
puts '                             Помещение результата выполнения метода в переменную'

res = raznoe(25, 10)  # Помещение результата выполнения метода в переменную
p (res) #=> "пися\n" [15, 70, "Сися"]
puts (res[2]) #=> "Сися"  # Можно обращаться через переменную к return(не учитывает и то что в теле метода до return) как к массиву, если возвращаем несколько значений
puts "Получена команда #{res[1]}" #=> "Получена команда 70"

puts
# Пример метода для ввода данных(gets)
def get_number(what)
  print "Введите #{what}: "
  gets.to_i
end
age = get_number('возраст')
salary = get_number('зарплату')
rockets = get_number('количество ракет для запуска')


puts
puts '                                              Переменные экземпляра'

# Локальная(local) - это любая переменная, объявленная внутри метода. Внутри тела метода переменная определяется заново(переменная с тем же именем вне метода это другая переменная) отдельно для пространства "внутри" этой функции
# Переменные экземпляра класса работают(доступны) по всей программе(но ограниченны классами либо внутри либо вне) как внутри отделых методов так и вне их. Назначаются при помощи символа @(Желательно использовать только в классах)
a = 1
@b = 1
def a_a
  a = 2
  @b = 2
  puts "#{a}, #{@b}"
end
a_a #=> "2, 2"
puts a #=> 1
puts @b #=> 2


puts
puts '                                               options'

# Если в метод нужно задать много параметров и потом некоторые убрать/добавить/поменять местами, то придется их менять и в каждом месте вызова метода. Поэтому удобнее вместо отдельных параметров использовать один параметр options(назвать можно как угодно) в который передать хэш содержащий отдельные параметры. Так параметры удобно добавлять, убирать и они не будут зависеть от порядка. К тому же точно видно какие параметры мы передаем, т.к. мы явно указываем названия этих параметров

def add_person (options = {}) # С указанием значений по умолчанию({} - пустой хэш). Так не будет ошибки если вызвать метод без параметров, тк переменные “a, b, c” будут инициализированы значением nil и метод можно будет вызывать без параметров.
  age = options[:age]
end
list = { name: 'Mike', age: 65 } # Вариант передачи с помещением хэша в переменную для наглядности
add_person(list)
add_person(name: 'Mike', age: 65) # Вариант 2. Фиг скобки не обязательны, Руби понимает что это хэш.


puts
# Так же в месте с хэшем можно передать и другой параметр.
# Если в функцию передается и хэш и отдельный параметр, то хэш всегда располагается по порядку последним. Происходит так потому что мы не знаем какое колличество элементов будет в хэше, а тк мы передаем их через запятую, то параметр записанный после хеша может быть воспринят ключем очередного элемента хэша.
def met(a, hh)
  # Какой-то код
end
met(125, name: 'Mike', age: 65)


puts
# nil || true. Если не задавать параметр(или испотзуемые элементы хэша) при вызове метода, то могут возникнуть проблемыы изза операций заданных методом, которые не могут проводиться со значением nil. Для предотвращения можно использовать оператор ||(or/или).
# nil || true => true;  nil || 100 => 100;  nil || 'aaa' => "aaa"
def total_weight(options = {})
  a = options[:soccer_ball_count] || 0 # Будет 0 вместо nil
  b = options[:tennis_ball_count] || 0
  c = options[:golf_ball_count] || 1 # Удобно задавать другие альтернативные решения(например 1 мяч в подарок если нет заказа)
  (a * 410) + (b * 58) + (c * 45) + 29
end
p x = total_weight() #=> 74   # (0 * 410) + (0 * 58) + (1 * 45) + 29
p x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1) #=> 1429


puts
# Пример программы с options:
# Метод launch принимает набор опций в виде хеша: 1. astronauts - массив символов [:belka, :strelka, :gagarin] (если не задан, то в космос нужно отправлять Белку и Стрелку); 2. delay - количество секунд до запуска(если не задано, то 5)
# Метод выводит: подсчет оставшихся до запуска секунд(Осталось секунд: 5 4 3 2 1), сообщение о том, какой астронавт (астронавты) запущены. Метод может принимать любое количество параметров.
# Варианты вызова: launch; launch(delay: 3); launch(delay: 3, astronauts: [:gagarin]); launch(astronauts: [:belka])
def launch(options = {})
  x = options[:delay] || 5 # Коллич секунд для запуска
  x.downto(1) do |n| # начинаем отсчет
    puts n
    sleep 0.5
  end
  puts 'Launch start!'

  astronauts = options[:astronauts] || [:belka, :strelka] # Выбор космонавтов
  astronauts.each {|a| puts "Astronaut is #{a.to_s.capitalize}"}
end
# Задаем параметр options
par = {
  astronauts: [:belka, :strelka, :gagarin],
  delay: 10
}
launch(par)


puts
puts '                                Proc. Процедуры и их виды(потом сопоставить с тем что ниже)'

# Proc - процедура. Существует 3 типа процедур: анонимные методы, лямбда, блок

# 1. Анонимный метод - это функция без имени
proc = Proc.new { 'какойто_код' } # создание анонимного метода
p proc.call #=> "какойто_код"  # вызов анонимной функции

# 2. Ламбда функция - почти тоже самое что и анонимный метод

# 3. Блок кода это по сути тоже анонимная функция, только передается по другому: через yield или &block.
# Блок - это какой-то кусок кода начинающийся с ключевого слова(в зависимости от типа блока например n.times do) и заканчивающийся end
# Блоки могут быть вложенными, тоесть находиться внутри тела других блоков.

# Пример
def three_ways(proc, lambda, &block) # запрашивает proc, lambda и block
  proc.call
  lambda.call
  yield # like block.call  # puts "I'm a block, but could it be???"
  puts "#{proc.inspect} #{lambda.inspect} #{block.inspect}"
end

anonymous = Proc.new { puts "I'm a Proc for sure." }
nameless  = lambda { puts "But what about me?" }

three_ways(anonymous, nameless) do
  puts "I'm a block, but could it be???"
end
#=> I'm a Proc for sure.
#=> But what about me?
#=> I'm a block, but could it be???
#<Proc:0x0000020841c7b2f8 E:/doc/ruby_exemples/test3.rb:14> #<Proc:0x0000020841c7a768 E:/doc/ruby_exemples/test3.rb:15 (lambda)> #<Proc:0x0000020841cb33d8 E:/doc/ruby_exemples/test3.rb:17>


puts
puts '                                yield (Передача блоков в функцию/функция обратного вызова)'

# Блок - это совокупность фрагментов кода. Вы присваиваете имя блоку. Код в блоке всегда заключен в фигурные скобки ({}) или do ... end.
# Блок всегда вызывается из функции с тем же именем, что и у блока. Это означает, что если у вас есть блок с именем test , то вы используете функцию test для вызова этого блока.
block_name { # имя оператора функции в который будет присвоен этот блок
  # код блока
}

# yield - можно по смыслу перевести как вызов. Ключевое слово yield вызывает блок который мы перелаем в метод, соотв этот код помещается/выполняется в вызванном месте. (это чтото вроде способа наполнения метода не в самом теле метода а вызванное при запуске метода)
def run_5_times
	3.times do |n|
    print "#{n+1}) "
		yield # сюда вызван блок { print 'some ' }. Выполняется тело блока
    print 'new '
    yield # сюда тоже вызван блок { print 'some ' }. Можно вызывать сколько угодно раз
	end
end
run_5_times { print 'some ' } #=> 1) some new some 2) some new some 3) some new some


# альтернативный синтаксис передачи блока
def show_me_text
  print "<h1>"
  yield
  print "</h1>"
end
show_me_text do
  print "Foo!"
end
#=> <h1>Foo!</h1>


# yield с параметром. В примере ниже мы по сути напишем алгоритм для метода-цикла 5.times
def run_5_times
  x = 0
	while x < 5
		yield x, 55  # передаем параметр x в yield, а он соответсвенно передает его в переменную блока(можно передать несколько параметров) x -> i, 55 -> v
    x += 1
	end
end
run_5_times { |i, v| puts "something #{v}. index #{i}" } #=> "something 55. index 0" "something 55. index 1" ...


# Передача чисел по порядку в блок
def sequence(&b)
  Enumerator.new do |y|
    i = 0
    loop do
      y.yield b.call(i)
      i += 1
    end
  end
end
# or
def sequence
  Enumerator.new do |y|
    n = 0
    loop do
      y << yield(n)
      n += 1
    end
  end
end
sequence {|n| n}.take_while {|n| n < 10} #=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
sequence {|n| (n * n)}.take(10) #=> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]


# Конструкция block_given? помогает не получать ошибку если блок не передан
def compute
  block_given? ? yield : 'block is not transmitted'
end
p compute { 'Block' } #=> "Block"
p compute #=> 'block is not transmitted'


puts
puts '                                 Передача параметров и блоков в функцию при помощи &'

# Если перед последним аргументом метода стоит &, то этому методу можно передать блок, и этот блок будет присвоен последнему параметру. В случае, если в списке аргументов присутствуют и *par, и &par, тогда &par должен появиться позже.
def oo(par, &block) # & указывает на то что передается блок
  block.call # содержание блока вызывается методом call
end
oo('a') { puts 'foo' } # блок передается после параметров

some_meth{|e| block.call(e)} # тоже самое что и...
some_meth(&block)

# Пример. Помещаем блоки в хэш
@hh = {}
def on(par, &block)
  @hh[par] = block
end
on('a') { puts 'foo' }
on('b') { puts 'bar' }
on('c') { puts 'baz' }
@hh.each_value(&:call) #=> foo bar baz

# Пример с взаимодействием с переменной и блока
def all? array, &block
  array.all?(&block)
end
def all? *args, &block
  args.all?(&block)
end


puts
puts '                                Блоки объявления начала и конца кода(BEGIN и END)'

# Ключевое слово/оператор BEGIN объявляет блок который будет исполнен в самом начале программы
puts "This is main Ruby Program"
BEGIN {
  puts "Initializing Ruby Program" # Эта строка будет 1й в прграмме
}
#=> Initializing Ruby Program
#=> This is main Ruby Program


# Ключевое слово/оператор END объявляет блок который будет исполнен в самом конце программы
END {
  puts "Terminating Ruby Program" #  эта строка будет последней в программе
}
puts "This is main Ruby Program"
#=> This is main Ruby Program
#=> Terminating Ruby Program


puts
puts '                                           Метод от объекта'

#  Можно добавлять методы не только в любые классы, но и в любые объекты. Например, вы можете добавить к некоторой строке произвольный метод.
str = "Привет"

def str.bye # str. указывает, кому принадлежит метод (по умолчанию Object) bye - имя метода
  "Пока!"
end

puts str.bye #=> Пока!


puts
puts '                                            lambda-функции'

# lambda-функции(так же их называют lambda-выражения) - это указатель на функцию у которой нет названия/имени
# Иногда переменным очень удобно присваивать указатели на какие либо функции(а не только на их вызов как при стандартном синтаксисе), например для того чтоб поместить в массив множество указателей на функцию и потом вызывать их.
# Указываем некой переменной на функцию при помощи ключевого слова lambda:
x = lambda {'какая-то функция'}      # Синтаксис 1
x = lambda {|a| 'какая-то функция'}  # с параметром
x = lambda do |a|                    # Синтаксис 2
  'какая-то функция'
end

proc1 = proc { | i | i * 2 } # proc - альтернативный синтаксис лямды ???

lambda{|a| a*4!=0}.class #=> Proc

x.call # Вызов lambda-функции производится ключевым словом call
x.call('какое-то значение для параметра a') # Вызов с заданием значения параметра

x.('какое-то значение для параметра a') # Вызов с заданием значения параметра 2(без имени метода == метод call)
test = lambda{|x| x + 10}
p test.(5) #=> 15

# Примечание: если функция содержит более 3х операторов то принято использовать обычные функции(методы), если 2 и меньше тогда lambda-функции.

# Пример использования 1:
say_hi = lambda { puts 'hi'}
say_bay = lambda { puts 'bay'}
week = [say_hi, say_hi, say_hi, say_hi, say_hi, say_bay, say_bay]
week.each {|f| f.call} #=> "hi" "hi" "hi" "hi" "hi" "bay" "bay"

# Пример использования 2:
sub_10 = lambda {|x| return x - 10} # return в lambda-функции так же необязателен как и в обычной
a = sub_10.call 1000
puts a #=> 990

# Пример использования 3(Однорукий бандит):
add_10 = lambda {|x| x + 10}
add_20 = lambda {|x| x + 20}
sub_5 = lambda {|x| x - 5}
hh = {11 => add_10, 22 => add_10, 33 => add_10, 44 => add_10, 55 => add_10, 66 => add_10, 77 => add_20, 88 => add_20, 99 => add_20}
sum = 1000
loop do
	puts "sum is #{sum}"
	gets

	res = rand(100)
	puts "res is #{res}"

	if hh[res]
		sum = hh[res].call sum
	else
		sum = sub_5.call sum
	end
end


# Альтернативный синтаксис для lamda-выражений(с помощью символа lambda rocket):
sub_10 = -> (x) {x - 10}
a = sub_10.call 1000
puts a

# Передача аргументов массивом
ff = ->(x){x.split.map(&:to_i).inject(:^)}
p ff['1 0 0 1 0'] #=> 0


# Синтаксис передачи лямбда функций и аргументов в функцию
def compose(add, id)
  # *args в данном случае это 0, так что можно было написать и просто arg
  ->(*args){add.(id.(*args))}
  # id.(*args) => ->(a){a}  => ->(a){0}  => 0
  # add.(id.(*args)) => add.(id.(0)) => ->(a){a + 1}  => ->(a){0 + 1}  =>  1
end
add = ->(a){a + 1}
id  = ->(a){a}
p compose(add,id).(0) #=> 1
p compose(add,id) #=> #<Proc:0x0000028151244af8 E:/doc/ruby_exemples/test3.rb:3 (lambda)>


# Вызов лямбды без метода call как блока
def array_procs(arr, *pr)
  res = [*arr]
  pr.each do |block|
    res = res.map(&block)
  end
  res
end
p array_procs([1, 2, 4, 6], lambda{|i| i * 2}, lambda{|i| i + 1})# [3, 5, 9, 13]


puts
puts '                                        alias (псевдонимы методов)'

# Дает псевдоним методам или глобальным переменным. Псевдонимы не могут быть определены в теле метода.
# Псевдоним метода сохраняет текущее определение метода, даже если методы переопределены.
# Создание псевдонимов для пронумерованных глобальных переменных ($1, $2,...) запрещено. Переопределение встроенных глобальных переменных может вызвать серьезные проблемы.

# Синтаксис для метода: alias alias_method_name method_name => method_name === alias_method_name
def bar
  puts 'i am Kroker'
end
alias foo bar #=> Здесь мы определили псевдоним foo для метода bar
foo #=> "i am Kroker"

# Псевдоним метода сохраняет текущее определение метода, даже если методы переопределены.
def bar
  puts 'aaa'
end
bar #=> "aaa"
foo #=> "i am Kroker"

# Синтаксис для глоб переменной: alias global_variable_alias_name global_variable_name
$a = 10
alias $b $a #=> $b — это псевдоним для $a.
p $b #=> 10


puts
puts '                                      undef(отмена определения метода)'

# отменяет определение метода. undef не может появляться в теле метода

# undef method-name
def aaa
  puts 'aaa'
end
aaa #=> aaa
undef aaa
aaa #=> undefined local variable or method `aaa' for main:Object (NameError)


# Используя undef и alias , интерфейс класса можно изменить независимо от суперкласса, но обратите внимание, что это может привести к поломке программ внутренним вызовом метода self.
